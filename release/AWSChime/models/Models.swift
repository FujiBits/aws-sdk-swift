// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have permissions to perform the requested operation.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let code: ChimeClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeClientTypes.Account: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case accountStatus = "AccountStatus"
        case accountType = "AccountType"
        case awsAccountId = "AwsAccountId"
        case createdTimestamp = "CreatedTimestamp"
        case defaultLicense = "DefaultLicense"
        case name = "Name"
        case signinDelegateGroups = "SigninDelegateGroups"
        case supportedLicenses = "SupportedLicenses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let accountStatus = accountStatus {
            try encodeContainer.encode(accountStatus.rawValue, forKey: .accountStatus)
        }
        if let accountType = accountType {
            try encodeContainer.encode(accountType.rawValue, forKey: .accountType)
        }
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let defaultLicense = defaultLicense {
            try encodeContainer.encode(defaultLicense.rawValue, forKey: .defaultLicense)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let signinDelegateGroups = signinDelegateGroups {
            var signinDelegateGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signinDelegateGroups)
            for signindelegategrouplist0 in signinDelegateGroups {
                try signinDelegateGroupsContainer.encode(signindelegategrouplist0)
            }
        }
        if let supportedLicenses = supportedLicenses {
            var supportedLicensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedLicenses)
            for licenselist0 in supportedLicenses {
                try supportedLicensesContainer.encode(licenselist0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let accountTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AccountType.self, forKey: .accountType)
        accountType = accountTypeDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let defaultLicenseDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.License.self, forKey: .defaultLicense)
        defaultLicense = defaultLicenseDecoded
        let supportedLicensesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.License?].self, forKey: .supportedLicenses)
        var supportedLicensesDecoded0:[ChimeClientTypes.License]? = nil
        if let supportedLicensesContainer = supportedLicensesContainer {
            supportedLicensesDecoded0 = [ChimeClientTypes.License]()
            for string0 in supportedLicensesContainer {
                if let string0 = string0 {
                    supportedLicensesDecoded0?.append(string0)
                }
            }
        }
        supportedLicenses = supportedLicensesDecoded0
        let accountStatusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AccountStatus.self, forKey: .accountStatus)
        accountStatus = accountStatusDecoded
        let signinDelegateGroupsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SigninDelegateGroup?].self, forKey: .signinDelegateGroups)
        var signinDelegateGroupsDecoded0:[ChimeClientTypes.SigninDelegateGroup]? = nil
        if let signinDelegateGroupsContainer = signinDelegateGroupsContainer {
            signinDelegateGroupsDecoded0 = [ChimeClientTypes.SigninDelegateGroup]()
            for structure0 in signinDelegateGroupsContainer {
                if let structure0 = structure0 {
                    signinDelegateGroupsDecoded0?.append(structure0)
                }
            }
        }
        signinDelegateGroups = signinDelegateGroupsDecoded0
    }
}

extension ChimeClientTypes.Account: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Account(accountId: \(Swift.String(describing: accountId)), accountStatus: \(Swift.String(describing: accountStatus)), accountType: \(Swift.String(describing: accountType)), awsAccountId: \(Swift.String(describing: awsAccountId)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), defaultLicense: \(Swift.String(describing: defaultLicense)), name: \(Swift.String(describing: name)), signinDelegateGroups: \(Swift.String(describing: signinDelegateGroups)), supportedLicenses: \(Swift.String(describing: supportedLicenses)))"}
}

extension ChimeClientTypes {
    /// The Amazon Chime account details. An AWS account can have multiple Amazon Chime accounts.
    public struct Account: Swift.Equatable {
        /// The Amazon Chime account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// The status of the account.
        public var accountStatus: ChimeClientTypes.AccountStatus?
        /// The Amazon Chime account type. For more information about different account types, see
        ///     <a href="https://docs.aws.amazon.com/chime/latest/ag/manage-chime-account.html">Managing Your Amazon Chime Accounts in the Amazon Chime Administration
        ///                 Guide.
        public var accountType: ChimeClientTypes.AccountType?
        /// The AWS account ID.
        /// This member is required.
        public var awsAccountId: Swift.String?
        /// The Amazon Chime account creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The default license for the Amazon Chime account.
        public var defaultLicense: ChimeClientTypes.License?
        /// The Amazon Chime account name.
        /// This member is required.
        public var name: Swift.String?
        /// The sign-in delegate groups associated with the account.
        public var signinDelegateGroups: [ChimeClientTypes.SigninDelegateGroup]?
        /// Supported licenses for the Amazon Chime account.
        public var supportedLicenses: [ChimeClientTypes.License]?

        public init (
            accountId: Swift.String? = nil,
            accountStatus: ChimeClientTypes.AccountStatus? = nil,
            accountType: ChimeClientTypes.AccountType? = nil,
            awsAccountId: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            defaultLicense: ChimeClientTypes.License? = nil,
            name: Swift.String? = nil,
            signinDelegateGroups: [ChimeClientTypes.SigninDelegateGroup]? = nil,
            supportedLicenses: [ChimeClientTypes.License]? = nil
        )
        {
            self.accountId = accountId
            self.accountStatus = accountStatus
            self.accountType = accountType
            self.awsAccountId = awsAccountId
            self.createdTimestamp = createdTimestamp
            self.defaultLicense = defaultLicense
            self.name = name
            self.signinDelegateGroups = signinDelegateGroups
            self.supportedLicenses = supportedLicenses
        }
    }

}

extension ChimeClientTypes.AccountSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableRemoteControl = "DisableRemoteControl"
        case enableDialOut = "EnableDialOut"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disableRemoteControl = disableRemoteControl {
            try encodeContainer.encode(disableRemoteControl, forKey: .disableRemoteControl)
        }
        if let enableDialOut = enableDialOut {
            try encodeContainer.encode(enableDialOut, forKey: .enableDialOut)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disableRemoteControlDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableRemoteControl)
        disableRemoteControl = disableRemoteControlDecoded
        let enableDialOutDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDialOut)
        enableDialOut = enableDialOutDecoded
    }
}

extension ChimeClientTypes.AccountSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountSettings(disableRemoteControl: \(Swift.String(describing: disableRemoteControl)), enableDialOut: \(Swift.String(describing: enableDialOut)))"}
}

extension ChimeClientTypes {
    /// Settings related to the Amazon Chime account. This includes settings that start or stop
    ///             remote control of shared screens, or start or stop the dial-out option in the Amazon Chime web application. For more information about these settings, see
    ///     <a href="https://docs.aws.amazon.com/chime/latest/ag/policies.html">Use the Policies Page in the Amazon Chime Administration Guide.
    public struct AccountSettings: Swift.Equatable {
        /// Setting that stops or starts remote control of shared screens during meetings.
        public var disableRemoteControl: Swift.Bool?
        /// Setting that allows meeting participants to choose the Call me at a phone number option. For more information, see
        ///     <a href="https://docs.aws.amazon.com/chime/latest/ug/chime-join-meeting.html">Join a Meeting without the Amazon Chime App.
        public var enableDialOut: Swift.Bool?

        public init (
            disableRemoteControl: Swift.Bool? = nil,
            enableDialOut: Swift.Bool? = nil
        )
        {
            self.disableRemoteControl = disableRemoteControl
            self.enableDialOut = enableDialOut
        }
    }

}

extension ChimeClientTypes {
    public enum AccountStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountStatus] {
            return [
                .active,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .suspended: return "Suspended"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountStatus(rawValue: rawValue) ?? AccountStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum AccountType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enterprisedirectory
        case enterpriselwa
        case enterpriseoidc
        case team
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountType] {
            return [
                .enterprisedirectory,
                .enterpriselwa,
                .enterpriseoidc,
                .team,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enterprisedirectory: return "EnterpriseDirectory"
            case .enterpriselwa: return "EnterpriseLWA"
            case .enterpriseoidc: return "EnterpriseOIDC"
            case .team: return "Team"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountType(rawValue: rawValue) ?? AccountType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.AlexaForBusinessMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alexaForBusinessRoomArn = "AlexaForBusinessRoomArn"
        case isAlexaForBusinessEnabled = "IsAlexaForBusinessEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alexaForBusinessRoomArn = alexaForBusinessRoomArn {
            try encodeContainer.encode(alexaForBusinessRoomArn, forKey: .alexaForBusinessRoomArn)
        }
        if let isAlexaForBusinessEnabled = isAlexaForBusinessEnabled {
            try encodeContainer.encode(isAlexaForBusinessEnabled, forKey: .isAlexaForBusinessEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isAlexaForBusinessEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAlexaForBusinessEnabled)
        isAlexaForBusinessEnabled = isAlexaForBusinessEnabledDecoded
        let alexaForBusinessRoomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alexaForBusinessRoomArn)
        alexaForBusinessRoomArn = alexaForBusinessRoomArnDecoded
    }
}

extension ChimeClientTypes.AlexaForBusinessMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlexaForBusinessMetadata(alexaForBusinessRoomArn: \(Swift.String(describing: alexaForBusinessRoomArn)), isAlexaForBusinessEnabled: \(Swift.String(describing: isAlexaForBusinessEnabled)))"}
}

extension ChimeClientTypes {
    /// The Alexa for Business metadata associated with an Amazon Chime user, used to integrate Alexa for Business with a device.
    public struct AlexaForBusinessMetadata: Swift.Equatable {
        /// The ARN of the room resource.
        public var alexaForBusinessRoomArn: Swift.String?
        /// Starts or stops Alexa for Business.
        public var isAlexaForBusinessEnabled: Swift.Bool?

        public init (
            alexaForBusinessRoomArn: Swift.String? = nil,
            isAlexaForBusinessEnabled: Swift.Bool? = nil
        )
        {
            self.alexaForBusinessRoomArn = alexaForBusinessRoomArn
            self.isAlexaForBusinessEnabled = isAlexaForBusinessEnabled
        }
    }

}

extension ChimeClientTypes.AppInstance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case createdTimestamp = "CreatedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ChimeClientTypes.AppInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstance(appInstanceArn: \(Swift.String(describing: appInstanceArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)))"}
}

extension ChimeClientTypes {
    /// The details of an AppInstance, an instance of an Amazon Chime SDK messaging application.
    public struct AppInstance: Swift.Equatable {
        /// The ARN of the messaging instance.
        public var appInstanceArn: Swift.String?
        /// The time at which an AppInstance was created. In epoch milliseconds.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time an AppInstance was last updated. In epoch milliseconds.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The metadata of an AppInstance.
        public var metadata: Swift.String?
        /// The name of an AppInstance.
        public var name: Swift.String?

        public init (
            appInstanceArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceArn = appInstanceArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeClientTypes.AppInstanceAdmin: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case admin = "Admin"
        case appInstanceArn = "AppInstanceArn"
        case createdTimestamp = "CreatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let admin = admin {
            try encodeContainer.encode(admin, forKey: .admin)
        }
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .admin)
        admin = adminDecoded
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension ChimeClientTypes.AppInstanceAdmin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceAdmin(admin: \(Swift.String(describing: admin)), appInstanceArn: \(Swift.String(describing: appInstanceArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)))"}
}

extension ChimeClientTypes {
    /// The details of an AppInstanceAdmin.
    public struct AppInstanceAdmin: Swift.Equatable {
        /// The AppInstanceAdmin data.
        public var admin: ChimeClientTypes.Identity?
        /// The ARN of the AppInstance for which the user is an administrator.
        public var appInstanceArn: Swift.String?
        /// The time at which an administrator was created.
        public var createdTimestamp: ClientRuntime.Date?

        public init (
            admin: ChimeClientTypes.Identity? = nil,
            appInstanceArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.admin = admin
            self.appInstanceArn = appInstanceArn
            self.createdTimestamp = createdTimestamp
        }
    }

}

extension ChimeClientTypes.AppInstanceAdminSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case admin = "Admin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let admin = admin {
            try encodeContainer.encode(admin, forKey: .admin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .admin)
        admin = adminDecoded
    }
}

extension ChimeClientTypes.AppInstanceAdminSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceAdminSummary(admin: \(Swift.String(describing: admin)))"}
}

extension ChimeClientTypes {
    /// Summary of the details of an AppInstanceAdmin.
    public struct AppInstanceAdminSummary: Swift.Equatable {
        /// The details of the AppInstanceAdmin.
        public var admin: ChimeClientTypes.Identity?

        public init (
            admin: ChimeClientTypes.Identity? = nil
        )
        {
            self.admin = admin
        }
    }

}

extension ChimeClientTypes {
    public enum AppInstanceDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case channel
        case channelmessage
        case sdkUnknown(Swift.String)

        public static var allCases: [AppInstanceDataType] {
            return [
                .channel,
                .channelmessage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .channel: return "Channel"
            case .channelmessage: return "ChannelMessage"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppInstanceDataType(rawValue: rawValue) ?? AppInstanceDataType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.AppInstanceRetentionSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelRetentionSettings = "ChannelRetentionSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelRetentionSettings = channelRetentionSettings {
            try encodeContainer.encode(channelRetentionSettings, forKey: .channelRetentionSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelRetentionSettings.self, forKey: .channelRetentionSettings)
        channelRetentionSettings = channelRetentionSettingsDecoded
    }
}

extension ChimeClientTypes.AppInstanceRetentionSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceRetentionSettings(channelRetentionSettings: \(Swift.String(describing: channelRetentionSettings)))"}
}

extension ChimeClientTypes {
    /// The details of the data-retention settings for an AppInstance.
    public struct AppInstanceRetentionSettings: Swift.Equatable {
        /// The length of time in days to retain the messages in a channel.
        public var channelRetentionSettings: ChimeClientTypes.ChannelRetentionSettings?

        public init (
            channelRetentionSettings: ChimeClientTypes.ChannelRetentionSettings? = nil
        )
        {
            self.channelRetentionSettings = channelRetentionSettings
        }
    }

}

extension ChimeClientTypes.AppInstanceStreamingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceDataType = "AppInstanceDataType"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceDataType = appInstanceDataType {
            try encodeContainer.encode(appInstanceDataType.rawValue, forKey: .appInstanceDataType)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceDataTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstanceDataType.self, forKey: .appInstanceDataType)
        appInstanceDataType = appInstanceDataTypeDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ChimeClientTypes.AppInstanceStreamingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceStreamingConfiguration(appInstanceDataType: \(Swift.String(describing: appInstanceDataType)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ChimeClientTypes {
    /// The details of the streaming configuration of an AppInstance.
    public struct AppInstanceStreamingConfiguration: Swift.Equatable {
        /// The type of data to be streamed.
        /// This member is required.
        public var appInstanceDataType: ChimeClientTypes.AppInstanceDataType?
        /// The resource ARN.
        /// This member is required.
        public var resourceArn: Swift.String?

        public init (
            appInstanceDataType: ChimeClientTypes.AppInstanceDataType? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.appInstanceDataType = appInstanceDataType
            self.resourceArn = resourceArn
        }
    }

}

extension ChimeClientTypes.AppInstanceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeClientTypes.AppInstanceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceSummary(appInstanceArn: \(Swift.String(describing: appInstanceArn)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)))"}
}

extension ChimeClientTypes {
    /// Summary of the data for an AppInstance.
    public struct AppInstanceSummary: Swift.Equatable {
        /// The AppInstance ARN.
        public var appInstanceArn: Swift.String?
        /// The metadata of the AppInstance.
        public var metadata: Swift.String?
        /// The name of the AppInstance.
        public var name: Swift.String?

        public init (
            appInstanceArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceArn = appInstanceArn
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeClientTypes.AppInstanceUser: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case createdTimestamp = "CreatedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceUserArn = appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ChimeClientTypes.AppInstanceUser: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUser(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)))"}
}

extension ChimeClientTypes {
    /// The details of an AppInstanceUser.
    public struct AppInstanceUser: Swift.Equatable {
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The time at which the AppInstanceUser was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which the AppInstanceUser was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The metadata of the AppInstanceUser.
        public var metadata: Swift.String?
        /// The name of the AppInstanceUser.
        public var name: Swift.String?

        public init (
            appInstanceUserArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceUserArn = appInstanceUserArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeClientTypes.AppInstanceUserMembershipSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readMarkerTimestamp = "ReadMarkerTimestamp"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readMarkerTimestamp = readMarkerTimestamp {
            try encodeContainer.encode(readMarkerTimestamp.timeIntervalSince1970, forKey: .readMarkerTimestamp)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let readMarkerTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .readMarkerTimestamp)
        readMarkerTimestamp = readMarkerTimestampDecoded
    }
}

extension ChimeClientTypes.AppInstanceUserMembershipSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUserMembershipSummary(readMarkerTimestamp: \(Swift.String(describing: readMarkerTimestamp)), type: \(Swift.String(describing: type)))"}
}

extension ChimeClientTypes {
    /// Summary of the membership details of an AppInstanceUser.
    public struct AppInstanceUserMembershipSummary: Swift.Equatable {
        /// The time at which a message was last read.
        public var readMarkerTimestamp: ClientRuntime.Date?
        /// The type of ChannelMembership.
        public var type: ChimeClientTypes.ChannelMembershipType?

        public init (
            readMarkerTimestamp: ClientRuntime.Date? = nil,
            type: ChimeClientTypes.ChannelMembershipType? = nil
        )
        {
            self.readMarkerTimestamp = readMarkerTimestamp
            self.type = type
        }
    }

}

extension ChimeClientTypes.AppInstanceUserSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceUserArn = appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeClientTypes.AppInstanceUserSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUserSummary(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)))"}
}

extension ChimeClientTypes {
    /// Summary of the details of an AppInstanceUser.
    public struct AppInstanceUserSummary: Swift.Equatable {
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The metadata of the AppInstanceUser.
        public var metadata: Swift.String?
        /// The name of an AppInstanceUser.
        public var name: Swift.String?

        public init (
            appInstanceUserArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceUserArn = appInstanceUserArn
            self.metadata = metadata
            self.name = name
        }
    }

}

public struct AssociatePhoneNumberWithUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePhoneNumberWithUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociatePhoneNumberWithUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePhoneNumberWithUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociatePhoneNumberWithUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePhoneNumberWithUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePhoneNumberWithUserOutputError>
}

extension AssociatePhoneNumberWithUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatePhoneNumberWithUserInput(accountId: \(Swift.String(describing: accountId)), e164PhoneNumber: \(Swift.String(describing: e164PhoneNumber)), userId: \(Swift.String(describing: userId)))"}
}

extension AssociatePhoneNumberWithUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumber = "E164PhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumber = e164PhoneNumber {
            try encodeContainer.encode(e164PhoneNumber, forKey: .e164PhoneNumber)
        }
    }
}

public struct AssociatePhoneNumberWithUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePhoneNumberWithUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociatePhoneNumberWithUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePhoneNumberWithUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociatePhoneNumberWithUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePhoneNumberWithUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePhoneNumberWithUserOutputError>
}

public struct AssociatePhoneNumberWithUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePhoneNumberWithUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociatePhoneNumberWithUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePhoneNumberWithUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "associate-phone-number"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociatePhoneNumberWithUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePhoneNumberWithUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePhoneNumberWithUserOutputError>
}

public struct AssociatePhoneNumberWithUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePhoneNumberWithUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociatePhoneNumberWithUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePhoneNumberWithUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociatePhoneNumberWithUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePhoneNumberWithUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePhoneNumberWithUserOutputError>
}

public struct AssociatePhoneNumberWithUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePhoneNumberWithUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociatePhoneNumberWithUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePhoneNumberWithUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let userId = input.userId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("userId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociatePhoneNumberWithUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePhoneNumberWithUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePhoneNumberWithUserOutputError>
}

public struct AssociatePhoneNumberWithUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The phone number, in E.164 format.
    /// This member is required.
    public var e164PhoneNumber: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        e164PhoneNumber: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.e164PhoneNumber = e164PhoneNumber
        self.userId = userId
    }
}

struct AssociatePhoneNumberWithUserInputBody: Swift.Equatable {
    public let e164PhoneNumber: Swift.String?
}

extension AssociatePhoneNumberWithUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumber = "E164PhoneNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .e164PhoneNumber)
        e164PhoneNumber = e164PhoneNumberDecoded
    }
}

extension AssociatePhoneNumberWithUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociatePhoneNumberWithUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociatePhoneNumberWithUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociatePhoneNumberWithUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatePhoneNumberWithUserOutputResponse()"}
}

extension AssociatePhoneNumberWithUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociatePhoneNumberWithUserOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociatePhoneNumberWithUserOutputResponseBody: Swift.Equatable {
}

extension AssociatePhoneNumberWithUserOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePhoneNumbersWithVoiceConnectorGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociatePhoneNumbersWithVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociatePhoneNumbersWithVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePhoneNumbersWithVoiceConnectorGroupOutputError>
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatePhoneNumbersWithVoiceConnectorGroupInput(e164PhoneNumbers: \(Swift.String(describing: e164PhoneNumbers)), forceAssociate: \(Swift.String(describing: forceAssociate)), voiceConnectorGroupId: \(Swift.String(describing: voiceConnectorGroupId)))"}
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumberlist0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumberlist0)
            }
        }
        if let forceAssociate = forceAssociate {
            try encodeContainer.encode(forceAssociate, forKey: .forceAssociate)
        }
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePhoneNumbersWithVoiceConnectorGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociatePhoneNumbersWithVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociatePhoneNumbersWithVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePhoneNumbersWithVoiceConnectorGroupOutputError>
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePhoneNumbersWithVoiceConnectorGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociatePhoneNumbersWithVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "associate-phone-numbers"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociatePhoneNumbersWithVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePhoneNumbersWithVoiceConnectorGroupOutputError>
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePhoneNumbersWithVoiceConnectorGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociatePhoneNumbersWithVoiceConnectorGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociatePhoneNumbersWithVoiceConnectorGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePhoneNumbersWithVoiceConnectorGroupOutputError>
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePhoneNumbersWithVoiceConnectorGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociatePhoneNumbersWithVoiceConnectorGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorGroupId = input.voiceConnectorGroupId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorGroupId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociatePhoneNumbersWithVoiceConnectorGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePhoneNumbersWithVoiceConnectorGroupOutputError>
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupInput: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// If true, associates the provided phone numbers with the provided Amazon Chime Voice Connector Group and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.
    public var forceAssociate: Swift.Bool?
    /// The Amazon Chime Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init (
        e164PhoneNumbers: [Swift.String]? = nil,
        forceAssociate: Swift.Bool? = nil,
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.forceAssociate = forceAssociate
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorGroupInputBody: Swift.Equatable {
    public let e164PhoneNumbers: [Swift.String]?
    public let forceAssociate: Swift.Bool?
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let forceAssociateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceAssociate)
        forceAssociate = forceAssociateDecoded
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociatePhoneNumbersWithVoiceConnectorGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse(phoneNumberErrors: \(Swift.String(describing: phoneNumberErrors)))"}
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init (
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
    public let phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePhoneNumbersWithVoiceConnectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociatePhoneNumbersWithVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociatePhoneNumbersWithVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePhoneNumbersWithVoiceConnectorOutputError>
}

extension AssociatePhoneNumbersWithVoiceConnectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatePhoneNumbersWithVoiceConnectorInput(e164PhoneNumbers: \(Swift.String(describing: e164PhoneNumbers)), forceAssociate: \(Swift.String(describing: forceAssociate)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension AssociatePhoneNumbersWithVoiceConnectorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumberlist0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumberlist0)
            }
        }
        if let forceAssociate = forceAssociate {
            try encodeContainer.encode(forceAssociate, forKey: .forceAssociate)
        }
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePhoneNumbersWithVoiceConnectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociatePhoneNumbersWithVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociatePhoneNumbersWithVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePhoneNumbersWithVoiceConnectorOutputError>
}

public struct AssociatePhoneNumbersWithVoiceConnectorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePhoneNumbersWithVoiceConnectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociatePhoneNumbersWithVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "associate-phone-numbers"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociatePhoneNumbersWithVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePhoneNumbersWithVoiceConnectorOutputError>
}

public struct AssociatePhoneNumbersWithVoiceConnectorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePhoneNumbersWithVoiceConnectorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociatePhoneNumbersWithVoiceConnectorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociatePhoneNumbersWithVoiceConnectorInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePhoneNumbersWithVoiceConnectorOutputError>
}

public struct AssociatePhoneNumbersWithVoiceConnectorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePhoneNumbersWithVoiceConnectorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociatePhoneNumbersWithVoiceConnectorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociatePhoneNumbersWithVoiceConnectorInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePhoneNumbersWithVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePhoneNumbersWithVoiceConnectorOutputError>
}

public struct AssociatePhoneNumbersWithVoiceConnectorInput: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// If true, associates the provided phone numbers with the provided Amazon Chime Voice Connector and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.
    public var forceAssociate: Swift.Bool?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        e164PhoneNumbers: [Swift.String]? = nil,
        forceAssociate: Swift.Bool? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.forceAssociate = forceAssociate
        self.voiceConnectorId = voiceConnectorId
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorInputBody: Swift.Equatable {
    public let e164PhoneNumbers: [Swift.String]?
    public let forceAssociate: Swift.Bool?
}

extension AssociatePhoneNumbersWithVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let forceAssociateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceAssociate)
        forceAssociate = forceAssociateDecoded
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociatePhoneNumbersWithVoiceConnectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociatePhoneNumbersWithVoiceConnectorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatePhoneNumbersWithVoiceConnectorOutputResponse(phoneNumberErrors: \(Swift.String(describing: phoneNumberErrors)))"}
}

extension AssociatePhoneNumbersWithVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociatePhoneNumbersWithVoiceConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorOutputResponse: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and
    ///     error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init (
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorOutputResponseBody: Swift.Equatable {
    public let phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?
}

extension AssociatePhoneNumbersWithVoiceConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

public struct AssociateSigninDelegateGroupsWithAccountInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateSigninDelegateGroupsWithAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateSigninDelegateGroupsWithAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateSigninDelegateGroupsWithAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateSigninDelegateGroupsWithAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateSigninDelegateGroupsWithAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateSigninDelegateGroupsWithAccountOutputError>
}

extension AssociateSigninDelegateGroupsWithAccountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateSigninDelegateGroupsWithAccountInput(accountId: \(Swift.String(describing: accountId)), signinDelegateGroups: \(Swift.String(describing: signinDelegateGroups)))"}
}

extension AssociateSigninDelegateGroupsWithAccountInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signinDelegateGroups = "SigninDelegateGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signinDelegateGroups = signinDelegateGroups {
            var signinDelegateGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signinDelegateGroups)
            for signindelegategrouplist0 in signinDelegateGroups {
                try signinDelegateGroupsContainer.encode(signindelegategrouplist0)
            }
        }
    }
}

public struct AssociateSigninDelegateGroupsWithAccountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateSigninDelegateGroupsWithAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateSigninDelegateGroupsWithAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateSigninDelegateGroupsWithAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateSigninDelegateGroupsWithAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateSigninDelegateGroupsWithAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateSigninDelegateGroupsWithAccountOutputError>
}

public struct AssociateSigninDelegateGroupsWithAccountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateSigninDelegateGroupsWithAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateSigninDelegateGroupsWithAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateSigninDelegateGroupsWithAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "associate-signin-delegate-groups"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateSigninDelegateGroupsWithAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateSigninDelegateGroupsWithAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateSigninDelegateGroupsWithAccountOutputError>
}

public struct AssociateSigninDelegateGroupsWithAccountInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateSigninDelegateGroupsWithAccountInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateSigninDelegateGroupsWithAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateSigninDelegateGroupsWithAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateSigninDelegateGroupsWithAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateSigninDelegateGroupsWithAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateSigninDelegateGroupsWithAccountOutputError>
}

public struct AssociateSigninDelegateGroupsWithAccountInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateSigninDelegateGroupsWithAccountInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateSigninDelegateGroupsWithAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateSigninDelegateGroupsWithAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateSigninDelegateGroupsWithAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateSigninDelegateGroupsWithAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateSigninDelegateGroupsWithAccountOutputError>
}

public struct AssociateSigninDelegateGroupsWithAccountInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The sign-in delegate groups.
    /// This member is required.
    public var signinDelegateGroups: [ChimeClientTypes.SigninDelegateGroup]?

    public init (
        accountId: Swift.String? = nil,
        signinDelegateGroups: [ChimeClientTypes.SigninDelegateGroup]? = nil
    )
    {
        self.accountId = accountId
        self.signinDelegateGroups = signinDelegateGroups
    }
}

struct AssociateSigninDelegateGroupsWithAccountInputBody: Swift.Equatable {
    public let signinDelegateGroups: [ChimeClientTypes.SigninDelegateGroup]?
}

extension AssociateSigninDelegateGroupsWithAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signinDelegateGroups = "SigninDelegateGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signinDelegateGroupsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SigninDelegateGroup?].self, forKey: .signinDelegateGroups)
        var signinDelegateGroupsDecoded0:[ChimeClientTypes.SigninDelegateGroup]? = nil
        if let signinDelegateGroupsContainer = signinDelegateGroupsContainer {
            signinDelegateGroupsDecoded0 = [ChimeClientTypes.SigninDelegateGroup]()
            for structure0 in signinDelegateGroupsContainer {
                if let structure0 = structure0 {
                    signinDelegateGroupsDecoded0?.append(structure0)
                }
            }
        }
        signinDelegateGroups = signinDelegateGroupsDecoded0
    }
}

extension AssociateSigninDelegateGroupsWithAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateSigninDelegateGroupsWithAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateSigninDelegateGroupsWithAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateSigninDelegateGroupsWithAccountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateSigninDelegateGroupsWithAccountOutputResponse()"}
}

extension AssociateSigninDelegateGroupsWithAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateSigninDelegateGroupsWithAccountOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateSigninDelegateGroupsWithAccountOutputResponseBody: Swift.Equatable {
}

extension AssociateSigninDelegateGroupsWithAccountOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ChimeClientTypes.Attendee: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendeeId = "AttendeeId"
        case externalUserId = "ExternalUserId"
        case joinToken = "JoinToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendeeId = attendeeId {
            try encodeContainer.encode(attendeeId, forKey: .attendeeId)
        }
        if let externalUserId = externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
        if let joinToken = joinToken {
            try encodeContainer.encode(joinToken, forKey: .joinToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
        let attendeeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attendeeId)
        attendeeId = attendeeIdDecoded
        let joinTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .joinToken)
        joinToken = joinTokenDecoded
    }
}

extension ChimeClientTypes.Attendee: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attendee(attendeeId: \(Swift.String(describing: attendeeId)), externalUserId: \(Swift.String(describing: externalUserId)), joinToken: \(Swift.String(describing: joinToken)))"}
}

extension ChimeClientTypes {
    ///
    /// An Amazon Chime SDK meeting attendee. Includes a unique
    /// AttendeeId
    /// and
    /// JoinToken
    /// . The
    /// JoinToken
    /// allows a client to authenticate and join as the specified attendee. The
    /// JoinToken
    /// expires when the meeting ends or when
    /// DeleteAttendee
    /// is called. After that, the attendee is unable to join the meeting.
    ///
    ///
    ///          We recommend securely transferring each JoinToken from your server application
    ///             to the client so that no other client has access to the token except for the one
    ///             authorized to represent the attendee.
    public struct Attendee: Swift.Equatable {
        /// The Amazon Chime SDK attendee ID.
        public var attendeeId: Swift.String?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
        public var externalUserId: Swift.String?
        /// The join token used by the Amazon Chime SDK attendee.
        public var joinToken: Swift.String?

        public init (
            attendeeId: Swift.String? = nil,
            externalUserId: Swift.String? = nil,
            joinToken: Swift.String? = nil
        )
        {
            self.attendeeId = attendeeId
            self.externalUserId = externalUserId
            self.joinToken = joinToken
        }
    }

}

extension BadRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequestException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    public let code: ChimeClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeClientTypes.BatchChannelMemberships: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case invitedBy = "InvitedBy"
        case members = "Members"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let invitedBy = invitedBy {
            try encodeContainer.encode(invitedBy, forKey: .invitedBy)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for members0 in members {
                try membersContainer.encode(members0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitedByDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .invitedBy)
        invitedBy = invitedByDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let membersContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Identity?].self, forKey: .members)
        var membersDecoded0:[ChimeClientTypes.Identity]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [ChimeClientTypes.Identity]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension ChimeClientTypes.BatchChannelMemberships: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchChannelMemberships(channelArn: \(Swift.String(describing: channelArn)), invitedBy: \(Swift.String(describing: invitedBy)), members: \(Swift.String(describing: members)), type: \(Swift.String(describing: type)))"}
}

extension ChimeClientTypes {
    /// The membership information, including member ARNs, the channel ARN, and membership
    ///          types.
    public struct BatchChannelMemberships: Swift.Equatable {
        /// The ARN of the channel to which you're adding users.
        public var channelArn: Swift.String?
        /// The identifier of the member who invited another member.
        public var invitedBy: ChimeClientTypes.Identity?
        /// The users successfully added to the request.
        public var members: [ChimeClientTypes.Identity]?
        /// The membership types set for the channel users.
        public var type: ChimeClientTypes.ChannelMembershipType?

        public init (
            channelArn: Swift.String? = nil,
            invitedBy: ChimeClientTypes.Identity? = nil,
            members: [ChimeClientTypes.Identity]? = nil,
            type: ChimeClientTypes.ChannelMembershipType? = nil
        )
        {
            self.channelArn = channelArn
            self.invitedBy = invitedBy
            self.members = members
            self.type = type
        }
    }

}

public struct BatchCreateAttendeeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateAttendeeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCreateAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCreateAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateAttendeeOutputError>
}

extension BatchCreateAttendeeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateAttendeeInput(attendees: \(Swift.String(describing: attendees)), meetingId: \(Swift.String(describing: meetingId)))"}
}

extension BatchCreateAttendeeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendees = attendees {
            var attendeesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attendees)
            for createattendeerequestitemlist0 in attendees {
                try attendeesContainer.encode(createattendeerequestitemlist0)
            }
        }
    }
}

public struct BatchCreateAttendeeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateAttendeeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCreateAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCreateAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateAttendeeOutputError>
}

public struct BatchCreateAttendeeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateAttendeeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCreateAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "batch-create"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCreateAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateAttendeeOutputError>
}

public struct BatchCreateAttendeeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateAttendeeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchCreateAttendeeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchCreateAttendeeInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateAttendeeOutputError>
}

public struct BatchCreateAttendeeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateAttendeeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchCreateAttendeeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())/attendees"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchCreateAttendeeInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateAttendeeOutputError>
}

public struct BatchCreateAttendeeInput: Swift.Equatable {
    /// The request containing the attendees to create.
    /// This member is required.
    public var attendees: [ChimeClientTypes.CreateAttendeeRequestItem]?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init (
        attendees: [ChimeClientTypes.CreateAttendeeRequestItem]? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendees = attendees
        self.meetingId = meetingId
    }
}

struct BatchCreateAttendeeInputBody: Swift.Equatable {
    public let attendees: [ChimeClientTypes.CreateAttendeeRequestItem]?
}

extension BatchCreateAttendeeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.CreateAttendeeRequestItem?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeClientTypes.CreateAttendeeRequestItem]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeClientTypes.CreateAttendeeRequestItem]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
    }
}

extension BatchCreateAttendeeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCreateAttendeeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchCreateAttendeeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCreateAttendeeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateAttendeeOutputResponse(attendees: \(Swift.String(describing: attendees)), errors: \(Swift.String(describing: errors)))"}
}

extension BatchCreateAttendeeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchCreateAttendeeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attendees = output.attendees
            self.errors = output.errors
        } else {
            self.attendees = nil
            self.errors = nil
        }
    }
}

public struct BatchCreateAttendeeOutputResponse: Swift.Equatable {
    /// The attendee information, including attendees IDs and join tokens.
    public var attendees: [ChimeClientTypes.Attendee]?
    /// If the action fails for one or more of the attendees in the request, a list of the attendees is returned, along with error codes and error messages.
    public var errors: [ChimeClientTypes.CreateAttendeeError]?

    public init (
        attendees: [ChimeClientTypes.Attendee]? = nil,
        errors: [ChimeClientTypes.CreateAttendeeError]? = nil
    )
    {
        self.attendees = attendees
        self.errors = errors
    }
}

struct BatchCreateAttendeeOutputResponseBody: Swift.Equatable {
    public let attendees: [ChimeClientTypes.Attendee]?
    public let errors: [ChimeClientTypes.CreateAttendeeError]?
}

extension BatchCreateAttendeeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Attendee?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeClientTypes.Attendee]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeClientTypes.Attendee]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.CreateAttendeeError?].self, forKey: .errors)
        var errorsDecoded0:[ChimeClientTypes.CreateAttendeeError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ChimeClientTypes.CreateAttendeeError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension ChimeClientTypes.BatchCreateChannelMembershipError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case memberArn = "MemberArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let memberArn = memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeClientTypes.BatchCreateChannelMembershipError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateChannelMembershipError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), memberArn: \(Swift.String(describing: memberArn)))"}
}

extension ChimeClientTypes {
    /// A list of failed member ARNs, error codes, and error messages.
    public struct BatchCreateChannelMembershipError: Swift.Equatable {
        /// The error code.
        public var errorCode: ChimeClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The ARN of the member that the service couldn't add.
        public var memberArn: Swift.String?

        public init (
            errorCode: ChimeClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            memberArn: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.memberArn = memberArn
        }
    }

}

public struct BatchCreateChannelMembershipInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateChannelMembershipInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCreateChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCreateChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateChannelMembershipOutputError>
}

extension BatchCreateChannelMembershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateChannelMembershipInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), memberArns: \(Swift.String(describing: memberArns)), type: \(Swift.String(describing: type)))"}
}

extension BatchCreateChannelMembershipInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArns = "MemberArns"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArns = memberArns {
            var memberArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memberArns)
            for memberarns0 in memberArns {
                try memberArnsContainer.encode(memberarns0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct BatchCreateChannelMembershipInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateChannelMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCreateChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCreateChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateChannelMembershipOutputError>
}

public struct BatchCreateChannelMembershipInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateChannelMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCreateChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "batch-create"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCreateChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateChannelMembershipOutputError>
}

public struct BatchCreateChannelMembershipInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateChannelMembershipInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchCreateChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchCreateChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateChannelMembershipOutputError>
}

public struct BatchCreateChannelMembershipInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateChannelMembershipInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchCreateChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/memberships"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchCreateChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateChannelMembershipOutputError>
}

public struct BatchCreateChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel to which you're adding users.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARNs of the members you want to add to the channel.
    /// This member is required.
    public var memberArns: [Swift.String]?
    /// The membership type of a user, DEFAULT or HIDDEN. Default
    ///          members are always returned as part of ListChannelMemberships. Hidden members
    ///          are only returned if the type filter in ListChannelMemberships equals
    ///             HIDDEN. Otherwise hidden members are not returned. This is only supported
    ///          by moderators.
    public var type: ChimeClientTypes.ChannelMembershipType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArns: [Swift.String]? = nil,
        type: ChimeClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArns = memberArns
        self.type = type
    }
}

struct BatchCreateChannelMembershipInputBody: Swift.Equatable {
    public let type: ChimeClientTypes.ChannelMembershipType?
    public let memberArns: [Swift.String]?
}

extension BatchCreateChannelMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArns = "MemberArns"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let memberArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .memberArns)
        var memberArnsDecoded0:[Swift.String]? = nil
        if let memberArnsContainer = memberArnsContainer {
            memberArnsDecoded0 = [Swift.String]()
            for string0 in memberArnsContainer {
                if let string0 = string0 {
                    memberArnsDecoded0?.append(string0)
                }
            }
        }
        memberArns = memberArnsDecoded0
    }
}

extension BatchCreateChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCreateChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchCreateChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCreateChannelMembershipOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateChannelMembershipOutputResponse(batchChannelMemberships: \(Swift.String(describing: batchChannelMemberships)), errors: \(Swift.String(describing: errors)))"}
}

extension BatchCreateChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchCreateChannelMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchChannelMemberships = output.batchChannelMemberships
            self.errors = output.errors
        } else {
            self.batchChannelMemberships = nil
            self.errors = nil
        }
    }
}

public struct BatchCreateChannelMembershipOutputResponse: Swift.Equatable {
    /// The list of channel memberships in the response.
    public var batchChannelMemberships: ChimeClientTypes.BatchChannelMemberships?
    /// If the action fails for one or more of the memberships in the request, a list of the
    ///          memberships is returned, along with error codes and error messages.
    public var errors: [ChimeClientTypes.BatchCreateChannelMembershipError]?

    public init (
        batchChannelMemberships: ChimeClientTypes.BatchChannelMemberships? = nil,
        errors: [ChimeClientTypes.BatchCreateChannelMembershipError]? = nil
    )
    {
        self.batchChannelMemberships = batchChannelMemberships
        self.errors = errors
    }
}

struct BatchCreateChannelMembershipOutputResponseBody: Swift.Equatable {
    public let batchChannelMemberships: ChimeClientTypes.BatchChannelMemberships?
    public let errors: [ChimeClientTypes.BatchCreateChannelMembershipError]?
}

extension BatchCreateChannelMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchChannelMemberships = "BatchChannelMemberships"
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchChannelMembershipsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.BatchChannelMemberships.self, forKey: .batchChannelMemberships)
        batchChannelMemberships = batchChannelMembershipsDecoded
        let errorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.BatchCreateChannelMembershipError?].self, forKey: .errors)
        var errorsDecoded0:[ChimeClientTypes.BatchCreateChannelMembershipError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ChimeClientTypes.BatchCreateChannelMembershipError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct BatchCreateRoomMembershipInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateRoomMembershipInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCreateRoomMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCreateRoomMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateRoomMembershipOutputError>
}

extension BatchCreateRoomMembershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateRoomMembershipInput(accountId: \(Swift.String(describing: accountId)), membershipItemList: \(Swift.String(describing: membershipItemList)), roomId: \(Swift.String(describing: roomId)))"}
}

extension BatchCreateRoomMembershipInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case membershipItemList = "MembershipItemList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let membershipItemList = membershipItemList {
            var membershipItemListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .membershipItemList)
            for membershipitemlist0 in membershipItemList {
                try membershipItemListContainer.encode(membershipitemlist0)
            }
        }
    }
}

public struct BatchCreateRoomMembershipInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateRoomMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCreateRoomMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCreateRoomMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateRoomMembershipOutputError>
}

public struct BatchCreateRoomMembershipInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateRoomMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCreateRoomMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "batch-create"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCreateRoomMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateRoomMembershipOutputError>
}

public struct BatchCreateRoomMembershipInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateRoomMembershipInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchCreateRoomMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchCreateRoomMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateRoomMembershipOutputError>
}

public struct BatchCreateRoomMembershipInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateRoomMembershipInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchCreateRoomMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let roomId = input.roomId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("roomId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/memberships"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchCreateRoomMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateRoomMembershipOutputError>
}

public struct BatchCreateRoomMembershipInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The list of membership items.
    /// This member is required.
    public var membershipItemList: [ChimeClientTypes.MembershipItem]?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        membershipItemList: [ChimeClientTypes.MembershipItem]? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.membershipItemList = membershipItemList
        self.roomId = roomId
    }
}

struct BatchCreateRoomMembershipInputBody: Swift.Equatable {
    public let membershipItemList: [ChimeClientTypes.MembershipItem]?
}

extension BatchCreateRoomMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case membershipItemList = "MembershipItemList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipItemListContainer = try containerValues.decodeIfPresent([ChimeClientTypes.MembershipItem?].self, forKey: .membershipItemList)
        var membershipItemListDecoded0:[ChimeClientTypes.MembershipItem]? = nil
        if let membershipItemListContainer = membershipItemListContainer {
            membershipItemListDecoded0 = [ChimeClientTypes.MembershipItem]()
            for structure0 in membershipItemListContainer {
                if let structure0 = structure0 {
                    membershipItemListDecoded0?.append(structure0)
                }
            }
        }
        membershipItemList = membershipItemListDecoded0
    }
}

extension BatchCreateRoomMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCreateRoomMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchCreateRoomMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCreateRoomMembershipOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateRoomMembershipOutputResponse(errors: \(Swift.String(describing: errors)))"}
}

extension BatchCreateRoomMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchCreateRoomMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchCreateRoomMembershipOutputResponse: Swift.Equatable {
    /// If the action fails for one or more of the member IDs in the request, a list of the member IDs is returned, along with error codes and error messages.
    public var errors: [ChimeClientTypes.MemberError]?

    public init (
        errors: [ChimeClientTypes.MemberError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchCreateRoomMembershipOutputResponseBody: Swift.Equatable {
    public let errors: [ChimeClientTypes.MemberError]?
}

extension BatchCreateRoomMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.MemberError?].self, forKey: .errors)
        var errorsDecoded0:[ChimeClientTypes.MemberError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ChimeClientTypes.MemberError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct BatchDeletePhoneNumberInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeletePhoneNumberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeletePhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeletePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeletePhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeletePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeletePhoneNumberOutputError>
}

extension BatchDeletePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeletePhoneNumberInput(phoneNumberIds: \(Swift.String(describing: phoneNumberIds)))"}
}

extension BatchDeletePhoneNumberInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberIds = "PhoneNumberIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumberIds = phoneNumberIds {
            var phoneNumberIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberIds)
            for nonemptystringlist0 in phoneNumberIds {
                try phoneNumberIdsContainer.encode(nonemptystringlist0)
            }
        }
    }
}

public struct BatchDeletePhoneNumberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeletePhoneNumberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeletePhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeletePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeletePhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeletePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeletePhoneNumberOutputError>
}

public struct BatchDeletePhoneNumberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeletePhoneNumberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeletePhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeletePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "batch-delete"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeletePhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeletePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeletePhoneNumberOutputError>
}

public struct BatchDeletePhoneNumberInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeletePhoneNumberInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchDeletePhoneNumberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeletePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDeletePhoneNumberInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeletePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeletePhoneNumberOutputError>
}

public struct BatchDeletePhoneNumberInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeletePhoneNumberInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchDeletePhoneNumberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeletePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/phone-numbers"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDeletePhoneNumberInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeletePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeletePhoneNumberOutputError>
}

public struct BatchDeletePhoneNumberInput: Swift.Equatable {
    /// List of phone number IDs.
    /// This member is required.
    public var phoneNumberIds: [Swift.String]?

    public init (
        phoneNumberIds: [Swift.String]? = nil
    )
    {
        self.phoneNumberIds = phoneNumberIds
    }
}

struct BatchDeletePhoneNumberInputBody: Swift.Equatable {
    public let phoneNumberIds: [Swift.String]?
}

extension BatchDeletePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberIds = "PhoneNumberIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberIds)
        var phoneNumberIdsDecoded0:[Swift.String]? = nil
        if let phoneNumberIdsContainer = phoneNumberIdsContainer {
            phoneNumberIdsDecoded0 = [Swift.String]()
            for string0 in phoneNumberIdsContainer {
                if let string0 = string0 {
                    phoneNumberIdsDecoded0?.append(string0)
                }
            }
        }
        phoneNumberIds = phoneNumberIdsDecoded0
    }
}

extension BatchDeletePhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeletePhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeletePhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeletePhoneNumberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeletePhoneNumberOutputResponse(phoneNumberErrors: \(Swift.String(describing: phoneNumberErrors)))"}
}

extension BatchDeletePhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDeletePhoneNumberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct BatchDeletePhoneNumberOutputResponse: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init (
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct BatchDeletePhoneNumberOutputResponseBody: Swift.Equatable {
    public let phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?
}

extension BatchDeletePhoneNumberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

public struct BatchSuspendUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchSuspendUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchSuspendUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchSuspendUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchSuspendUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchSuspendUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchSuspendUserOutputError>
}

extension BatchSuspendUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchSuspendUserInput(accountId: \(Swift.String(describing: accountId)), userIdList: \(Swift.String(describing: userIdList)))"}
}

extension BatchSuspendUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userIdList = "UserIdList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userIdList = userIdList {
            var userIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIdList)
            for useridlist0 in userIdList {
                try userIdListContainer.encode(useridlist0)
            }
        }
    }
}

public struct BatchSuspendUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchSuspendUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchSuspendUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchSuspendUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchSuspendUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchSuspendUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchSuspendUserOutputError>
}

public struct BatchSuspendUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchSuspendUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchSuspendUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchSuspendUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "suspend"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchSuspendUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchSuspendUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchSuspendUserOutputError>
}

public struct BatchSuspendUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchSuspendUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchSuspendUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchSuspendUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchSuspendUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchSuspendUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchSuspendUserOutputError>
}

public struct BatchSuspendUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchSuspendUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchSuspendUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchSuspendUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/users"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchSuspendUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchSuspendUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchSuspendUserOutputError>
}

public struct BatchSuspendUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The request containing the user IDs to suspend.
    /// This member is required.
    public var userIdList: [Swift.String]?

    public init (
        accountId: Swift.String? = nil,
        userIdList: [Swift.String]? = nil
    )
    {
        self.accountId = accountId
        self.userIdList = userIdList
    }
}

struct BatchSuspendUserInputBody: Swift.Equatable {
    public let userIdList: [Swift.String]?
}

extension BatchSuspendUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userIdList = "UserIdList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIdList)
        var userIdListDecoded0:[Swift.String]? = nil
        if let userIdListContainer = userIdListContainer {
            userIdListDecoded0 = [Swift.String]()
            for string0 in userIdListContainer {
                if let string0 = string0 {
                    userIdListDecoded0?.append(string0)
                }
            }
        }
        userIdList = userIdListDecoded0
    }
}

extension BatchSuspendUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchSuspendUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchSuspendUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchSuspendUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchSuspendUserOutputResponse(userErrors: \(Swift.String(describing: userErrors)))"}
}

extension BatchSuspendUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchSuspendUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userErrors = output.userErrors
        } else {
            self.userErrors = nil
        }
    }
}

public struct BatchSuspendUserOutputResponse: Swift.Equatable {
    /// If the BatchSuspendUser action fails for one or more of the user IDs in the
    ///             request, a list of the user IDs is returned, along with error codes and error messages.
    public var userErrors: [ChimeClientTypes.UserError]?

    public init (
        userErrors: [ChimeClientTypes.UserError]? = nil
    )
    {
        self.userErrors = userErrors
    }
}

struct BatchSuspendUserOutputResponseBody: Swift.Equatable {
    public let userErrors: [ChimeClientTypes.UserError]?
}

extension BatchSuspendUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userErrors = "UserErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.UserError?].self, forKey: .userErrors)
        var userErrorsDecoded0:[ChimeClientTypes.UserError]? = nil
        if let userErrorsContainer = userErrorsContainer {
            userErrorsDecoded0 = [ChimeClientTypes.UserError]()
            for structure0 in userErrorsContainer {
                if let structure0 = structure0 {
                    userErrorsDecoded0?.append(structure0)
                }
            }
        }
        userErrors = userErrorsDecoded0
    }
}

public struct BatchUnsuspendUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUnsuspendUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchUnsuspendUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUnsuspendUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchUnsuspendUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUnsuspendUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUnsuspendUserOutputError>
}

extension BatchUnsuspendUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUnsuspendUserInput(accountId: \(Swift.String(describing: accountId)), userIdList: \(Swift.String(describing: userIdList)))"}
}

extension BatchUnsuspendUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userIdList = "UserIdList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userIdList = userIdList {
            var userIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIdList)
            for useridlist0 in userIdList {
                try userIdListContainer.encode(useridlist0)
            }
        }
    }
}

public struct BatchUnsuspendUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUnsuspendUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchUnsuspendUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUnsuspendUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchUnsuspendUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUnsuspendUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUnsuspendUserOutputError>
}

public struct BatchUnsuspendUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUnsuspendUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchUnsuspendUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUnsuspendUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "unsuspend"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchUnsuspendUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUnsuspendUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUnsuspendUserOutputError>
}

public struct BatchUnsuspendUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUnsuspendUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchUnsuspendUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUnsuspendUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchUnsuspendUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUnsuspendUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUnsuspendUserOutputError>
}

public struct BatchUnsuspendUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUnsuspendUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchUnsuspendUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUnsuspendUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/users"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchUnsuspendUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUnsuspendUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUnsuspendUserOutputError>
}

public struct BatchUnsuspendUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The request containing the user IDs to unsuspend.
    /// This member is required.
    public var userIdList: [Swift.String]?

    public init (
        accountId: Swift.String? = nil,
        userIdList: [Swift.String]? = nil
    )
    {
        self.accountId = accountId
        self.userIdList = userIdList
    }
}

struct BatchUnsuspendUserInputBody: Swift.Equatable {
    public let userIdList: [Swift.String]?
}

extension BatchUnsuspendUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userIdList = "UserIdList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIdList)
        var userIdListDecoded0:[Swift.String]? = nil
        if let userIdListContainer = userIdListContainer {
            userIdListDecoded0 = [Swift.String]()
            for string0 in userIdListContainer {
                if let string0 = string0 {
                    userIdListDecoded0?.append(string0)
                }
            }
        }
        userIdList = userIdListDecoded0
    }
}

extension BatchUnsuspendUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchUnsuspendUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchUnsuspendUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchUnsuspendUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUnsuspendUserOutputResponse(userErrors: \(Swift.String(describing: userErrors)))"}
}

extension BatchUnsuspendUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchUnsuspendUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userErrors = output.userErrors
        } else {
            self.userErrors = nil
        }
    }
}

public struct BatchUnsuspendUserOutputResponse: Swift.Equatable {
    /// If the BatchUnsuspendUser action fails for one or more of the user IDs in the
    ///             request, a list of the user IDs is returned, along with error codes and error messages.
    public var userErrors: [ChimeClientTypes.UserError]?

    public init (
        userErrors: [ChimeClientTypes.UserError]? = nil
    )
    {
        self.userErrors = userErrors
    }
}

struct BatchUnsuspendUserOutputResponseBody: Swift.Equatable {
    public let userErrors: [ChimeClientTypes.UserError]?
}

extension BatchUnsuspendUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userErrors = "UserErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.UserError?].self, forKey: .userErrors)
        var userErrorsDecoded0:[ChimeClientTypes.UserError]? = nil
        if let userErrorsContainer = userErrorsContainer {
            userErrorsDecoded0 = [ChimeClientTypes.UserError]()
            for structure0 in userErrorsContainer {
                if let structure0 = structure0 {
                    userErrorsDecoded0?.append(structure0)
                }
            }
        }
        userErrors = userErrorsDecoded0
    }
}

public struct BatchUpdatePhoneNumberInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdatePhoneNumberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchUpdatePhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdatePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchUpdatePhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdatePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdatePhoneNumberOutputError>
}

extension BatchUpdatePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUpdatePhoneNumberInput(updatePhoneNumberRequestItems: \(Swift.String(describing: updatePhoneNumberRequestItems)))"}
}

extension BatchUpdatePhoneNumberInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatePhoneNumberRequestItems = "UpdatePhoneNumberRequestItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updatePhoneNumberRequestItems = updatePhoneNumberRequestItems {
            var updatePhoneNumberRequestItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updatePhoneNumberRequestItems)
            for updatephonenumberrequestitemlist0 in updatePhoneNumberRequestItems {
                try updatePhoneNumberRequestItemsContainer.encode(updatephonenumberrequestitemlist0)
            }
        }
    }
}

public struct BatchUpdatePhoneNumberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdatePhoneNumberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchUpdatePhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdatePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchUpdatePhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdatePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdatePhoneNumberOutputError>
}

public struct BatchUpdatePhoneNumberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdatePhoneNumberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchUpdatePhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdatePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "batch-update"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchUpdatePhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdatePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdatePhoneNumberOutputError>
}

public struct BatchUpdatePhoneNumberInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdatePhoneNumberInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchUpdatePhoneNumberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdatePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchUpdatePhoneNumberInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdatePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdatePhoneNumberOutputError>
}

public struct BatchUpdatePhoneNumberInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdatePhoneNumberInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchUpdatePhoneNumberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdatePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/phone-numbers"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchUpdatePhoneNumberInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdatePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdatePhoneNumberOutputError>
}

public struct BatchUpdatePhoneNumberInput: Swift.Equatable {
    /// The request containing the phone number IDs and product types or calling names to update.
    /// This member is required.
    public var updatePhoneNumberRequestItems: [ChimeClientTypes.UpdatePhoneNumberRequestItem]?

    public init (
        updatePhoneNumberRequestItems: [ChimeClientTypes.UpdatePhoneNumberRequestItem]? = nil
    )
    {
        self.updatePhoneNumberRequestItems = updatePhoneNumberRequestItems
    }
}

struct BatchUpdatePhoneNumberInputBody: Swift.Equatable {
    public let updatePhoneNumberRequestItems: [ChimeClientTypes.UpdatePhoneNumberRequestItem]?
}

extension BatchUpdatePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatePhoneNumberRequestItems = "UpdatePhoneNumberRequestItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatePhoneNumberRequestItemsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.UpdatePhoneNumberRequestItem?].self, forKey: .updatePhoneNumberRequestItems)
        var updatePhoneNumberRequestItemsDecoded0:[ChimeClientTypes.UpdatePhoneNumberRequestItem]? = nil
        if let updatePhoneNumberRequestItemsContainer = updatePhoneNumberRequestItemsContainer {
            updatePhoneNumberRequestItemsDecoded0 = [ChimeClientTypes.UpdatePhoneNumberRequestItem]()
            for structure0 in updatePhoneNumberRequestItemsContainer {
                if let structure0 = structure0 {
                    updatePhoneNumberRequestItemsDecoded0?.append(structure0)
                }
            }
        }
        updatePhoneNumberRequestItems = updatePhoneNumberRequestItemsDecoded0
    }
}

extension BatchUpdatePhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchUpdatePhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchUpdatePhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchUpdatePhoneNumberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUpdatePhoneNumberOutputResponse(phoneNumberErrors: \(Swift.String(describing: phoneNumberErrors)))"}
}

extension BatchUpdatePhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchUpdatePhoneNumberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct BatchUpdatePhoneNumberOutputResponse: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init (
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct BatchUpdatePhoneNumberOutputResponseBody: Swift.Equatable {
    public let phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?
}

extension BatchUpdatePhoneNumberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

public struct BatchUpdateUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchUpdateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchUpdateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdateUserOutputError>
}

extension BatchUpdateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUpdateUserInput(accountId: \(Swift.String(describing: accountId)), updateUserRequestItems: \(Swift.String(describing: updateUserRequestItems)))"}
}

extension BatchUpdateUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateUserRequestItems = "UpdateUserRequestItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updateUserRequestItems = updateUserRequestItems {
            var updateUserRequestItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updateUserRequestItems)
            for updateuserrequestitemlist0 in updateUserRequestItems {
                try updateUserRequestItemsContainer.encode(updateuserrequestitemlist0)
            }
        }
    }
}

public struct BatchUpdateUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchUpdateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchUpdateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdateUserOutputError>
}

public struct BatchUpdateUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchUpdateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchUpdateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdateUserOutputError>
}

public struct BatchUpdateUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdateUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchUpdateUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchUpdateUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdateUserOutputError>
}

public struct BatchUpdateUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdateUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchUpdateUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/users"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchUpdateUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdateUserOutputError>
}

public struct BatchUpdateUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The request containing the user IDs and details to update.
    /// This member is required.
    public var updateUserRequestItems: [ChimeClientTypes.UpdateUserRequestItem]?

    public init (
        accountId: Swift.String? = nil,
        updateUserRequestItems: [ChimeClientTypes.UpdateUserRequestItem]? = nil
    )
    {
        self.accountId = accountId
        self.updateUserRequestItems = updateUserRequestItems
    }
}

struct BatchUpdateUserInputBody: Swift.Equatable {
    public let updateUserRequestItems: [ChimeClientTypes.UpdateUserRequestItem]?
}

extension BatchUpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateUserRequestItems = "UpdateUserRequestItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateUserRequestItemsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.UpdateUserRequestItem?].self, forKey: .updateUserRequestItems)
        var updateUserRequestItemsDecoded0:[ChimeClientTypes.UpdateUserRequestItem]? = nil
        if let updateUserRequestItemsContainer = updateUserRequestItemsContainer {
            updateUserRequestItemsDecoded0 = [ChimeClientTypes.UpdateUserRequestItem]()
            for structure0 in updateUserRequestItemsContainer {
                if let structure0 = structure0 {
                    updateUserRequestItemsDecoded0?.append(structure0)
                }
            }
        }
        updateUserRequestItems = updateUserRequestItemsDecoded0
    }
}

extension BatchUpdateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchUpdateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchUpdateUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchUpdateUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUpdateUserOutputResponse(userErrors: \(Swift.String(describing: userErrors)))"}
}

extension BatchUpdateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchUpdateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userErrors = output.userErrors
        } else {
            self.userErrors = nil
        }
    }
}

public struct BatchUpdateUserOutputResponse: Swift.Equatable {
    /// If the BatchUpdateUser action fails for one or more of the user IDs in the
    ///             request, a list of the user IDs is returned, along with error codes and error messages.
    public var userErrors: [ChimeClientTypes.UserError]?

    public init (
        userErrors: [ChimeClientTypes.UserError]? = nil
    )
    {
        self.userErrors = userErrors
    }
}

struct BatchUpdateUserOutputResponseBody: Swift.Equatable {
    public let userErrors: [ChimeClientTypes.UserError]?
}

extension BatchUpdateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userErrors = "UserErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.UserError?].self, forKey: .userErrors)
        var userErrorsDecoded0:[ChimeClientTypes.UserError]? = nil
        if let userErrorsContainer = userErrorsContainer {
            userErrorsDecoded0 = [ChimeClientTypes.UserError]()
            for structure0 in userErrorsContainer {
                if let structure0 = structure0 {
                    userErrorsDecoded0?.append(structure0)
                }
            }
        }
        userErrors = userErrorsDecoded0
    }
}

extension ChimeClientTypes.Bot: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botEmail = "BotEmail"
        case botId = "BotId"
        case botType = "BotType"
        case createdTimestamp = "CreatedTimestamp"
        case disabled = "Disabled"
        case displayName = "DisplayName"
        case securityToken = "SecurityToken"
        case updatedTimestamp = "UpdatedTimestamp"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botEmail = botEmail {
            try encodeContainer.encode(botEmail, forKey: .botEmail)
        }
        if let botId = botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botType = botType {
            try encodeContainer.encode(botType.rawValue, forKey: .botType)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let disabled = disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let securityToken = securityToken {
            try encodeContainer.encode(securityToken, forKey: .securityToken)
        }
        if let updatedTimestamp = updatedTimestamp {
            try encodeContainer.encode(updatedTimestamp.timeIntervalSince1970, forKey: .updatedTimestamp)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let botTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.BotType.self, forKey: .botType)
        botType = botTypeDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let botEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botEmail)
        botEmail = botEmailDecoded
        let securityTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityToken)
        securityToken = securityTokenDecoded
    }
}

extension ChimeClientTypes.Bot: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Bot(botEmail: \(Swift.String(describing: botEmail)), botId: \(Swift.String(describing: botId)), botType: \(Swift.String(describing: botType)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), disabled: \(Swift.String(describing: disabled)), displayName: \(Swift.String(describing: displayName)), securityToken: \(Swift.String(describing: securityToken)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), userId: \(Swift.String(describing: userId)))"}
}

extension ChimeClientTypes {
    /// A resource that allows Enterprise account administrators to configure an interface to receive events from Amazon Chime.
    public struct Bot: Swift.Equatable {
        /// The bot email address.
        public var botEmail: Swift.String?
        /// The bot ID.
        public var botId: Swift.String?
        /// The bot type.
        public var botType: ChimeClientTypes.BotType?
        /// The bot creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// When true, the bot is stopped from running in your account.
        public var disabled: Swift.Bool?
        /// The bot display name.
        public var displayName: Swift.String?
        /// The security token used to authenticate Amazon Chime with the outgoing event endpoint.
        public var securityToken: Swift.String?
        /// The updated bot timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The unique ID for the bot user.
        public var userId: Swift.String?

        public init (
            botEmail: Swift.String? = nil,
            botId: Swift.String? = nil,
            botType: ChimeClientTypes.BotType? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            disabled: Swift.Bool? = nil,
            displayName: Swift.String? = nil,
            securityToken: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            userId: Swift.String? = nil
        )
        {
            self.botEmail = botEmail
            self.botId = botId
            self.botType = botType
            self.createdTimestamp = createdTimestamp
            self.disabled = disabled
            self.displayName = displayName
            self.securityToken = securityToken
            self.updatedTimestamp = updatedTimestamp
            self.userId = userId
        }
    }

}

extension ChimeClientTypes {
    public enum BotType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chatbot
        case sdkUnknown(Swift.String)

        public static var allCases: [BotType] {
            return [
                .chatbot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chatbot: return "ChatBot"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BotType(rawValue: rawValue) ?? BotType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.BusinessCallingSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdrBucket = "CdrBucket"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdrBucket = cdrBucket {
            try encodeContainer.encode(cdrBucket, forKey: .cdrBucket)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cdrBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdrBucket)
        cdrBucket = cdrBucketDecoded
    }
}

extension ChimeClientTypes.BusinessCallingSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BusinessCallingSettings(cdrBucket: \(Swift.String(describing: cdrBucket)))"}
}

extension ChimeClientTypes {
    /// The Amazon Chime Business Calling settings for the administrator's AWS account. Includes any
    ///             Amazon S3 buckets designated for storing call detail records.
    public struct BusinessCallingSettings: Swift.Equatable {
        /// The Amazon S3 bucket designated for call detail record storage.
        public var cdrBucket: Swift.String?

        public init (
            cdrBucket: Swift.String? = nil
        )
        {
            self.cdrBucket = cdrBucket
        }
    }

}

extension ChimeClientTypes {
    public enum CallingNameStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case unassigned
        case updatefailed
        case updateinprogress
        case updatesucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CallingNameStatus] {
            return [
                .unassigned,
                .updatefailed,
                .updateinprogress,
                .updatesucceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .unassigned: return "Unassigned"
            case .updatefailed: return "UpdateFailed"
            case .updateinprogress: return "UpdateInProgress"
            case .updatesucceeded: return "UpdateSucceeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CallingNameStatus(rawValue: rawValue) ?? CallingNameStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum Capability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [Capability] {
            return [
                .sms,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sms: return "SMS"
            case .voice: return "Voice"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Capability(rawValue: rawValue) ?? Capability.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.Channel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case lastMessageTimestamp = "LastMessageTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastMessageTimestamp = lastMessageTimestamp {
            try encodeContainer.encode(lastMessageTimestamp.timeIntervalSince1970, forKey: .lastMessageTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastMessageTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastMessageTimestamp)
        lastMessageTimestamp = lastMessageTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ChimeClientTypes.Channel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Channel(channelArn: \(Swift.String(describing: channelArn)), createdBy: \(Swift.String(describing: createdBy)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastMessageTimestamp: \(Swift.String(describing: lastMessageTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \(Swift.String(describing: metadata)), mode: \(Swift.String(describing: mode)), name: \(Swift.String(describing: name)), privacy: \(Swift.String(describing: privacy)))"}
}

extension ChimeClientTypes {
    /// The details of a channel.
    public struct Channel: Swift.Equatable {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the channel.
        public var createdBy: ChimeClientTypes.Identity?
        /// The time at which the AppInstanceUser created the channel.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a member sent the last message in the channel.
        public var lastMessageTimestamp: ClientRuntime.Date?
        /// The time at which a channel was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The channel's metadata.
        public var metadata: Swift.String?
        /// The mode of the channel.
        public var mode: ChimeClientTypes.ChannelMode?
        /// The name of the channel.
        public var name: Swift.String?
        /// The channel's privacy setting.
        public var privacy: ChimeClientTypes.ChannelPrivacy?

        public init (
            channelArn: Swift.String? = nil,
            createdBy: ChimeClientTypes.Identity? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastMessageTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.lastMessageTimestamp = lastMessageTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }

}

extension ChimeClientTypes.ChannelBan: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case member = "Member"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let member = member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ChimeClientTypes.ChannelBan: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelBan(channelArn: \(Swift.String(describing: channelArn)), createdBy: \(Swift.String(describing: createdBy)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), member: \(Swift.String(describing: member)))"}
}

extension ChimeClientTypes {
    /// The details of a channel ban.
    public struct ChannelBan: Swift.Equatable {
        /// The ARN of the channel from which a member is being banned.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the ban.
        public var createdBy: ChimeClientTypes.Identity?
        /// The time at which the ban was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The member being banned from the channel.
        public var member: ChimeClientTypes.Identity?

        public init (
            channelArn: Swift.String? = nil,
            createdBy: ChimeClientTypes.Identity? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            member: ChimeClientTypes.Identity? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.member = member
        }
    }

}

extension ChimeClientTypes.ChannelBanSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member = "Member"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let member = member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

extension ChimeClientTypes.ChannelBanSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelBanSummary(member: \(Swift.String(describing: member)))"}
}

extension ChimeClientTypes {
    /// Summary of the details of a ChannelBan.
    public struct ChannelBanSummary: Swift.Equatable {
        /// The member being banned from a channel.
        public var member: ChimeClientTypes.Identity?

        public init (
            member: ChimeClientTypes.Identity? = nil
        )
        {
            self.member = member
        }
    }

}

extension ChimeClientTypes.ChannelMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdTimestamp = "CreatedTimestamp"
        case invitedBy = "InvitedBy"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case member = "Member"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let invitedBy = invitedBy {
            try encodeContainer.encode(invitedBy, forKey: .invitedBy)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let member = member {
            try encodeContainer.encode(member, forKey: .member)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitedByDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .invitedBy)
        invitedBy = invitedByDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ChimeClientTypes.ChannelMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMembership(channelArn: \(Swift.String(describing: channelArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), invitedBy: \(Swift.String(describing: invitedBy)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), member: \(Swift.String(describing: member)), type: \(Swift.String(describing: type)))"}
}

extension ChimeClientTypes {
    /// The details of a channel member.
    public struct ChannelMembership: Swift.Equatable {
        /// The ARN of the member's channel.
        public var channelArn: Swift.String?
        /// The time at which the channel membership was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The identifier of the member who invited another member.
        public var invitedBy: ChimeClientTypes.Identity?
        /// The time at which a channel membership was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The data of the channel member.
        public var member: ChimeClientTypes.Identity?
        /// The membership type set for the channel member.
        public var type: ChimeClientTypes.ChannelMembershipType?

        public init (
            channelArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            invitedBy: ChimeClientTypes.Identity? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            member: ChimeClientTypes.Identity? = nil,
            type: ChimeClientTypes.ChannelMembershipType? = nil
        )
        {
            self.channelArn = channelArn
            self.createdTimestamp = createdTimestamp
            self.invitedBy = invitedBy
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.member = member
            self.type = type
        }
    }

}

extension ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserMembershipSummary = "AppInstanceUserMembershipSummary"
        case channelSummary = "ChannelSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceUserMembershipSummary = appInstanceUserMembershipSummary {
            try encodeContainer.encode(appInstanceUserMembershipSummary, forKey: .appInstanceUserMembershipSummary)
        }
        if let channelSummary = channelSummary {
            try encodeContainer.encode(channelSummary, forKey: .channelSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelSummaryDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelSummary.self, forKey: .channelSummary)
        channelSummary = channelSummaryDecoded
        let appInstanceUserMembershipSummaryDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstanceUserMembershipSummary.self, forKey: .appInstanceUserMembershipSummary)
        appInstanceUserMembershipSummary = appInstanceUserMembershipSummaryDecoded
    }
}

extension ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMembershipForAppInstanceUserSummary(appInstanceUserMembershipSummary: \(Swift.String(describing: appInstanceUserMembershipSummary)), channelSummary: \(Swift.String(describing: channelSummary)))"}
}

extension ChimeClientTypes {
    /// Summary of the channel membership details of an AppInstanceUser.
    public struct ChannelMembershipForAppInstanceUserSummary: Swift.Equatable {
        /// Summary of the membership details of an AppInstanceUser.
        public var appInstanceUserMembershipSummary: ChimeClientTypes.AppInstanceUserMembershipSummary?
        /// Summary of the details of a Channel.
        public var channelSummary: ChimeClientTypes.ChannelSummary?

        public init (
            appInstanceUserMembershipSummary: ChimeClientTypes.AppInstanceUserMembershipSummary? = nil,
            channelSummary: ChimeClientTypes.ChannelSummary? = nil
        )
        {
            self.appInstanceUserMembershipSummary = appInstanceUserMembershipSummary
            self.channelSummary = channelSummary
        }
    }

}

extension ChimeClientTypes.ChannelMembershipSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member = "Member"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let member = member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

extension ChimeClientTypes.ChannelMembershipSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMembershipSummary(member: \(Swift.String(describing: member)))"}
}

extension ChimeClientTypes {
    /// Summary of the details of a ChannelMembership.
    public struct ChannelMembershipSummary: Swift.Equatable {
        /// A member's summary data.
        public var member: ChimeClientTypes.Identity?

        public init (
            member: ChimeClientTypes.Identity? = nil
        )
        {
            self.member = member
        }
    }

}

extension ChimeClientTypes {
    public enum ChannelMembershipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case hidden
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMembershipType] {
            return [
                .default,
                .hidden,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .hidden: return "HIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMembershipType(rawValue: rawValue) ?? ChannelMembershipType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.ChannelMessage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case content = "Content"
        case createdTimestamp = "CreatedTimestamp"
        case lastEditedTimestamp = "LastEditedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case messageId = "MessageId"
        case metadata = "Metadata"
        case persistence = "Persistence"
        case redacted = "Redacted"
        case sender = "Sender"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastEditedTimestamp = lastEditedTimestamp {
            try encodeContainer.encode(lastEditedTimestamp.timeIntervalSince1970, forKey: .lastEditedTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let persistence = persistence {
            try encodeContainer.encode(persistence.rawValue, forKey: .persistence)
        }
        if redacted != false {
            try encodeContainer.encode(redacted, forKey: .redacted)
        }
        if let sender = sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMessageType.self, forKey: .type)
        type = typeDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastEditedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastEditedTimestamp)
        lastEditedTimestamp = lastEditedTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let senderDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .sender)
        sender = senderDecoded
        let redactedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .redacted)
        redacted = redactedDecoded
        let persistenceDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMessagePersistenceType.self, forKey: .persistence)
        persistence = persistenceDecoded
    }
}

extension ChimeClientTypes.ChannelMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMessage(channelArn: \(Swift.String(describing: channelArn)), content: \(Swift.String(describing: content)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastEditedTimestamp: \(Swift.String(describing: lastEditedTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), messageId: \(Swift.String(describing: messageId)), metadata: \(Swift.String(describing: metadata)), persistence: \(Swift.String(describing: persistence)), redacted: \(Swift.String(describing: redacted)), sender: \(Swift.String(describing: sender)), type: \(Swift.String(describing: type)))"}
}

extension ChimeClientTypes {
    /// The details of a message in a channel.
    public struct ChannelMessage: Swift.Equatable {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The message content.
        public var content: Swift.String?
        /// The time at which the message was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a message was edited.
        public var lastEditedTimestamp: ClientRuntime.Date?
        /// The time at which a message was updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The ID of a message.
        public var messageId: Swift.String?
        /// The message metadata.
        public var metadata: Swift.String?
        /// The persistence setting for a channel message.
        public var persistence: ChimeClientTypes.ChannelMessagePersistenceType?
        /// Hides the content of a message.
        public var redacted: Swift.Bool
        /// The message sender.
        public var sender: ChimeClientTypes.Identity?
        /// The message type.
        public var type: ChimeClientTypes.ChannelMessageType?

        public init (
            channelArn: Swift.String? = nil,
            content: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastEditedTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            persistence: ChimeClientTypes.ChannelMessagePersistenceType? = nil,
            redacted: Swift.Bool = false,
            sender: ChimeClientTypes.Identity? = nil,
            type: ChimeClientTypes.ChannelMessageType? = nil
        )
        {
            self.channelArn = channelArn
            self.content = content
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageId = messageId
            self.metadata = metadata
            self.persistence = persistence
            self.redacted = redacted
            self.sender = sender
            self.type = type
        }
    }

}

extension ChimeClientTypes {
    public enum ChannelMessagePersistenceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nonPersistent
        case persistent
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessagePersistenceType] {
            return [
                .nonPersistent,
                .persistent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nonPersistent: return "NON_PERSISTENT"
            case .persistent: return "PERSISTENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMessagePersistenceType(rawValue: rawValue) ?? ChannelMessagePersistenceType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.ChannelMessageSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case createdTimestamp = "CreatedTimestamp"
        case lastEditedTimestamp = "LastEditedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case messageId = "MessageId"
        case metadata = "Metadata"
        case redacted = "Redacted"
        case sender = "Sender"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastEditedTimestamp = lastEditedTimestamp {
            try encodeContainer.encode(lastEditedTimestamp.timeIntervalSince1970, forKey: .lastEditedTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if redacted != false {
            try encodeContainer.encode(redacted, forKey: .redacted)
        }
        if let sender = sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMessageType.self, forKey: .type)
        type = typeDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let lastEditedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastEditedTimestamp)
        lastEditedTimestamp = lastEditedTimestampDecoded
        let senderDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .sender)
        sender = senderDecoded
        let redactedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .redacted)
        redacted = redactedDecoded
    }
}

extension ChimeClientTypes.ChannelMessageSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMessageSummary(content: \(Swift.String(describing: content)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastEditedTimestamp: \(Swift.String(describing: lastEditedTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), messageId: \(Swift.String(describing: messageId)), metadata: \(Swift.String(describing: metadata)), redacted: \(Swift.String(describing: redacted)), sender: \(Swift.String(describing: sender)), type: \(Swift.String(describing: type)))"}
}

extension ChimeClientTypes {
    /// Summary of the messages in a Channel.
    public struct ChannelMessageSummary: Swift.Equatable {
        /// The content of the message.
        public var content: Swift.String?
        /// The time at which the message summary was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a message was last edited.
        public var lastEditedTimestamp: ClientRuntime.Date?
        /// The time at which a message was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The ID of the message.
        public var messageId: Swift.String?
        /// The metadata of the message.
        public var metadata: Swift.String?
        /// Indicates whether a message was redacted.
        public var redacted: Swift.Bool
        /// The message sender.
        public var sender: ChimeClientTypes.Identity?
        /// The type of message.
        public var type: ChimeClientTypes.ChannelMessageType?

        public init (
            content: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastEditedTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            redacted: Swift.Bool = false,
            sender: ChimeClientTypes.Identity? = nil,
            type: ChimeClientTypes.ChannelMessageType? = nil
        )
        {
            self.content = content
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageId = messageId
            self.metadata = metadata
            self.redacted = redacted
            self.sender = sender
            self.type = type
        }
    }

}

extension ChimeClientTypes {
    public enum ChannelMessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case control
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessageType] {
            return [
                .control,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .control: return "CONTROL"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMessageType(rawValue: rawValue) ?? ChannelMessageType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum ChannelMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case restricted
        case unrestricted
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMode] {
            return [
                .restricted,
                .unrestricted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .restricted: return "RESTRICTED"
            case .unrestricted: return "UNRESTRICTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMode(rawValue: rawValue) ?? ChannelMode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelSummary = "ChannelSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelSummary = channelSummary {
            try encodeContainer.encode(channelSummary, forKey: .channelSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelSummaryDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelSummary.self, forKey: .channelSummary)
        channelSummary = channelSummaryDecoded
    }
}

extension ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelModeratedByAppInstanceUserSummary(channelSummary: \(Swift.String(describing: channelSummary)))"}
}

extension ChimeClientTypes {
    /// Summary of the details of a moderated channel.
    public struct ChannelModeratedByAppInstanceUserSummary: Swift.Equatable {
        /// Summary of the details of a Channel.
        public var channelSummary: ChimeClientTypes.ChannelSummary?

        public init (
            channelSummary: ChimeClientTypes.ChannelSummary? = nil
        )
        {
            self.channelSummary = channelSummary
        }
    }

}

extension ChimeClientTypes.ChannelModerator: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case moderator = "Moderator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let moderator = moderator {
            try encodeContainer.encode(moderator, forKey: .moderator)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moderatorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .moderator)
        moderator = moderatorDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ChimeClientTypes.ChannelModerator: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelModerator(channelArn: \(Swift.String(describing: channelArn)), createdBy: \(Swift.String(describing: createdBy)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), moderator: \(Swift.String(describing: moderator)))"}
}

extension ChimeClientTypes {
    /// The details of a channel moderator.
    public struct ChannelModerator: Swift.Equatable {
        /// The ARN of the moderator's channel.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the moderator.
        public var createdBy: ChimeClientTypes.Identity?
        /// The time at which the moderator was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The moderator's data.
        public var moderator: ChimeClientTypes.Identity?

        public init (
            channelArn: Swift.String? = nil,
            createdBy: ChimeClientTypes.Identity? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            moderator: ChimeClientTypes.Identity? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.moderator = moderator
        }
    }

}

extension ChimeClientTypes.ChannelModeratorSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case moderator = "Moderator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let moderator = moderator {
            try encodeContainer.encode(moderator, forKey: .moderator)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moderatorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .moderator)
        moderator = moderatorDecoded
    }
}

extension ChimeClientTypes.ChannelModeratorSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelModeratorSummary(moderator: \(Swift.String(describing: moderator)))"}
}

extension ChimeClientTypes {
    /// Summary of the details of a ChannelModerator.
    public struct ChannelModeratorSummary: Swift.Equatable {
        /// The data for a moderator.
        public var moderator: ChimeClientTypes.Identity?

        public init (
            moderator: ChimeClientTypes.Identity? = nil
        )
        {
            self.moderator = moderator
        }
    }

}

extension ChimeClientTypes {
    public enum ChannelPrivacy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelPrivacy] {
            return [
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelPrivacy(rawValue: rawValue) ?? ChannelPrivacy.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.ChannelRetentionSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionDays = "RetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionDays = retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
    }
}

extension ChimeClientTypes.ChannelRetentionSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelRetentionSettings(retentionDays: \(Swift.String(describing: retentionDays)))"}
}

extension ChimeClientTypes {
    /// The details of the retention settings for a channel.
    public struct ChannelRetentionSettings: Swift.Equatable {
        /// The time in days to retain the messages in a channel.
        public var retentionDays: Swift.Int?

        public init (
            retentionDays: Swift.Int? = nil
        )
        {
            self.retentionDays = retentionDays
        }
    }

}

extension ChimeClientTypes.ChannelSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case lastMessageTimestamp = "LastMessageTimestamp"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let lastMessageTimestamp = lastMessageTimestamp {
            try encodeContainer.encode(lastMessageTimestamp.timeIntervalSince1970, forKey: .lastMessageTimestamp)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let lastMessageTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastMessageTimestamp)
        lastMessageTimestamp = lastMessageTimestampDecoded
    }
}

extension ChimeClientTypes.ChannelSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelSummary(channelArn: \(Swift.String(describing: channelArn)), lastMessageTimestamp: \(Swift.String(describing: lastMessageTimestamp)), metadata: \(Swift.String(describing: metadata)), mode: \(Swift.String(describing: mode)), name: \(Swift.String(describing: name)), privacy: \(Swift.String(describing: privacy)))"}
}

extension ChimeClientTypes {
    /// Summary of the details of a Channel.
    public struct ChannelSummary: Swift.Equatable {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The time at which the last message in a channel was sent.
        public var lastMessageTimestamp: ClientRuntime.Date?
        /// The metadata of the channel.
        public var metadata: Swift.String?
        /// The mode of the channel.
        public var mode: ChimeClientTypes.ChannelMode?
        /// The name of the channel.
        public var name: Swift.String?
        /// The privacy setting of the channel.
        public var privacy: ChimeClientTypes.ChannelPrivacy?

        public init (
            channelArn: Swift.String? = nil,
            lastMessageTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.lastMessageTimestamp = lastMessageTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be processed because of conflict in the current state of the
///          resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let code: ChimeClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeClientTypes.ConversationRetentionSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionDays = "RetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionDays = retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
    }
}

extension ChimeClientTypes.ConversationRetentionSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConversationRetentionSettings(retentionDays: \(Swift.String(describing: retentionDays)))"}
}

extension ChimeClientTypes {
    /// The retention settings that determine how long to retain conversation messages for an Amazon Chime Enterprise account.
    public struct ConversationRetentionSettings: Swift.Equatable {
        /// The number of days for which to retain conversation messages.
        public var retentionDays: Swift.Int?

        public init (
            retentionDays: Swift.Int? = nil
        )
        {
            self.retentionDays = retentionDays
        }
    }

}

public struct CreateAccountInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccountOutputError>
}

extension CreateAccountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAccountInput(name: \(Swift.String(describing: name)))"}
}

extension CreateAccountInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateAccountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccountOutputError>
}

public struct CreateAccountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccountOutputError>
}

public struct CreateAccountInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccountInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccountOutputError>
}

public struct CreateAccountInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccountInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/accounts"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccountOutputError>
}

public struct CreateAccountInput: Swift.Equatable {
    /// The name of the Amazon Chime account.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateAccountInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension CreateAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAccountOutputResponse(account: \(Swift.String(describing: account)))"}
}

extension CreateAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.account = output.account
        } else {
            self.account = nil
        }
    }
}

public struct CreateAccountOutputResponse: Swift.Equatable {
    /// The Amazon Chime account details.
    public var account: ChimeClientTypes.Account?

    public init (
        account: ChimeClientTypes.Account? = nil
    )
    {
        self.account = account
    }
}

struct CreateAccountOutputResponseBody: Swift.Equatable {
    public let account: ChimeClientTypes.Account?
}

extension CreateAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Account.self, forKey: .account)
        account = accountDecoded
    }
}

public struct CreateAppInstanceAdminInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceAdminInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceAdminOutputError>
}

extension CreateAppInstanceAdminInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceAdminInput(appInstanceAdminArn: \(Swift.String(describing: appInstanceAdminArn)), appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension CreateAppInstanceAdminInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdminArn = "AppInstanceAdminArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceAdminArn = appInstanceAdminArn {
            try encodeContainer.encode(appInstanceAdminArn, forKey: .appInstanceAdminArn)
        }
    }
}

public struct CreateAppInstanceAdminInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceAdminInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceAdminOutputError>
}

public struct CreateAppInstanceAdminInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceAdminInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceAdminOutputError>
}

public struct CreateAppInstanceAdminInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceAdminInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateAppInstanceAdminInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAppInstanceAdminInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceAdminOutputError>
}

public struct CreateAppInstanceAdminInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceAdminInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateAppInstanceAdminInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAppInstanceAdminInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceAdminOutputError>
}

public struct CreateAppInstanceAdminInput: Swift.Equatable {
    /// The ARN of the administrator of the current AppInstance.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

struct CreateAppInstanceAdminInputBody: Swift.Equatable {
    public let appInstanceAdminArn: Swift.String?
}

extension CreateAppInstanceAdminInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdminArn = "AppInstanceAdminArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceAdminArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceAdminArn)
        appInstanceAdminArn = appInstanceAdminArnDecoded
    }
}

extension CreateAppInstanceAdminOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppInstanceAdminOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppInstanceAdminOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppInstanceAdminOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceAdminOutputResponse(appInstanceAdmin: \(Swift.String(describing: appInstanceAdmin)), appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension CreateAppInstanceAdminOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAppInstanceAdminOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceAdmin = output.appInstanceAdmin
            self.appInstanceArn = output.appInstanceArn
        } else {
            self.appInstanceAdmin = nil
            self.appInstanceArn = nil
        }
    }
}

public struct CreateAppInstanceAdminOutputResponse: Swift.Equatable {
    /// The name and ARN of the admin for the AppInstance.
    public var appInstanceAdmin: ChimeClientTypes.Identity?
    /// The ARN of the of the admin for the AppInstance.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceAdmin: ChimeClientTypes.Identity? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdmin = appInstanceAdmin
        self.appInstanceArn = appInstanceArn
    }
}

struct CreateAppInstanceAdminOutputResponseBody: Swift.Equatable {
    public let appInstanceAdmin: ChimeClientTypes.Identity?
    public let appInstanceArn: Swift.String?
}

extension CreateAppInstanceAdminOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdmin = "AppInstanceAdmin"
        case appInstanceArn = "AppInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceAdminDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .appInstanceAdmin)
        appInstanceAdmin = appInstanceAdminDecoded
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
    }
}

public struct CreateAppInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceOutputError>
}

extension CreateAppInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAppInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateAppInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceOutputError>
}

public struct CreateAppInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceOutputError>
}

public struct CreateAppInstanceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceOutputError>
}

public struct CreateAppInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/app-instances"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceOutputError>
}

public struct CreateAppInstanceInput: Swift.Equatable {
    /// The ClientRequestToken of the AppInstance.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The metadata of the AppInstance. Limited to a 1KB string in UTF-8.
    public var metadata: Swift.String?
    /// The name of the AppInstance.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to the AppInstanceUser.
    public var tags: [ChimeClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.name = name
        self.tags = tags
    }
}

struct CreateAppInstanceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let metadata: Swift.String?
    public let clientRequestToken: Swift.String?
    public let tags: [ChimeClientTypes.Tag]?
}

extension CreateAppInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAppInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppInstanceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceOutputResponse(appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension CreateAppInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAppInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
        } else {
            self.appInstanceArn = nil
        }
    }
}

public struct CreateAppInstanceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the AppInstance.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct CreateAppInstanceOutputResponseBody: Swift.Equatable {
    public let appInstanceArn: Swift.String?
}

extension CreateAppInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
    }
}

public struct CreateAppInstanceUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceUserOutputError>
}

extension CreateAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceUserInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), appInstanceUserId: \(Swift.String(describing: appInstanceUserId)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceUserId = "AppInstanceUserId"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let appInstanceUserId = appInstanceUserId {
            try encodeContainer.encode(appInstanceUserId, forKey: .appInstanceUserId)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceUserOutputError>
}

public struct CreateAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceUserOutputError>
}

public struct CreateAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceUserOutputError>
}

public struct CreateAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/app-instance-users"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAppInstanceUserOutputError>
}

public struct CreateAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstance request.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The user ID of the AppInstance.
    /// This member is required.
    public var appInstanceUserId: Swift.String?
    /// The token assigned to the user requesting an AppInstance.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The request's metadata. Limited to a 1KB string in UTF-8.
    public var metadata: Swift.String?
    /// The user's name.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to the AppInstanceUser.
    public var tags: [ChimeClientTypes.Tag]?

    public init (
        appInstanceArn: Swift.String? = nil,
        appInstanceUserId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceUserId = appInstanceUserId
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.name = name
        self.tags = tags
    }
}

struct CreateAppInstanceUserInputBody: Swift.Equatable {
    public let appInstanceArn: Swift.String?
    public let appInstanceUserId: Swift.String?
    public let name: Swift.String?
    public let metadata: Swift.String?
    public let clientRequestToken: Swift.String?
    public let tags: [ChimeClientTypes.Tag]?
}

extension CreateAppInstanceUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceUserId = "AppInstanceUserId"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserId)
        appInstanceUserId = appInstanceUserIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceUserOutputResponse(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)))"}
}

extension CreateAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
        } else {
            self.appInstanceUserArn = nil
        }
    }
}

public struct CreateAppInstanceUserOutputResponse: Swift.Equatable {
    /// The user's ARN.
    public var appInstanceUserArn: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct CreateAppInstanceUserOutputResponseBody: Swift.Equatable {
    public let appInstanceUserArn: Swift.String?
}

extension CreateAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
    }
}

extension ChimeClientTypes.CreateAttendeeError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case externalUserId = "ExternalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let externalUserId = externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeClientTypes.CreateAttendeeError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), externalUserId: \(Swift.String(describing: externalUserId)))"}
}

extension ChimeClientTypes {
    /// The list of errors returned when errors are encountered during the BatchCreateAttendee and CreateAttendee actions. This includes external user IDs, error codes, and error messages.
    public struct CreateAttendeeError: Swift.Equatable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
        public var externalUserId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            externalUserId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.externalUserId = externalUserId
        }
    }

}

public struct CreateAttendeeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAttendeeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAttendeeOutputError>
}

extension CreateAttendeeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeInput(externalUserId: \(Swift.String(describing: externalUserId)), meetingId: \(Swift.String(describing: meetingId)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAttendeeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalUserId = "ExternalUserId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalUserId = externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for attendeetaglist0 in tags {
                try tagsContainer.encode(attendeetaglist0)
            }
        }
    }
}

public struct CreateAttendeeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAttendeeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAttendeeOutputError>
}

public struct CreateAttendeeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAttendeeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAttendeeOutputError>
}

public struct CreateAttendeeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAttendeeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateAttendeeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAttendeeInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAttendeeOutputError>
}

public struct CreateAttendeeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAttendeeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateAttendeeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())/attendees"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAttendeeInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAttendeeOutputError>
}

public struct CreateAttendeeInput: Swift.Equatable {
    /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
    /// This member is required.
    public var externalUserId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The tag key-value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init (
        externalUserId: Swift.String? = nil,
        meetingId: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.externalUserId = externalUserId
        self.meetingId = meetingId
        self.tags = tags
    }
}

struct CreateAttendeeInputBody: Swift.Equatable {
    public let externalUserId: Swift.String?
    public let tags: [ChimeClientTypes.Tag]?
}

extension CreateAttendeeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalUserId = "ExternalUserId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAttendeeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAttendeeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAttendeeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAttendeeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeOutputResponse(attendee: \(Swift.String(describing: attendee)))"}
}

extension CreateAttendeeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAttendeeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attendee = output.attendee
        } else {
            self.attendee = nil
        }
    }
}

public struct CreateAttendeeOutputResponse: Swift.Equatable {
    /// The attendee information, including attendee ID and join token.
    public var attendee: ChimeClientTypes.Attendee?

    public init (
        attendee: ChimeClientTypes.Attendee? = nil
    )
    {
        self.attendee = attendee
    }
}

struct CreateAttendeeOutputResponseBody: Swift.Equatable {
    public let attendee: ChimeClientTypes.Attendee?
}

extension CreateAttendeeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendee = "Attendee"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Attendee.self, forKey: .attendee)
        attendee = attendeeDecoded
    }
}

extension ChimeClientTypes.CreateAttendeeRequestItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalUserId = "ExternalUserId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalUserId = externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for attendeetaglist0 in tags {
                try tagsContainer.encode(attendeetaglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ChimeClientTypes.CreateAttendeeRequestItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeRequestItem(externalUserId: \(Swift.String(describing: externalUserId)), tags: \(Swift.String(describing: tags)))"}
}

extension ChimeClientTypes {
    /// The Amazon Chime SDK attendee fields to create, used with the BatchCreateAttendee action.
    public struct CreateAttendeeRequestItem: Swift.Equatable {
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
        /// This member is required.
        public var externalUserId: Swift.String?
        /// The tag key-value pairs.
        public var tags: [ChimeClientTypes.Tag]?

        public init (
            externalUserId: Swift.String? = nil,
            tags: [ChimeClientTypes.Tag]? = nil
        )
        {
            self.externalUserId = externalUserId
            self.tags = tags
        }
    }

}

public struct CreateBotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBotOutputError>
}

extension CreateBotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBotInput(accountId: \(Swift.String(describing: accountId)), displayName: \(Swift.String(describing: displayName)), domain: \(Swift.String(describing: domain)))"}
}

extension CreateBotInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case domain = "Domain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }
}

public struct CreateBotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBotOutputError>
}

public struct CreateBotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBotOutputError>
}

public struct CreateBotInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBotInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateBotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateBotInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBotOutputError>
}

public struct CreateBotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBotInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateBotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/bots"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateBotInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBotOutputError>
}

public struct CreateBotInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot display name.
    /// This member is required.
    public var displayName: Swift.String?
    /// The domain of the Amazon Chime Enterprise account.
    public var domain: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domain: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.displayName = displayName
        self.domain = domain
    }
}

struct CreateBotInputBody: Swift.Equatable {
    public let displayName: Swift.String?
    public let domain: Swift.String?
}

extension CreateBotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case domain = "Domain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension CreateBotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBotOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBotOutputResponse(bot: \(Swift.String(describing: bot)))"}
}

extension CreateBotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bot = output.bot
        } else {
            self.bot = nil
        }
    }
}

public struct CreateBotOutputResponse: Swift.Equatable {
    /// The bot details.
    public var bot: ChimeClientTypes.Bot?

    public init (
        bot: ChimeClientTypes.Bot? = nil
    )
    {
        self.bot = bot
    }
}

struct CreateBotOutputResponseBody: Swift.Equatable {
    public let bot: ChimeClientTypes.Bot?
}

extension CreateBotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bot = "Bot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Bot.self, forKey: .bot)
        bot = botDecoded
    }
}

public struct CreateChannelBanInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelBanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelBanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelBanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelBanOutputError>
}

extension CreateChannelBanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelBanInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), memberArn: \(Swift.String(describing: memberArn)))"}
}

extension CreateChannelBanInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArn = memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
    }
}

public struct CreateChannelBanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelBanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelBanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelBanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelBanOutputError>
}

public struct CreateChannelBanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelBanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelBanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelBanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelBanOutputError>
}

public struct CreateChannelBanInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelBanInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateChannelBanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelBanInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelBanOutputError>
}

public struct CreateChannelBanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelBanInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateChannelBanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/bans"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelBanInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelBanOutputError>
}

public struct CreateChannelBanInput: Swift.Equatable {
    /// The ARN of the ban request.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the member being banned.
    /// This member is required.
    public var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct CreateChannelBanInputBody: Swift.Equatable {
    public let memberArn: Swift.String?
}

extension CreateChannelBanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
    }
}

extension CreateChannelBanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelBanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelBanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelBanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelBanOutputResponse(channelArn: \(Swift.String(describing: channelArn)), member: \(Swift.String(describing: member)))"}
}

extension CreateChannelBanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelBanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.member = output.member
        } else {
            self.channelArn = nil
            self.member = nil
        }
    }
}

public struct CreateChannelBanOutputResponse: Swift.Equatable {
    /// The ARN of the response to the ban request.
    public var channelArn: Swift.String?
    /// The ChannelArn and BannedIdentity of the member in the ban
    ///          response.
    public var member: ChimeClientTypes.Identity?

    public init (
        channelArn: Swift.String? = nil,
        member: ChimeClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
    }
}

struct CreateChannelBanOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let member: ChimeClientTypes.Identity?
}

extension CreateChannelBanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case member = "Member"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

public struct CreateChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

extension CreateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), metadata: \(Swift.String(describing: metadata)), mode: \(Swift.String(describing: mode)), name: \(Swift.String(describing: name)), privacy: \(Swift.String(describing: privacy)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/channels"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInput: Swift.Equatable {
    /// The ARN of the channel request.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The client token for the request. An Idempotency token.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The metadata of the creation request. Limited to 1KB and UTF-8.
    public var metadata: Swift.String?
    /// The channel mode: UNRESTRICTED or RESTRICTED. Administrators,
    ///          moderators, and channel members can add themselves and other members to unrestricted
    ///          channels. Only administrators and moderators can add members to restricted channels.
    public var mode: ChimeClientTypes.ChannelMode?
    /// The name of the channel.
    /// This member is required.
    public var name: Swift.String?
    /// The channel's privacy level: PUBLIC or PRIVATE. Private
    ///          channels aren't discoverable by users outside the channel. Public channels are discoverable
    ///          by anyone in the AppInstance.
    public var privacy: ChimeClientTypes.ChannelPrivacy?
    /// The tags for the creation request.
    public var tags: [ChimeClientTypes.Tag]?

    public init (
        appInstanceArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        mode: ChimeClientTypes.ChannelMode? = nil,
        name: Swift.String? = nil,
        privacy: ChimeClientTypes.ChannelPrivacy? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.chimeBearer = chimeBearer
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.mode = mode
        self.name = name
        self.privacy = privacy
        self.tags = tags
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    public let appInstanceArn: Swift.String?
    public let name: Swift.String?
    public let mode: ChimeClientTypes.ChannelMode?
    public let privacy: ChimeClientTypes.ChannelPrivacy?
    public let metadata: Swift.String?
    public let clientRequestToken: Swift.String?
    public let tags: [ChimeClientTypes.Tag]?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateChannelMembershipInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelMembershipInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelMembershipOutputError>
}

extension CreateChannelMembershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelMembershipInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), memberArn: \(Swift.String(describing: memberArn)), type: \(Swift.String(describing: type)))"}
}

extension CreateChannelMembershipInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArn = memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateChannelMembershipInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelMembershipOutputError>
}

public struct CreateChannelMembershipInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelMembershipOutputError>
}

public struct CreateChannelMembershipInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelMembershipInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelMembershipOutputError>
}

public struct CreateChannelMembershipInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelMembershipInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/memberships"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelMembershipOutputError>
}

public struct CreateChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel to which you're adding users.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the member you want to add to the channel.
    /// This member is required.
    public var memberArn: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default
    ///          members are always returned as part of ListChannelMemberships. Hidden members
    ///          are only returned if the type filter in ListChannelMemberships equals
    ///             HIDDEN. Otherwise hidden members are not returned. This is only supported
    ///          by moderators.
    /// This member is required.
    public var type: ChimeClientTypes.ChannelMembershipType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil,
        type: ChimeClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
        self.type = type
    }
}

struct CreateChannelMembershipInputBody: Swift.Equatable {
    public let memberArn: Swift.String?
    public let type: ChimeClientTypes.ChannelMembershipType?
}

extension CreateChannelMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelMembershipOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelMembershipOutputResponse(channelArn: \(Swift.String(describing: channelArn)), member: \(Swift.String(describing: member)))"}
}

extension CreateChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.member = output.member
        } else {
            self.channelArn = nil
            self.member = nil
        }
    }
}

public struct CreateChannelMembershipOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ARN and metadata of the member being added.
    public var member: ChimeClientTypes.Identity?

    public init (
        channelArn: Swift.String? = nil,
        member: ChimeClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
    }
}

struct CreateChannelMembershipOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let member: ChimeClientTypes.Identity?
}

extension CreateChannelMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case member = "Member"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

public struct CreateChannelModeratorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelModeratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelModeratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelModeratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelModeratorOutputError>
}

extension CreateChannelModeratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelModeratorInput(channelArn: \(Swift.String(describing: channelArn)), channelModeratorArn: \(Swift.String(describing: channelModeratorArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension CreateChannelModeratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelModeratorArn = "ChannelModeratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelModeratorArn = channelModeratorArn {
            try encodeContainer.encode(channelModeratorArn, forKey: .channelModeratorArn)
        }
    }
}

public struct CreateChannelModeratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelModeratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelModeratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelModeratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelModeratorOutputError>
}

public struct CreateChannelModeratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelModeratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelModeratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelModeratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelModeratorOutputError>
}

public struct CreateChannelModeratorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelModeratorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateChannelModeratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelModeratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelModeratorOutputError>
}

public struct CreateChannelModeratorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelModeratorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateChannelModeratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/moderators"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelModeratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelModeratorOutputError>
}

public struct CreateChannelModeratorInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the moderator.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

struct CreateChannelModeratorInputBody: Swift.Equatable {
    public let channelModeratorArn: Swift.String?
}

extension CreateChannelModeratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelModeratorArn = "ChannelModeratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelModeratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelModeratorArn)
        channelModeratorArn = channelModeratorArnDecoded
    }
}

extension CreateChannelModeratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelModeratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelModeratorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelModeratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelModeratorOutputResponse(channelArn: \(Swift.String(describing: channelArn)), channelModerator: \(Swift.String(describing: channelModerator)))"}
}

extension CreateChannelModeratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelModeratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelModerator = output.channelModerator
        } else {
            self.channelArn = nil
            self.channelModerator = nil
        }
    }
}

public struct CreateChannelModeratorOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ARNs of the channel and the moderator.
    public var channelModerator: ChimeClientTypes.Identity?

    public init (
        channelArn: Swift.String? = nil,
        channelModerator: ChimeClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModerator = channelModerator
    }
}

struct CreateChannelModeratorOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let channelModerator: ChimeClientTypes.Identity?
}

extension CreateChannelModeratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelModerator = "ChannelModerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let channelModeratorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .channelModerator)
        channelModerator = channelModeratorDecoded
    }
}

extension CreateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelOutputResponse(channelArn: \(Swift.String(describing: channelArn)))"}
}

extension CreateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
        } else {
            self.channelArn = nil
        }
    }
}

public struct CreateChannelOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct CreateChannelOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
}

extension CreateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

public struct CreateMediaCapturePipelineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMediaCapturePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMediaCapturePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMediaCapturePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMediaCapturePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMediaCapturePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMediaCapturePipelineOutputError>
}

extension CreateMediaCapturePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaCapturePipelineInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), sinkArn: \(Swift.String(describing: sinkArn)), sinkType: \(Swift.String(describing: sinkType)), sourceArn: \(Swift.String(describing: sourceArn)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension CreateMediaCapturePipelineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sinkArn = sinkArn {
            try encodeContainer.encode(sinkArn, forKey: .sinkArn)
        }
        if let sinkType = sinkType {
            try encodeContainer.encode(sinkType.rawValue, forKey: .sinkType)
        }
        if let sourceArn = sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }
}

public struct CreateMediaCapturePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMediaCapturePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMediaCapturePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMediaCapturePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMediaCapturePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMediaCapturePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMediaCapturePipelineOutputError>
}

public struct CreateMediaCapturePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMediaCapturePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMediaCapturePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMediaCapturePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMediaCapturePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMediaCapturePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMediaCapturePipelineOutputError>
}

public struct CreateMediaCapturePipelineInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMediaCapturePipelineInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateMediaCapturePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMediaCapturePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMediaCapturePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMediaCapturePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMediaCapturePipelineOutputError>
}

public struct CreateMediaCapturePipelineInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMediaCapturePipelineInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateMediaCapturePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMediaCapturePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/media-capture-pipelines"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMediaCapturePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMediaCapturePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMediaCapturePipelineOutputError>
}

public struct CreateMediaCapturePipelineInput: Swift.Equatable {
    /// The token assigned to the client making the pipeline request.
    public var clientRequestToken: Swift.String?
    /// The ARN of the sink type.
    /// This member is required.
    public var sinkArn: Swift.String?
    /// Destination type to which the media artifacts are saved. You must use an S3 bucket.
    /// This member is required.
    public var sinkType: ChimeClientTypes.MediaPipelineSinkType?
    /// ARN of the source from which the media artifacts are captured.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// Source type from which the media artifacts will be captured. A Chime SDK Meeting
    ///             is the only supported source.
    /// This member is required.
    public var sourceType: ChimeClientTypes.MediaPipelineSourceType?

    public init (
        clientRequestToken: Swift.String? = nil,
        sinkArn: Swift.String? = nil,
        sinkType: ChimeClientTypes.MediaPipelineSinkType? = nil,
        sourceArn: Swift.String? = nil,
        sourceType: ChimeClientTypes.MediaPipelineSourceType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sinkArn = sinkArn
        self.sinkType = sinkType
        self.sourceArn = sourceArn
        self.sourceType = sourceType
    }
}

struct CreateMediaCapturePipelineInputBody: Swift.Equatable {
    public let sourceType: ChimeClientTypes.MediaPipelineSourceType?
    public let sourceArn: Swift.String?
    public let sinkType: ChimeClientTypes.MediaPipelineSinkType?
    public let sinkArn: Swift.String?
    public let clientRequestToken: Swift.String?
}

extension CreateMediaCapturePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaPipelineSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sinkTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaPipelineSinkType.self, forKey: .sinkType)
        sinkType = sinkTypeDecoded
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateMediaCapturePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMediaCapturePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMediaCapturePipelineOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMediaCapturePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaCapturePipelineOutputResponse(mediaCapturePipeline: \(Swift.String(describing: mediaCapturePipeline)))"}
}

extension CreateMediaCapturePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMediaCapturePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mediaCapturePipeline = output.mediaCapturePipeline
        } else {
            self.mediaCapturePipeline = nil
        }
    }
}

public struct CreateMediaCapturePipelineOutputResponse: Swift.Equatable {
    /// A media capture pipeline object, the ID, source type, source ARN, sink type, and  sink ARN of a media capture pipeline object.
    public var mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline?

    public init (
        mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline? = nil
    )
    {
        self.mediaCapturePipeline = mediaCapturePipeline
    }
}

struct CreateMediaCapturePipelineOutputResponseBody: Swift.Equatable {
    public let mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline?
}

extension CreateMediaCapturePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipeline = "MediaCapturePipeline"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelineDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaCapturePipeline.self, forKey: .mediaCapturePipeline)
        mediaCapturePipeline = mediaCapturePipelineDecoded
    }
}

public struct CreateMeetingDialOutInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMeetingDialOutInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMeetingDialOutInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeetingDialOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMeetingDialOutInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMeetingDialOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMeetingDialOutOutputError>
}

extension CreateMeetingDialOutInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingDialOutInput(fromPhoneNumber: \(Swift.String(describing: fromPhoneNumber)), joinToken: \(Swift.String(describing: joinToken)), meetingId: \(Swift.String(describing: meetingId)), toPhoneNumber: \(Swift.String(describing: toPhoneNumber)))"}
}

extension CreateMeetingDialOutInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPhoneNumber = "FromPhoneNumber"
        case joinToken = "JoinToken"
        case toPhoneNumber = "ToPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPhoneNumber = fromPhoneNumber {
            try encodeContainer.encode(fromPhoneNumber, forKey: .fromPhoneNumber)
        }
        if let joinToken = joinToken {
            try encodeContainer.encode(joinToken, forKey: .joinToken)
        }
        if let toPhoneNumber = toPhoneNumber {
            try encodeContainer.encode(toPhoneNumber, forKey: .toPhoneNumber)
        }
    }
}

public struct CreateMeetingDialOutInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMeetingDialOutInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMeetingDialOutInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeetingDialOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMeetingDialOutInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMeetingDialOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMeetingDialOutOutputError>
}

public struct CreateMeetingDialOutInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMeetingDialOutInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMeetingDialOutInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeetingDialOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMeetingDialOutInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMeetingDialOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMeetingDialOutOutputError>
}

public struct CreateMeetingDialOutInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMeetingDialOutInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateMeetingDialOutInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeetingDialOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMeetingDialOutInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMeetingDialOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMeetingDialOutOutputError>
}

public struct CreateMeetingDialOutInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMeetingDialOutInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateMeetingDialOutInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeetingDialOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())/dial-outs"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMeetingDialOutInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMeetingDialOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMeetingDialOutOutputError>
}

public struct CreateMeetingDialOutInput: Swift.Equatable {
    /// Phone number used as the caller ID when the remote party receives a call.
    /// This member is required.
    public var fromPhoneNumber: Swift.String?
    /// Token used by the Amazon Chime SDK attendee. Call the <a href="https://docs.aws.amazon.com/chime/latest/APIReference/API_CreateAttendee.html">CreateAttendee action to get a join token.
    /// This member is required.
    public var joinToken: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// Phone number called when inviting someone to a meeting.
    /// This member is required.
    public var toPhoneNumber: Swift.String?

    public init (
        fromPhoneNumber: Swift.String? = nil,
        joinToken: Swift.String? = nil,
        meetingId: Swift.String? = nil,
        toPhoneNumber: Swift.String? = nil
    )
    {
        self.fromPhoneNumber = fromPhoneNumber
        self.joinToken = joinToken
        self.meetingId = meetingId
        self.toPhoneNumber = toPhoneNumber
    }
}

struct CreateMeetingDialOutInputBody: Swift.Equatable {
    public let fromPhoneNumber: Swift.String?
    public let toPhoneNumber: Swift.String?
    public let joinToken: Swift.String?
}

extension CreateMeetingDialOutInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPhoneNumber = "FromPhoneNumber"
        case joinToken = "JoinToken"
        case toPhoneNumber = "ToPhoneNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromPhoneNumber)
        fromPhoneNumber = fromPhoneNumberDecoded
        let toPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toPhoneNumber)
        toPhoneNumber = toPhoneNumberDecoded
        let joinTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .joinToken)
        joinToken = joinTokenDecoded
    }
}

extension CreateMeetingDialOutOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMeetingDialOutOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMeetingDialOutOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMeetingDialOutOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingDialOutOutputResponse(transactionId: \(Swift.String(describing: transactionId)))"}
}

extension CreateMeetingDialOutOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMeetingDialOutOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transactionId = output.transactionId
        } else {
            self.transactionId = nil
        }
    }
}

public struct CreateMeetingDialOutOutputResponse: Swift.Equatable {
    /// Unique ID that tracks API calls.
    public var transactionId: Swift.String?

    public init (
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

struct CreateMeetingDialOutOutputResponseBody: Swift.Equatable {
    public let transactionId: Swift.String?
}

extension CreateMeetingDialOutOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

public struct CreateMeetingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMeetingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMeetingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMeetingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMeetingOutputError>
}

extension CreateMeetingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), externalMeetingId: \(Swift.String(describing: externalMeetingId)), mediaRegion: \(Swift.String(describing: mediaRegion)), meetingHostId: \(Swift.String(describing: meetingHostId)), notificationsConfiguration: \(Swift.String(describing: notificationsConfiguration)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateMeetingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let externalMeetingId = externalMeetingId {
            try encodeContainer.encode(externalMeetingId, forKey: .externalMeetingId)
        }
        if let mediaRegion = mediaRegion {
            try encodeContainer.encode(mediaRegion, forKey: .mediaRegion)
        }
        if let meetingHostId = meetingHostId {
            try encodeContainer.encode(meetingHostId, forKey: .meetingHostId)
        }
        if let notificationsConfiguration = notificationsConfiguration {
            try encodeContainer.encode(notificationsConfiguration, forKey: .notificationsConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for meetingtaglist0 in tags {
                try tagsContainer.encode(meetingtaglist0)
            }
        }
    }
}

public struct CreateMeetingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMeetingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMeetingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMeetingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMeetingOutputError>
}

public struct CreateMeetingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMeetingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMeetingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMeetingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMeetingOutputError>
}

public struct CreateMeetingInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMeetingInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateMeetingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMeetingInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMeetingOutputError>
}

public struct CreateMeetingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMeetingInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateMeetingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/meetings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMeetingInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMeetingOutputError>
}

public struct CreateMeetingInput: Swift.Equatable {
    /// The unique identifier for the client request. Use a different token for different meetings.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The external meeting ID.
    public var externalMeetingId: Swift.String?
    ///
    /// The Region in which to create the meeting. Default: us-east-1.
    ///
    ///
    ///
    /// Available values:
    /// af-south-1
    /// ,
    /// ap-northeast-1
    /// ,
    /// ap-northeast-2
    /// ,
    /// ap-south-1
    /// ,
    /// ap-southeast-1
    /// ,
    /// ap-southeast-2
    /// ,
    /// ca-central-1
    /// ,
    /// eu-central-1
    /// ,
    /// eu-north-1
    /// ,
    /// eu-south-1
    /// ,
    /// eu-west-1
    /// ,
    /// eu-west-2
    /// ,
    /// eu-west-3
    /// ,
    /// sa-east-1
    /// ,
    /// us-east-1
    /// ,
    /// us-east-2
    /// ,
    /// us-west-1
    /// ,
    /// us-west-2
    /// .
    ///
    public var mediaRegion: Swift.String?
    /// Reserved.
    public var meetingHostId: Swift.String?
    /// The configuration for resource targets to receive notifications when meeting and attendee events occur.
    public var notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration?
    /// The tag key-value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        externalMeetingId: Swift.String? = nil,
        mediaRegion: Swift.String? = nil,
        meetingHostId: Swift.String? = nil,
        notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.externalMeetingId = externalMeetingId
        self.mediaRegion = mediaRegion
        self.meetingHostId = meetingHostId
        self.notificationsConfiguration = notificationsConfiguration
        self.tags = tags
    }
}

struct CreateMeetingInputBody: Swift.Equatable {
    public let clientRequestToken: Swift.String?
    public let externalMeetingId: Swift.String?
    public let meetingHostId: Swift.String?
    public let mediaRegion: Swift.String?
    public let tags: [ChimeClientTypes.Tag]?
    public let notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration?
}

extension CreateMeetingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let externalMeetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalMeetingId)
        externalMeetingId = externalMeetingIdDecoded
        let meetingHostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingHostId)
        meetingHostId = meetingHostIdDecoded
        let mediaRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaRegion)
        mediaRegion = mediaRegionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let notificationsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MeetingNotificationConfiguration.self, forKey: .notificationsConfiguration)
        notificationsConfiguration = notificationsConfigurationDecoded
    }
}

extension CreateMeetingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMeetingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMeetingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMeetingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingOutputResponse(meeting: \(Swift.String(describing: meeting)))"}
}

extension CreateMeetingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMeetingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.meeting = output.meeting
        } else {
            self.meeting = nil
        }
    }
}

public struct CreateMeetingOutputResponse: Swift.Equatable {
    ///
    /// The meeting information, including the meeting ID and
    /// MediaPlacement
    /// .
    ///
    public var meeting: ChimeClientTypes.Meeting?

    public init (
        meeting: ChimeClientTypes.Meeting? = nil
    )
    {
        self.meeting = meeting
    }
}

struct CreateMeetingOutputResponseBody: Swift.Equatable {
    public let meeting: ChimeClientTypes.Meeting?
}

extension CreateMeetingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meeting = "Meeting"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Meeting.self, forKey: .meeting)
        meeting = meetingDecoded
    }
}

public struct CreateMeetingWithAttendeesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMeetingWithAttendeesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMeetingWithAttendeesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeetingWithAttendeesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMeetingWithAttendeesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMeetingWithAttendeesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMeetingWithAttendeesOutputError>
}

extension CreateMeetingWithAttendeesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingWithAttendeesInput(attendees: \(Swift.String(describing: attendees)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), externalMeetingId: \(Swift.String(describing: externalMeetingId)), mediaRegion: \(Swift.String(describing: mediaRegion)), meetingHostId: \(Swift.String(describing: meetingHostId)), notificationsConfiguration: \(Swift.String(describing: notificationsConfiguration)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateMeetingWithAttendeesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendees = attendees {
            var attendeesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attendees)
            for createmeetingwithattendeesrequestitemlist0 in attendees {
                try attendeesContainer.encode(createmeetingwithattendeesrequestitemlist0)
            }
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let externalMeetingId = externalMeetingId {
            try encodeContainer.encode(externalMeetingId, forKey: .externalMeetingId)
        }
        if let mediaRegion = mediaRegion {
            try encodeContainer.encode(mediaRegion, forKey: .mediaRegion)
        }
        if let meetingHostId = meetingHostId {
            try encodeContainer.encode(meetingHostId, forKey: .meetingHostId)
        }
        if let notificationsConfiguration = notificationsConfiguration {
            try encodeContainer.encode(notificationsConfiguration, forKey: .notificationsConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for meetingtaglist0 in tags {
                try tagsContainer.encode(meetingtaglist0)
            }
        }
    }
}

public struct CreateMeetingWithAttendeesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMeetingWithAttendeesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMeetingWithAttendeesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeetingWithAttendeesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMeetingWithAttendeesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMeetingWithAttendeesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMeetingWithAttendeesOutputError>
}

public struct CreateMeetingWithAttendeesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMeetingWithAttendeesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMeetingWithAttendeesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeetingWithAttendeesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "create-attendees"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMeetingWithAttendeesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMeetingWithAttendeesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMeetingWithAttendeesOutputError>
}

public struct CreateMeetingWithAttendeesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMeetingWithAttendeesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateMeetingWithAttendeesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeetingWithAttendeesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMeetingWithAttendeesInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMeetingWithAttendeesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMeetingWithAttendeesOutputError>
}

public struct CreateMeetingWithAttendeesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMeetingWithAttendeesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateMeetingWithAttendeesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeetingWithAttendeesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/meetings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMeetingWithAttendeesInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMeetingWithAttendeesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMeetingWithAttendeesOutputError>
}

public struct CreateMeetingWithAttendeesInput: Swift.Equatable {
    /// The request containing the attendees to create.
    public var attendees: [ChimeClientTypes.CreateAttendeeRequestItem]?
    /// The unique identifier for the client request. Use a different token for different meetings.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The external meeting ID.
    public var externalMeetingId: Swift.String?
    ///
    /// The Region in which to create the meeting. Default: us-east-1
    /// .
    ///
    ///
    ///
    /// Available values:
    /// af-south-1
    /// ,
    /// ap-northeast-1
    /// ,
    /// ap-northeast-2
    /// ,
    /// ap-south-1
    /// ,
    /// ap-southeast-1
    /// ,
    /// ap-southeast-2
    /// ,
    /// ca-central-1
    /// ,
    /// eu-central-1
    /// ,
    /// eu-north-1
    /// ,
    /// eu-south-1
    /// ,
    /// eu-west-1
    /// ,
    /// eu-west-2
    /// ,
    /// eu-west-3
    /// ,
    /// sa-east-1
    /// ,
    /// us-east-1
    /// ,
    /// us-east-2
    /// ,
    /// us-west-1
    /// ,
    /// us-west-2
    /// .
    ///
    public var mediaRegion: Swift.String?
    /// Reserved.
    public var meetingHostId: Swift.String?
    ///  The resource target configurations for receiving Amazon Chime SDK meeting and attendee event
    ///             notifications. The Amazon Chime SDK supports resource targets located in the US East (N.
    ///             Virginia) AWS Region (us-east-1).
    public var notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration?
    /// The tag key-value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init (
        attendees: [ChimeClientTypes.CreateAttendeeRequestItem]? = nil,
        clientRequestToken: Swift.String? = nil,
        externalMeetingId: Swift.String? = nil,
        mediaRegion: Swift.String? = nil,
        meetingHostId: Swift.String? = nil,
        notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.attendees = attendees
        self.clientRequestToken = clientRequestToken
        self.externalMeetingId = externalMeetingId
        self.mediaRegion = mediaRegion
        self.meetingHostId = meetingHostId
        self.notificationsConfiguration = notificationsConfiguration
        self.tags = tags
    }
}

struct CreateMeetingWithAttendeesInputBody: Swift.Equatable {
    public let clientRequestToken: Swift.String?
    public let externalMeetingId: Swift.String?
    public let meetingHostId: Swift.String?
    public let mediaRegion: Swift.String?
    public let tags: [ChimeClientTypes.Tag]?
    public let notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration?
    public let attendees: [ChimeClientTypes.CreateAttendeeRequestItem]?
}

extension CreateMeetingWithAttendeesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let externalMeetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalMeetingId)
        externalMeetingId = externalMeetingIdDecoded
        let meetingHostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingHostId)
        meetingHostId = meetingHostIdDecoded
        let mediaRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaRegion)
        mediaRegion = mediaRegionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let notificationsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MeetingNotificationConfiguration.self, forKey: .notificationsConfiguration)
        notificationsConfiguration = notificationsConfigurationDecoded
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.CreateAttendeeRequestItem?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeClientTypes.CreateAttendeeRequestItem]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeClientTypes.CreateAttendeeRequestItem]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
    }
}

extension CreateMeetingWithAttendeesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMeetingWithAttendeesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMeetingWithAttendeesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMeetingWithAttendeesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingWithAttendeesOutputResponse(attendees: \(Swift.String(describing: attendees)), errors: \(Swift.String(describing: errors)), meeting: \(Swift.String(describing: meeting)))"}
}

extension CreateMeetingWithAttendeesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMeetingWithAttendeesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attendees = output.attendees
            self.errors = output.errors
            self.meeting = output.meeting
        } else {
            self.attendees = nil
            self.errors = nil
            self.meeting = nil
        }
    }
}

public struct CreateMeetingWithAttendeesOutputResponse: Swift.Equatable {
    /// The attendee information, including attendees IDs and join tokens.
    public var attendees: [ChimeClientTypes.Attendee]?
    /// If the action fails for one or more of the attendees in the request, a list of the attendees is returned, along with error codes and error messages.
    public var errors: [ChimeClientTypes.CreateAttendeeError]?
    /// A meeting created using the Amazon Chime SDK.
    public var meeting: ChimeClientTypes.Meeting?

    public init (
        attendees: [ChimeClientTypes.Attendee]? = nil,
        errors: [ChimeClientTypes.CreateAttendeeError]? = nil,
        meeting: ChimeClientTypes.Meeting? = nil
    )
    {
        self.attendees = attendees
        self.errors = errors
        self.meeting = meeting
    }
}

struct CreateMeetingWithAttendeesOutputResponseBody: Swift.Equatable {
    public let meeting: ChimeClientTypes.Meeting?
    public let attendees: [ChimeClientTypes.Attendee]?
    public let errors: [ChimeClientTypes.CreateAttendeeError]?
}

extension CreateMeetingWithAttendeesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case errors = "Errors"
        case meeting = "Meeting"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Meeting.self, forKey: .meeting)
        meeting = meetingDecoded
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Attendee?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeClientTypes.Attendee]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeClientTypes.Attendee]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.CreateAttendeeError?].self, forKey: .errors)
        var errorsDecoded0:[ChimeClientTypes.CreateAttendeeError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ChimeClientTypes.CreateAttendeeError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct CreatePhoneNumberOrderInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePhoneNumberOrderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePhoneNumberOrderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePhoneNumberOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePhoneNumberOrderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePhoneNumberOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePhoneNumberOrderOutputError>
}

extension CreatePhoneNumberOrderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePhoneNumberOrderInput(e164PhoneNumbers: \(Swift.String(describing: e164PhoneNumbers)), productType: \(Swift.String(describing: productType)))"}
}

extension CreatePhoneNumberOrderInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case productType = "ProductType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumberlist0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumberlist0)
            }
        }
        if let productType = productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
    }
}

public struct CreatePhoneNumberOrderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePhoneNumberOrderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePhoneNumberOrderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePhoneNumberOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePhoneNumberOrderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePhoneNumberOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePhoneNumberOrderOutputError>
}

public struct CreatePhoneNumberOrderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePhoneNumberOrderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePhoneNumberOrderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePhoneNumberOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePhoneNumberOrderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePhoneNumberOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePhoneNumberOrderOutputError>
}

public struct CreatePhoneNumberOrderInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePhoneNumberOrderInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreatePhoneNumberOrderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePhoneNumberOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePhoneNumberOrderInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePhoneNumberOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePhoneNumberOrderOutputError>
}

public struct CreatePhoneNumberOrderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePhoneNumberOrderInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreatePhoneNumberOrderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePhoneNumberOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/phone-number-orders"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePhoneNumberOrderInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePhoneNumberOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePhoneNumberOrderOutputError>
}

public struct CreatePhoneNumberOrderInput: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// The phone number product type.
    /// This member is required.
    public var productType: ChimeClientTypes.PhoneNumberProductType?

    public init (
        e164PhoneNumbers: [Swift.String]? = nil,
        productType: ChimeClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.productType = productType
    }
}

struct CreatePhoneNumberOrderInputBody: Swift.Equatable {
    public let productType: ChimeClientTypes.PhoneNumberProductType?
    public let e164PhoneNumbers: [Swift.String]?
}

extension CreatePhoneNumberOrderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case productType = "ProductType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
    }
}

extension CreatePhoneNumberOrderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePhoneNumberOrderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePhoneNumberOrderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePhoneNumberOrderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePhoneNumberOrderOutputResponse(phoneNumberOrder: \(Swift.String(describing: phoneNumberOrder)))"}
}

extension CreatePhoneNumberOrderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePhoneNumberOrderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberOrder = output.phoneNumberOrder
        } else {
            self.phoneNumberOrder = nil
        }
    }
}

public struct CreatePhoneNumberOrderOutputResponse: Swift.Equatable {
    /// The phone number order details.
    public var phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder?

    public init (
        phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder? = nil
    )
    {
        self.phoneNumberOrder = phoneNumberOrder
    }
}

struct CreatePhoneNumberOrderOutputResponseBody: Swift.Equatable {
    public let phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder?
}

extension CreatePhoneNumberOrderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberOrder = "PhoneNumberOrder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrderDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberOrder.self, forKey: .phoneNumberOrder)
        phoneNumberOrder = phoneNumberOrderDecoded
    }
}

public struct CreateProxySessionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProxySessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProxySessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProxySessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProxySessionOutputError>
}

extension CreateProxySessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProxySessionInput(capabilities: \(Swift.String(describing: capabilities)), expiryMinutes: \(Swift.String(describing: expiryMinutes)), geoMatchLevel: \(Swift.String(describing: geoMatchLevel)), geoMatchParams: \(Swift.String(describing: geoMatchParams)), name: \(Swift.String(describing: name)), numberSelectionBehavior: \(Swift.String(describing: numberSelectionBehavior)), participantPhoneNumbers: \(Swift.String(describing: participantPhoneNumbers)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension CreateProxySessionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
        case geoMatchLevel = "GeoMatchLevel"
        case geoMatchParams = "GeoMatchParams"
        case name = "Name"
        case numberSelectionBehavior = "NumberSelectionBehavior"
        case participantPhoneNumbers = "ParticipantPhoneNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capabilitylist0 in capabilities {
                try capabilitiesContainer.encode(capabilitylist0.rawValue)
            }
        }
        if let expiryMinutes = expiryMinutes {
            try encodeContainer.encode(expiryMinutes, forKey: .expiryMinutes)
        }
        if let geoMatchLevel = geoMatchLevel {
            try encodeContainer.encode(geoMatchLevel.rawValue, forKey: .geoMatchLevel)
        }
        if let geoMatchParams = geoMatchParams {
            try encodeContainer.encode(geoMatchParams, forKey: .geoMatchParams)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberSelectionBehavior = numberSelectionBehavior {
            try encodeContainer.encode(numberSelectionBehavior.rawValue, forKey: .numberSelectionBehavior)
        }
        if let participantPhoneNumbers = participantPhoneNumbers {
            var participantPhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participantPhoneNumbers)
            for participantphonenumberlist0 in participantPhoneNumbers {
                try participantPhoneNumbersContainer.encode(participantphonenumberlist0)
            }
        }
    }
}

public struct CreateProxySessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProxySessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProxySessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProxySessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProxySessionOutputError>
}

public struct CreateProxySessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProxySessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProxySessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProxySessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProxySessionOutputError>
}

public struct CreateProxySessionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProxySessionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateProxySessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateProxySessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProxySessionOutputError>
}

public struct CreateProxySessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProxySessionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateProxySessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateProxySessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProxySessionOutputError>
}

public struct CreateProxySessionInput: Swift.Equatable {
    /// The proxy session capabilities.
    /// This member is required.
    public var capabilities: [ChimeClientTypes.Capability]?
    /// The number of minutes allowed for the proxy session.
    public var expiryMinutes: Swift.Int?
    /// The preference for matching the country or area code of the proxy phone number with that of the first participant.
    public var geoMatchLevel: ChimeClientTypes.GeoMatchLevel?
    /// The country and area code for the proxy phone number.
    public var geoMatchParams: ChimeClientTypes.GeoMatchParams?
    /// The name of the proxy session.
    public var name: Swift.String?
    /// The preference for proxy phone number reuse, or stickiness, between the same participants across sessions.
    public var numberSelectionBehavior: ChimeClientTypes.NumberSelectionBehavior?
    /// The participant phone numbers.
    /// This member is required.
    public var participantPhoneNumbers: [Swift.String]?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        capabilities: [ChimeClientTypes.Capability]? = nil,
        expiryMinutes: Swift.Int? = nil,
        geoMatchLevel: ChimeClientTypes.GeoMatchLevel? = nil,
        geoMatchParams: ChimeClientTypes.GeoMatchParams? = nil,
        name: Swift.String? = nil,
        numberSelectionBehavior: ChimeClientTypes.NumberSelectionBehavior? = nil,
        participantPhoneNumbers: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.expiryMinutes = expiryMinutes
        self.geoMatchLevel = geoMatchLevel
        self.geoMatchParams = geoMatchParams
        self.name = name
        self.numberSelectionBehavior = numberSelectionBehavior
        self.participantPhoneNumbers = participantPhoneNumbers
        self.voiceConnectorId = voiceConnectorId
    }
}

struct CreateProxySessionInputBody: Swift.Equatable {
    public let participantPhoneNumbers: [Swift.String]?
    public let name: Swift.String?
    public let expiryMinutes: Swift.Int?
    public let capabilities: [ChimeClientTypes.Capability]?
    public let numberSelectionBehavior: ChimeClientTypes.NumberSelectionBehavior?
    public let geoMatchLevel: ChimeClientTypes.GeoMatchLevel?
    public let geoMatchParams: ChimeClientTypes.GeoMatchParams?
}

extension CreateProxySessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
        case geoMatchLevel = "GeoMatchLevel"
        case geoMatchParams = "GeoMatchParams"
        case name = "Name"
        case numberSelectionBehavior = "NumberSelectionBehavior"
        case participantPhoneNumbers = "ParticipantPhoneNumbers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantPhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .participantPhoneNumbers)
        var participantPhoneNumbersDecoded0:[Swift.String]? = nil
        if let participantPhoneNumbersContainer = participantPhoneNumbersContainer {
            participantPhoneNumbersDecoded0 = [Swift.String]()
            for string0 in participantPhoneNumbersContainer {
                if let string0 = string0 {
                    participantPhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        participantPhoneNumbers = participantPhoneNumbersDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiryMinutes)
        expiryMinutes = expiryMinutesDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Capability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[ChimeClientTypes.Capability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [ChimeClientTypes.Capability]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let numberSelectionBehaviorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.NumberSelectionBehavior.self, forKey: .numberSelectionBehavior)
        numberSelectionBehavior = numberSelectionBehaviorDecoded
        let geoMatchLevelDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.GeoMatchLevel.self, forKey: .geoMatchLevel)
        geoMatchLevel = geoMatchLevelDecoded
        let geoMatchParamsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.GeoMatchParams.self, forKey: .geoMatchParams)
        geoMatchParams = geoMatchParamsDecoded
    }
}

extension CreateProxySessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProxySessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProxySessionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProxySessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProxySessionOutputResponse(proxySession: \(Swift.String(describing: proxySession)))"}
}

extension CreateProxySessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateProxySessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proxySession = output.proxySession
        } else {
            self.proxySession = nil
        }
    }
}

public struct CreateProxySessionOutputResponse: Swift.Equatable {
    /// The proxy session details.
    public var proxySession: ChimeClientTypes.ProxySession?

    public init (
        proxySession: ChimeClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

struct CreateProxySessionOutputResponseBody: Swift.Equatable {
    public let proxySession: ChimeClientTypes.ProxySession?
}

extension CreateProxySessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxySession = "ProxySession"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ProxySession.self, forKey: .proxySession)
        proxySession = proxySessionDecoded
    }
}

public struct CreateRoomInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRoomInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRoomInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRoomInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRoomOutputError>
}

extension CreateRoomInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRoomInput(accountId: \(Swift.String(describing: accountId)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), name: \(Swift.String(describing: name)))"}
}

extension CreateRoomInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateRoomInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRoomInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRoomInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRoomInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRoomOutputError>
}

public struct CreateRoomInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRoomInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRoomInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRoomInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRoomOutputError>
}

public struct CreateRoomInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRoomInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateRoomInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRoomInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRoomOutputError>
}

public struct CreateRoomInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRoomInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateRoomInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/rooms"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRoomInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRoomOutputError>
}

public struct CreateRoomInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The idempotency token for the request.
    public var clientRequestToken: Swift.String?
    /// The room name.
    /// This member is required.
    public var name: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.clientRequestToken = clientRequestToken
        self.name = name
    }
}

struct CreateRoomInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let clientRequestToken: Swift.String?
}

extension CreateRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

public struct CreateRoomMembershipInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRoomMembershipInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRoomMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRoomMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRoomMembershipOutputError>
}

extension CreateRoomMembershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRoomMembershipInput(accountId: \(Swift.String(describing: accountId)), memberId: \(Swift.String(describing: memberId)), role: \(Swift.String(describing: role)), roomId: \(Swift.String(describing: roomId)))"}
}

extension CreateRoomMembershipInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberId = "MemberId"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberId = memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
    }
}

public struct CreateRoomMembershipInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRoomMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRoomMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRoomMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRoomMembershipOutputError>
}

public struct CreateRoomMembershipInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRoomMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRoomMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRoomMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRoomMembershipOutputError>
}

public struct CreateRoomMembershipInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRoomMembershipInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateRoomMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRoomMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRoomMembershipOutputError>
}

public struct CreateRoomMembershipInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRoomMembershipInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateRoomMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let roomId = input.roomId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("roomId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/memberships"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRoomMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRoomMembershipOutputError>
}

public struct CreateRoomMembershipInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Chime member ID (user ID or bot ID).
    /// This member is required.
    public var memberId: Swift.String?
    /// The role of the member.
    public var role: ChimeClientTypes.RoomMembershipRole?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        role: ChimeClientTypes.RoomMembershipRole? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.memberId = memberId
        self.role = role
        self.roomId = roomId
    }
}

struct CreateRoomMembershipInputBody: Swift.Equatable {
    public let memberId: Swift.String?
    public let role: ChimeClientTypes.RoomMembershipRole?
}

extension CreateRoomMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberId = "MemberId"
        case role = "Role"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
        let roleDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RoomMembershipRole.self, forKey: .role)
        role = roleDecoded
    }
}

extension CreateRoomMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRoomMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRoomMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRoomMembershipOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRoomMembershipOutputResponse(roomMembership: \(Swift.String(describing: roomMembership)))"}
}

extension CreateRoomMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRoomMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.roomMembership = output.roomMembership
        } else {
            self.roomMembership = nil
        }
    }
}

public struct CreateRoomMembershipOutputResponse: Swift.Equatable {
    /// The room membership details.
    public var roomMembership: ChimeClientTypes.RoomMembership?

    public init (
        roomMembership: ChimeClientTypes.RoomMembership? = nil
    )
    {
        self.roomMembership = roomMembership
    }
}

struct CreateRoomMembershipOutputResponseBody: Swift.Equatable {
    public let roomMembership: ChimeClientTypes.RoomMembership?
}

extension CreateRoomMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomMembership = "RoomMembership"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomMembershipDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RoomMembership.self, forKey: .roomMembership)
        roomMembership = roomMembershipDecoded
    }
}

extension CreateRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRoomOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRoomOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRoomOutputResponse(room: \(Swift.String(describing: room)))"}
}

extension CreateRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRoomOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.room = output.room
        } else {
            self.room = nil
        }
    }
}

public struct CreateRoomOutputResponse: Swift.Equatable {
    /// The room details.
    public var room: ChimeClientTypes.Room?

    public init (
        room: ChimeClientTypes.Room? = nil
    )
    {
        self.room = room
    }
}

struct CreateRoomOutputResponseBody: Swift.Equatable {
    public let room: ChimeClientTypes.Room?
}

extension CreateRoomOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case room = "Room"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Room.self, forKey: .room)
        room = roomDecoded
    }
}

public struct CreateSipMediaApplicationCallInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSipMediaApplicationCallInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSipMediaApplicationCallInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSipMediaApplicationCallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSipMediaApplicationCallInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSipMediaApplicationCallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSipMediaApplicationCallOutputError>
}

extension CreateSipMediaApplicationCallInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSipMediaApplicationCallInput(fromPhoneNumber: \(Swift.String(describing: fromPhoneNumber)), sipHeaders: \(Swift.String(describing: sipHeaders)), sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)), toPhoneNumber: \(Swift.String(describing: toPhoneNumber)))"}
}

extension CreateSipMediaApplicationCallInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPhoneNumber = "FromPhoneNumber"
        case sipHeaders = "SipHeaders"
        case toPhoneNumber = "ToPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPhoneNumber = fromPhoneNumber {
            try encodeContainer.encode(fromPhoneNumber, forKey: .fromPhoneNumber)
        }
        if let sipHeaders = sipHeaders {
            var sipHeadersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sipHeaders)
            for (dictKey0, sipheadersmap0) in sipHeaders {
                try sipHeadersContainer.encode(sipheadersmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let toPhoneNumber = toPhoneNumber {
            try encodeContainer.encode(toPhoneNumber, forKey: .toPhoneNumber)
        }
    }
}

public struct CreateSipMediaApplicationCallInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSipMediaApplicationCallInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSipMediaApplicationCallInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSipMediaApplicationCallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSipMediaApplicationCallInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSipMediaApplicationCallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSipMediaApplicationCallOutputError>
}

public struct CreateSipMediaApplicationCallInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSipMediaApplicationCallInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSipMediaApplicationCallInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSipMediaApplicationCallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSipMediaApplicationCallInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSipMediaApplicationCallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSipMediaApplicationCallOutputError>
}

public struct CreateSipMediaApplicationCallInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSipMediaApplicationCallInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateSipMediaApplicationCallInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSipMediaApplicationCallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSipMediaApplicationCallInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSipMediaApplicationCallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSipMediaApplicationCallOutputError>
}

public struct CreateSipMediaApplicationCallInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSipMediaApplicationCallInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateSipMediaApplicationCallInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSipMediaApplicationCallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sipMediaApplicationId = input.sipMediaApplicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sipMediaApplicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/calls"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSipMediaApplicationCallInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSipMediaApplicationCallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSipMediaApplicationCallOutputError>
}

public struct CreateSipMediaApplicationCallInput: Swift.Equatable {
    /// The phone number that a user calls from. This is a phone number in your Amazon Chime phone number inventory.
    /// This member is required.
    public var fromPhoneNumber: Swift.String?
    /// The SIP headers added to an outbound call leg.
    public var sipHeaders: [Swift.String:Swift.String]?
    /// The ID of the SIP media application.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// The phone number that the service should call.
    /// This member is required.
    public var toPhoneNumber: Swift.String?

    public init (
        fromPhoneNumber: Swift.String? = nil,
        sipHeaders: [Swift.String:Swift.String]? = nil,
        sipMediaApplicationId: Swift.String? = nil,
        toPhoneNumber: Swift.String? = nil
    )
    {
        self.fromPhoneNumber = fromPhoneNumber
        self.sipHeaders = sipHeaders
        self.sipMediaApplicationId = sipMediaApplicationId
        self.toPhoneNumber = toPhoneNumber
    }
}

struct CreateSipMediaApplicationCallInputBody: Swift.Equatable {
    public let fromPhoneNumber: Swift.String?
    public let toPhoneNumber: Swift.String?
    public let sipHeaders: [Swift.String:Swift.String]?
}

extension CreateSipMediaApplicationCallInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPhoneNumber = "FromPhoneNumber"
        case sipHeaders = "SipHeaders"
        case toPhoneNumber = "ToPhoneNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromPhoneNumber)
        fromPhoneNumber = fromPhoneNumberDecoded
        let toPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toPhoneNumber)
        toPhoneNumber = toPhoneNumberDecoded
        let sipHeadersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sipHeaders)
        var sipHeadersDecoded0: [Swift.String:Swift.String]? = nil
        if let sipHeadersContainer = sipHeadersContainer {
            sipHeadersDecoded0 = [Swift.String:Swift.String]()
            for (key0, sensitivestring0) in sipHeadersContainer {
                if let sensitivestring0 = sensitivestring0 {
                    sipHeadersDecoded0?[key0] = sensitivestring0
                }
            }
        }
        sipHeaders = sipHeadersDecoded0
    }
}

extension CreateSipMediaApplicationCallOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSipMediaApplicationCallOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSipMediaApplicationCallOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSipMediaApplicationCallOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSipMediaApplicationCallOutputResponse(sipMediaApplicationCall: \(Swift.String(describing: sipMediaApplicationCall)))"}
}

extension CreateSipMediaApplicationCallOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSipMediaApplicationCallOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationCall = output.sipMediaApplicationCall
        } else {
            self.sipMediaApplicationCall = nil
        }
    }
}

public struct CreateSipMediaApplicationCallOutputResponse: Swift.Equatable {
    /// The actual call.
    public var sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall?

    public init (
        sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall? = nil
    )
    {
        self.sipMediaApplicationCall = sipMediaApplicationCall
    }
}

struct CreateSipMediaApplicationCallOutputResponseBody: Swift.Equatable {
    public let sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall?
}

extension CreateSipMediaApplicationCallOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationCall = "SipMediaApplicationCall"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationCallDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplicationCall.self, forKey: .sipMediaApplicationCall)
        sipMediaApplicationCall = sipMediaApplicationCallDecoded
    }
}

public struct CreateSipMediaApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSipMediaApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSipMediaApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSipMediaApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSipMediaApplicationOutputError>
}

extension CreateSipMediaApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSipMediaApplicationInput(awsRegion: \(Swift.String(describing: awsRegion)), endpoints: \(Swift.String(describing: endpoints)), name: \(Swift.String(describing: name)))"}
}

extension CreateSipMediaApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for sipmediaapplicationendpointlist0 in endpoints {
                try endpointsContainer.encode(sipmediaapplicationendpointlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateSipMediaApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSipMediaApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSipMediaApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSipMediaApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSipMediaApplicationOutputError>
}

public struct CreateSipMediaApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSipMediaApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSipMediaApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSipMediaApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSipMediaApplicationOutputError>
}

public struct CreateSipMediaApplicationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSipMediaApplicationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateSipMediaApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSipMediaApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSipMediaApplicationOutputError>
}

public struct CreateSipMediaApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSipMediaApplicationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateSipMediaApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/sip-media-applications"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSipMediaApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSipMediaApplicationOutputError>
}

public struct CreateSipMediaApplicationInput: Swift.Equatable {
    /// The AWS Region assigned to the SIP media application.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// List of endpoints (Lambda Amazon Resource Names) specified for the SIP media application. Currently, only one endpoint is supported.
    /// This member is required.
    public var endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]?
    /// The SIP media application name.
    /// This member is required.
    public var name: Swift.String?

    public init (
        awsRegion: Swift.String? = nil,
        endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]? = nil,
        name: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.endpoints = endpoints
        self.name = name
    }
}

struct CreateSipMediaApplicationInputBody: Swift.Equatable {
    public let awsRegion: Swift.String?
    public let name: Swift.String?
    public let endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]?
}

extension CreateSipMediaApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipMediaApplicationEndpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[ChimeClientTypes.SipMediaApplicationEndpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [ChimeClientTypes.SipMediaApplicationEndpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension CreateSipMediaApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSipMediaApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSipMediaApplicationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSipMediaApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSipMediaApplicationOutputResponse(sipMediaApplication: \(Swift.String(describing: sipMediaApplication)))"}
}

extension CreateSipMediaApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSipMediaApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplication = output.sipMediaApplication
        } else {
            self.sipMediaApplication = nil
        }
    }
}

public struct CreateSipMediaApplicationOutputResponse: Swift.Equatable {
    /// The SIP media application details.
    public var sipMediaApplication: ChimeClientTypes.SipMediaApplication?

    public init (
        sipMediaApplication: ChimeClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

struct CreateSipMediaApplicationOutputResponseBody: Swift.Equatable {
    public let sipMediaApplication: ChimeClientTypes.SipMediaApplication?
}

extension CreateSipMediaApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplication = "SipMediaApplication"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplication.self, forKey: .sipMediaApplication)
        sipMediaApplication = sipMediaApplicationDecoded
    }
}

public struct CreateSipRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSipRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSipRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSipRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSipRuleOutputError>
}

extension CreateSipRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSipRuleInput(disabled: \(Swift.String(describing: disabled)), name: \(Swift.String(describing: name)), targetApplications: \(Swift.String(describing: targetApplications)), triggerType: \(Swift.String(describing: triggerType)), triggerValue: \(Swift.String(describing: triggerValue)))"}
}

extension CreateSipRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
        case triggerType = "TriggerType"
        case triggerValue = "TriggerValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetApplications = targetApplications {
            var targetApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetApplications)
            for sipruletargetapplicationlist0 in targetApplications {
                try targetApplicationsContainer.encode(sipruletargetapplicationlist0)
            }
        }
        if let triggerType = triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
        if let triggerValue = triggerValue {
            try encodeContainer.encode(triggerValue, forKey: .triggerValue)
        }
    }
}

public struct CreateSipRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSipRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSipRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSipRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSipRuleOutputError>
}

public struct CreateSipRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSipRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSipRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSipRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSipRuleOutputError>
}

public struct CreateSipRuleInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSipRuleInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateSipRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSipRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSipRuleOutputError>
}

public struct CreateSipRuleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSipRuleInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateSipRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/sip-rules"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSipRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSipRuleOutputError>
}

public struct CreateSipRuleInput: Swift.Equatable {
    /// Enables or disables a rule. You must disable rules before you can delete them.
    public var disabled: Swift.Bool?
    /// The name of the SIP rule.
    /// This member is required.
    public var name: Swift.String?
    /// List of SIP media applications with priority and AWS Region. Only one SIP application per AWS Region can be used.
    /// This member is required.
    public var targetApplications: [ChimeClientTypes.SipRuleTargetApplication]?
    /// The type of trigger assigned to the SIP rule in TriggerValue, currently RequestUriHostname or ToPhoneNumber.
    /// This member is required.
    public var triggerType: ChimeClientTypes.SipRuleTriggerType?
    /// If TriggerType is RequestUriHostname, the value can be the outbound
    ///             host name of an Amazon Chime Voice Connector. If TriggerType is
    ///                 ToPhoneNumber, the value can be a customer-owned phone number in the
    ///     E164 format. The SipMediaApplication specified in the SipRule is triggered if the request URI in an incoming SIP
    ///     request matches the RequestUriHostname, or if the To header in the incoming SIP request matches the
    ///     ToPhoneNumber value.
    /// This member is required.
    public var triggerValue: Swift.String?

    public init (
        disabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        targetApplications: [ChimeClientTypes.SipRuleTargetApplication]? = nil,
        triggerType: ChimeClientTypes.SipRuleTriggerType? = nil,
        triggerValue: Swift.String? = nil
    )
    {
        self.disabled = disabled
        self.name = name
        self.targetApplications = targetApplications
        self.triggerType = triggerType
        self.triggerValue = triggerValue
    }
}

struct CreateSipRuleInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let triggerType: ChimeClientTypes.SipRuleTriggerType?
    public let triggerValue: Swift.String?
    public let disabled: Swift.Bool?
    public let targetApplications: [ChimeClientTypes.SipRuleTargetApplication]?
}

extension CreateSipRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
        case triggerType = "TriggerType"
        case triggerValue = "TriggerValue"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let triggerTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipRuleTriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .triggerValue)
        triggerValue = triggerValueDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let targetApplicationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipRuleTargetApplication?].self, forKey: .targetApplications)
        var targetApplicationsDecoded0:[ChimeClientTypes.SipRuleTargetApplication]? = nil
        if let targetApplicationsContainer = targetApplicationsContainer {
            targetApplicationsDecoded0 = [ChimeClientTypes.SipRuleTargetApplication]()
            for structure0 in targetApplicationsContainer {
                if let structure0 = structure0 {
                    targetApplicationsDecoded0?.append(structure0)
                }
            }
        }
        targetApplications = targetApplicationsDecoded0
    }
}

extension CreateSipRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSipRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSipRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSipRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSipRuleOutputResponse(sipRule: \(Swift.String(describing: sipRule)))"}
}

extension CreateSipRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSipRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipRule = output.sipRule
        } else {
            self.sipRule = nil
        }
    }
}

public struct CreateSipRuleOutputResponse: Swift.Equatable {
    /// Returns the SIP rule information, including the rule ID, triggers, and target applications.
    public var sipRule: ChimeClientTypes.SipRule?

    public init (
        sipRule: ChimeClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

struct CreateSipRuleOutputResponseBody: Swift.Equatable {
    public let sipRule: ChimeClientTypes.SipRule?
}

extension CreateSipRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipRule = "SipRule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipRule.self, forKey: .sipRule)
        sipRule = sipRuleDecoded
    }
}

public struct CreateUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(accountId: \(Swift.String(describing: accountId)), email: \(Swift.String(describing: email)), userType: \(Swift.String(describing: userType)), username: \(Swift.String(describing: username)))"}
}

extension CreateUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case userType = "UserType"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let userType = userType {
            try encodeContainer.encode(userType.rawValue, forKey: .userType)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct CreateUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "create"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/users"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user's email address.
    public var email: Swift.String?
    /// The user type.
    public var userType: ChimeClientTypes.UserType?
    /// The user name.
    public var username: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        email: Swift.String? = nil,
        userType: ChimeClientTypes.UserType? = nil,
        username: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.email = email
        self.userType = userType
        self.username = username
    }
}

struct CreateUserInputBody: Swift.Equatable {
    public let username: Swift.String?
    public let email: Swift.String?
    public let userType: ChimeClientTypes.UserType?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case userType = "UserType"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let userTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.UserType.self, forKey: .userType)
        userType = userTypeDecoded
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserOutputResponse(user: \(Swift.String(describing: user)))"}
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct CreateUserOutputResponse: Swift.Equatable {
    /// The user on the Amazon Chime account.
    public var user: ChimeClientTypes.User?

    public init (
        user: ChimeClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct CreateUserOutputResponseBody: Swift.Equatable {
    public let user: ChimeClientTypes.User?
}

extension CreateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

public struct CreateVoiceConnectorGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVoiceConnectorGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVoiceConnectorGroupOutputError>
}

extension CreateVoiceConnectorGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVoiceConnectorGroupInput(name: \(Swift.String(describing: name)), voiceConnectorItems: \(Swift.String(describing: voiceConnectorItems)))"}
}

extension CreateVoiceConnectorGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let voiceConnectorItems = voiceConnectorItems {
            var voiceConnectorItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .voiceConnectorItems)
            for voiceconnectoritemlist0 in voiceConnectorItems {
                try voiceConnectorItemsContainer.encode(voiceconnectoritemlist0)
            }
        }
    }
}

public struct CreateVoiceConnectorGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVoiceConnectorGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVoiceConnectorGroupOutputError>
}

public struct CreateVoiceConnectorGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVoiceConnectorGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVoiceConnectorGroupOutputError>
}

public struct CreateVoiceConnectorGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVoiceConnectorGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateVoiceConnectorGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateVoiceConnectorGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVoiceConnectorGroupOutputError>
}

public struct CreateVoiceConnectorGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVoiceConnectorGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateVoiceConnectorGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/voice-connector-groups"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateVoiceConnectorGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVoiceConnectorGroupOutputError>
}

public struct CreateVoiceConnectorGroupInput: Swift.Equatable {
    /// The name of the Amazon Chime Voice Connector group.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Chime Voice Connectors to route inbound calls to.
    public var voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]?

    public init (
        name: Swift.String? = nil,
        voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]? = nil
    )
    {
        self.name = name
        self.voiceConnectorItems = voiceConnectorItems
    }
}

struct CreateVoiceConnectorGroupInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]?
}

extension CreateVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let voiceConnectorItemsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.VoiceConnectorItem?].self, forKey: .voiceConnectorItems)
        var voiceConnectorItemsDecoded0:[ChimeClientTypes.VoiceConnectorItem]? = nil
        if let voiceConnectorItemsContainer = voiceConnectorItemsContainer {
            voiceConnectorItemsDecoded0 = [ChimeClientTypes.VoiceConnectorItem]()
            for structure0 in voiceConnectorItemsContainer {
                if let structure0 = structure0 {
                    voiceConnectorItemsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorItems = voiceConnectorItemsDecoded0
    }
}

extension CreateVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVoiceConnectorGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVoiceConnectorGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVoiceConnectorGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVoiceConnectorGroupOutputResponse(voiceConnectorGroup: \(Swift.String(describing: voiceConnectorGroup)))"}
}

extension CreateVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateVoiceConnectorGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorGroup = output.voiceConnectorGroup
        } else {
            self.voiceConnectorGroup = nil
        }
    }
}

public struct CreateVoiceConnectorGroupOutputResponse: Swift.Equatable {
    /// The Amazon Chime Voice Connector group details.
    public var voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup?

    public init (
        voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

struct CreateVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
    public let voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup?
}

extension CreateVoiceConnectorGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorGroup = "VoiceConnectorGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnectorGroup.self, forKey: .voiceConnectorGroup)
        voiceConnectorGroup = voiceConnectorGroupDecoded
    }
}

public struct CreateVoiceConnectorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVoiceConnectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVoiceConnectorOutputError>
}

extension CreateVoiceConnectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVoiceConnectorInput(awsRegion: \(Swift.String(describing: awsRegion)), name: \(Swift.String(describing: name)), requireEncryption: \(Swift.String(describing: requireEncryption)))"}
}

extension CreateVoiceConnectorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion.rawValue, forKey: .awsRegion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requireEncryption = requireEncryption {
            try encodeContainer.encode(requireEncryption, forKey: .requireEncryption)
        }
    }
}

public struct CreateVoiceConnectorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVoiceConnectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVoiceConnectorOutputError>
}

public struct CreateVoiceConnectorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVoiceConnectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVoiceConnectorOutputError>
}

public struct CreateVoiceConnectorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVoiceConnectorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateVoiceConnectorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateVoiceConnectorInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVoiceConnectorOutputError>
}

public struct CreateVoiceConnectorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVoiceConnectorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateVoiceConnectorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/voice-connectors"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateVoiceConnectorInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVoiceConnectorOutputError>
}

public struct CreateVoiceConnectorInput: Swift.Equatable {
    ///
    /// The AWS Region in which the Amazon Chime Voice Connector is created. Default value:
    /// us-east-1
    /// .
    ///
    public var awsRegion: ChimeClientTypes.VoiceConnectorAwsRegion?
    /// The name of the Amazon Chime Voice Connector.
    /// This member is required.
    public var name: Swift.String?
    /// When enabled, requires encryption for the Amazon Chime Voice Connector.
    /// This member is required.
    public var requireEncryption: Swift.Bool?

    public init (
        awsRegion: ChimeClientTypes.VoiceConnectorAwsRegion? = nil,
        name: Swift.String? = nil,
        requireEncryption: Swift.Bool? = nil
    )
    {
        self.awsRegion = awsRegion
        self.name = name
        self.requireEncryption = requireEncryption
    }
}

struct CreateVoiceConnectorInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let awsRegion: ChimeClientTypes.VoiceConnectorAwsRegion?
    public let requireEncryption: Swift.Bool?
}

extension CreateVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnectorAwsRegion.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let requireEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireEncryption)
        requireEncryption = requireEncryptionDecoded
    }
}

extension CreateVoiceConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVoiceConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVoiceConnectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVoiceConnectorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVoiceConnectorOutputResponse(voiceConnector: \(Swift.String(describing: voiceConnector)))"}
}

extension CreateVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateVoiceConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct CreateVoiceConnectorOutputResponse: Swift.Equatable {
    /// The Amazon Chime Voice Connector details.
    public var voiceConnector: ChimeClientTypes.VoiceConnector?

    public init (
        voiceConnector: ChimeClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct CreateVoiceConnectorOutputResponseBody: Swift.Equatable {
    public let voiceConnector: ChimeClientTypes.VoiceConnector?
}

extension CreateVoiceConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnector.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension ChimeClientTypes.Credential: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension ChimeClientTypes.Credential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Credential(password: \(Swift.String(describing: password)), username: \(Swift.String(describing: username)))"}
}

extension ChimeClientTypes {
    /// The SIP credentials used to authenticate requests to your Amazon Chime Voice Connector.
    public struct Credential: Swift.Equatable {
        /// The RFC2617 compliant password associated with the SIP credentials, in US-ASCII format.
        public var password: Swift.String?
        /// The RFC2617 compliant user name associated with the SIP credentials, in US-ASCII
        ///             format.
        public var username: Swift.String?

        public init (
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension ChimeClientTypes.DNISEmergencyCallingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingCountry = "CallingCountry"
        case emergencyPhoneNumber = "EmergencyPhoneNumber"
        case testPhoneNumber = "TestPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingCountry = callingCountry {
            try encodeContainer.encode(callingCountry, forKey: .callingCountry)
        }
        if let emergencyPhoneNumber = emergencyPhoneNumber {
            try encodeContainer.encode(emergencyPhoneNumber, forKey: .emergencyPhoneNumber)
        }
        if let testPhoneNumber = testPhoneNumber {
            try encodeContainer.encode(testPhoneNumber, forKey: .testPhoneNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emergencyPhoneNumber)
        emergencyPhoneNumber = emergencyPhoneNumberDecoded
        let testPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testPhoneNumber)
        testPhoneNumber = testPhoneNumberDecoded
        let callingCountryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingCountry)
        callingCountry = callingCountryDecoded
    }
}

extension ChimeClientTypes.DNISEmergencyCallingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DNISEmergencyCallingConfiguration(callingCountry: \(Swift.String(describing: callingCountry)), emergencyPhoneNumber: \(Swift.String(describing: emergencyPhoneNumber)), testPhoneNumber: \(Swift.String(describing: testPhoneNumber)))"}
}

extension ChimeClientTypes {
    /// The Dialed Number Identification Service (DNIS) emergency calling configuration details associated with an Amazon Chime Voice Connector's emergency calling configuration.
    public struct DNISEmergencyCallingConfiguration: Swift.Equatable {
        /// The country from which emergency calls are allowed, in ISO 3166-1 alpha-2 format.
        /// This member is required.
        public var callingCountry: Swift.String?
        /// The DNIS phone number to route emergency calls to, in E.164 format.
        /// This member is required.
        public var emergencyPhoneNumber: Swift.String?
        /// The DNIS phone number to route test emergency calls to, in E.164 format.
        public var testPhoneNumber: Swift.String?

        public init (
            callingCountry: Swift.String? = nil,
            emergencyPhoneNumber: Swift.String? = nil,
            testPhoneNumber: Swift.String? = nil
        )
        {
            self.callingCountry = callingCountry
            self.emergencyPhoneNumber = emergencyPhoneNumber
            self.testPhoneNumber = testPhoneNumber
        }
    }

}

extension DeleteAccountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAccountInput(accountId: \(Swift.String(describing: accountId)))"}
}

extension DeleteAccountInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAccountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccountOutputError>
}

public struct DeleteAccountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccountOutputError>
}

public struct DeleteAccountInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccountInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccountOutputError>
}

public struct DeleteAccountInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccountInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccountOutputError>
}

public struct DeleteAccountInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct DeleteAccountInputBody: Swift.Equatable {
}

extension DeleteAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAccountOutputResponse()"}
}

extension DeleteAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccountOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAccountOutputResponseBody: Swift.Equatable {
}

extension DeleteAccountOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceAdminInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInstanceAdminInput(appInstanceAdminArn: \(Swift.String(describing: appInstanceAdminArn)), appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension DeleteAppInstanceAdminInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAppInstanceAdminInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceAdminInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInstanceAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInstanceAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceAdminOutputError>
}

public struct DeleteAppInstanceAdminInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceAdminInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInstanceAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInstanceAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceAdminOutputError>
}

public struct DeleteAppInstanceAdminInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceAdminInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInstanceAdminInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInstanceAdminInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceAdminOutputError>
}

public struct DeleteAppInstanceAdminInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceAdminInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInstanceAdminInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        guard let appInstanceAdminArn = input.appInstanceAdminArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceAdminArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins/\(appInstanceAdminArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInstanceAdminInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceAdminOutputError>
}

public struct DeleteAppInstanceAdminInput: Swift.Equatable {
    /// The ARN of the AppInstance's administrator.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

struct DeleteAppInstanceAdminInputBody: Swift.Equatable {
}

extension DeleteAppInstanceAdminInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceAdminOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppInstanceAdminOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppInstanceAdminOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppInstanceAdminOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInstanceAdminOutputResponse()"}
}

extension DeleteAppInstanceAdminOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppInstanceAdminOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAppInstanceAdminOutputResponseBody: Swift.Equatable {
}

extension DeleteAppInstanceAdminOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInstanceInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension DeleteAppInstanceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAppInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceOutputError>
}

public struct DeleteAppInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceOutputError>
}

public struct DeleteAppInstanceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceOutputError>
}

public struct DeleteAppInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceOutputError>
}

public struct DeleteAppInstanceInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct DeleteAppInstanceInputBody: Swift.Equatable {
}

extension DeleteAppInstanceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppInstanceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInstanceOutputResponse()"}
}

extension DeleteAppInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAppInstanceOutputResponseBody: Swift.Equatable {
}

extension DeleteAppInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceStreamingConfigurationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInstanceStreamingConfigurationsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension DeleteAppInstanceStreamingConfigurationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAppInstanceStreamingConfigurationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceStreamingConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInstanceStreamingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceStreamingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInstanceStreamingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceStreamingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceStreamingConfigurationsOutputError>
}

public struct DeleteAppInstanceStreamingConfigurationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceStreamingConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInstanceStreamingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceStreamingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInstanceStreamingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceStreamingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceStreamingConfigurationsOutputError>
}

public struct DeleteAppInstanceStreamingConfigurationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceStreamingConfigurationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInstanceStreamingConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceStreamingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInstanceStreamingConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceStreamingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceStreamingConfigurationsOutputError>
}

public struct DeleteAppInstanceStreamingConfigurationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceStreamingConfigurationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInstanceStreamingConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceStreamingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())/streaming-configurations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInstanceStreamingConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceStreamingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceStreamingConfigurationsOutputError>
}

public struct DeleteAppInstanceStreamingConfigurationsInput: Swift.Equatable {
    /// The ARN of the streaming configurations being deleted.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct DeleteAppInstanceStreamingConfigurationsInputBody: Swift.Equatable {
}

extension DeleteAppInstanceStreamingConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceStreamingConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppInstanceStreamingConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppInstanceStreamingConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppInstanceStreamingConfigurationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInstanceStreamingConfigurationsOutputResponse()"}
}

extension DeleteAppInstanceStreamingConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppInstanceStreamingConfigurationsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAppInstanceStreamingConfigurationsOutputResponseBody: Swift.Equatable {
}

extension DeleteAppInstanceStreamingConfigurationsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)))"}
}

extension DeleteAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceUserOutputError>
}

public struct DeleteAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceUserOutputError>
}

public struct DeleteAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceUserOutputError>
}

public struct DeleteAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceUserArn = input.appInstanceUserArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceUserArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAppInstanceUserOutputError>
}

public struct DeleteAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the user request being deleted.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct DeleteAppInstanceUserInputBody: Swift.Equatable {
}

extension DeleteAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAppInstanceUserOutputResponse()"}
}

extension DeleteAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppInstanceUserOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAppInstanceUserOutputResponseBody: Swift.Equatable {
}

extension DeleteAppInstanceUserOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAttendeeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAttendeeInput(attendeeId: \(Swift.String(describing: attendeeId)), meetingId: \(Swift.String(describing: meetingId)))"}
}

extension DeleteAttendeeInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAttendeeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAttendeeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAttendeeOutputError>
}

public struct DeleteAttendeeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAttendeeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAttendeeOutputError>
}

public struct DeleteAttendeeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAttendeeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAttendeeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAttendeeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAttendeeOutputError>
}

public struct DeleteAttendeeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAttendeeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAttendeeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        guard let attendeeId = input.attendeeId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("attendeeId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAttendeeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAttendeeOutputError>
}

public struct DeleteAttendeeInput: Swift.Equatable {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init (
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
    }
}

struct DeleteAttendeeInputBody: Swift.Equatable {
}

extension DeleteAttendeeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAttendeeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAttendeeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAttendeeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAttendeeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAttendeeOutputResponse()"}
}

extension DeleteAttendeeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAttendeeOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAttendeeOutputResponseBody: Swift.Equatable {
}

extension DeleteAttendeeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelBanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelBanInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), memberArn: \(Swift.String(describing: memberArn)))"}
}

extension DeleteChannelBanInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteChannelBanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelBanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelBanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelBanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelBanOutputError>
}

public struct DeleteChannelBanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelBanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelBanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelBanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelBanOutputError>
}

public struct DeleteChannelBanInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelBanInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelBanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelBanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelBanOutputError>
}

public struct DeleteChannelBanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelBanInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelBanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let memberArn = input.memberArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("memberArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/bans/\(memberArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelBanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelBanOutputError>
}

public struct DeleteChannelBanInput: Swift.Equatable {
    /// The ARN of the channel from which the AppInstanceUser was banned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the AppInstanceUser that you want to reinstate.
    /// This member is required.
    public var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct DeleteChannelBanInputBody: Swift.Equatable {
}

extension DeleteChannelBanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelBanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelBanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelBanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelBanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelBanOutputResponse()"}
}

extension DeleteChannelBanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelBanOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteChannelBanOutputResponseBody: Swift.Equatable {
}

extension DeleteChannelBanOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension DeleteChannelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInput: Swift.Equatable {
    /// The ARN of the channel being deleted.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct DeleteChannelInputBody: Swift.Equatable {
}

extension DeleteChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelMembershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelMembershipInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), memberArn: \(Swift.String(describing: memberArn)))"}
}

extension DeleteChannelMembershipInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteChannelMembershipInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMembershipOutputError>
}

public struct DeleteChannelMembershipInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMembershipOutputError>
}

public struct DeleteChannelMembershipInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMembershipInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMembershipOutputError>
}

public struct DeleteChannelMembershipInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMembershipInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let memberArn = input.memberArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("memberArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMembershipOutputError>
}

public struct DeleteChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel from which you want to remove the user.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the member that you're removing from the channel.
    /// This member is required.
    public var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct DeleteChannelMembershipInputBody: Swift.Equatable {
}

extension DeleteChannelMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelMembershipOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelMembershipOutputResponse()"}
}

extension DeleteChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelMembershipOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteChannelMembershipOutputResponseBody: Swift.Equatable {
}

extension DeleteChannelMembershipOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), messageId: \(Swift.String(describing: messageId)))"}
}

extension DeleteChannelMessageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteChannelMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMessageOutputError>
}

public struct DeleteChannelMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMessageOutputError>
}

public struct DeleteChannelMessageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMessageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMessageOutputError>
}

public struct DeleteChannelMessageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelMessageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let messageId = input.messageId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("messageId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelMessageOutputError>
}

public struct DeleteChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ID of the message being deleted.
    /// This member is required.
    public var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

struct DeleteChannelMessageInputBody: Swift.Equatable {
}

extension DeleteChannelMessageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelMessageOutputResponse()"}
}

extension DeleteChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelMessageOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteChannelMessageOutputResponseBody: Swift.Equatable {
}

extension DeleteChannelMessageOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelModeratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelModeratorInput(channelArn: \(Swift.String(describing: channelArn)), channelModeratorArn: \(Swift.String(describing: channelModeratorArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension DeleteChannelModeratorInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteChannelModeratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelModeratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelModeratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelModeratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelModeratorOutputError>
}

public struct DeleteChannelModeratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelModeratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelModeratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelModeratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelModeratorOutputError>
}

public struct DeleteChannelModeratorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelModeratorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelModeratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelModeratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelModeratorOutputError>
}

public struct DeleteChannelModeratorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelModeratorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteChannelModeratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let channelModeratorArn = input.channelModeratorArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelModeratorArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/moderators/\(channelModeratorArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelModeratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelModeratorOutputError>
}

public struct DeleteChannelModeratorInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the moderator being deleted.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

struct DeleteChannelModeratorInputBody: Swift.Equatable {
}

extension DeleteChannelModeratorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelModeratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelModeratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelModeratorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelModeratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelModeratorOutputResponse()"}
}

extension DeleteChannelModeratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelModeratorOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteChannelModeratorOutputResponseBody: Swift.Equatable {
}

extension DeleteChannelModeratorOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelOutputResponse()"}
}

extension DeleteChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteChannelOutputResponseBody: Swift.Equatable {
}

extension DeleteChannelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEventsConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventsConfigurationInput(accountId: \(Swift.String(describing: accountId)), botId: \(Swift.String(describing: botId)))"}
}

extension DeleteEventsConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteEventsConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventsConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventsConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventsConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventsConfigurationOutputError>
}

public struct DeleteEventsConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventsConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventsConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventsConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventsConfigurationOutputError>
}

public struct DeleteEventsConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventsConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteEventsConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEventsConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventsConfigurationOutputError>
}

public struct DeleteEventsConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventsConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteEventsConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let botId = input.botId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("botId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())/events-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEventsConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventsConfigurationOutputError>
}

public struct DeleteEventsConfigurationInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
    }
}

struct DeleteEventsConfigurationInputBody: Swift.Equatable {
}

extension DeleteEventsConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEventsConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventsConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventsConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventsConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventsConfigurationOutputResponse()"}
}

extension DeleteEventsConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventsConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteEventsConfigurationOutputResponseBody: Swift.Equatable {
}

extension DeleteEventsConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMediaCapturePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMediaCapturePipelineInput(mediaPipelineId: \(Swift.String(describing: mediaPipelineId)))"}
}

extension DeleteMediaCapturePipelineInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteMediaCapturePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMediaCapturePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMediaCapturePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMediaCapturePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMediaCapturePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMediaCapturePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMediaCapturePipelineOutputError>
}

public struct DeleteMediaCapturePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMediaCapturePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMediaCapturePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMediaCapturePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMediaCapturePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMediaCapturePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMediaCapturePipelineOutputError>
}

public struct DeleteMediaCapturePipelineInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMediaCapturePipelineInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteMediaCapturePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMediaCapturePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMediaCapturePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMediaCapturePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMediaCapturePipelineOutputError>
}

public struct DeleteMediaCapturePipelineInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMediaCapturePipelineInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteMediaCapturePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMediaCapturePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let mediaPipelineId = input.mediaPipelineId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("mediaPipelineId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/media-capture-pipelines/\(mediaPipelineId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMediaCapturePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMediaCapturePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMediaCapturePipelineOutputError>
}

public struct DeleteMediaCapturePipelineInput: Swift.Equatable {
    /// The ID of the media capture pipeline being deleted.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init (
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

struct DeleteMediaCapturePipelineInputBody: Swift.Equatable {
}

extension DeleteMediaCapturePipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMediaCapturePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMediaCapturePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMediaCapturePipelineOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMediaCapturePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMediaCapturePipelineOutputResponse()"}
}

extension DeleteMediaCapturePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMediaCapturePipelineOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteMediaCapturePipelineOutputResponseBody: Swift.Equatable {
}

extension DeleteMediaCapturePipelineOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMeetingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMeetingInput(meetingId: \(Swift.String(describing: meetingId)))"}
}

extension DeleteMeetingInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteMeetingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMeetingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMeetingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMeetingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMeetingOutputError>
}

public struct DeleteMeetingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMeetingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMeetingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMeetingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMeetingOutputError>
}

public struct DeleteMeetingInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMeetingInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteMeetingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMeetingInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMeetingOutputError>
}

public struct DeleteMeetingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMeetingInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteMeetingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMeetingInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMeetingOutputError>
}

public struct DeleteMeetingInput: Swift.Equatable {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init (
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

struct DeleteMeetingInputBody: Swift.Equatable {
}

extension DeleteMeetingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMeetingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMeetingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMeetingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMeetingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMeetingOutputResponse()"}
}

extension DeleteMeetingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMeetingOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteMeetingOutputResponseBody: Swift.Equatable {
}

extension DeleteMeetingOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePhoneNumberInput(phoneNumberId: \(Swift.String(describing: phoneNumberId)))"}
}

extension DeletePhoneNumberInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeletePhoneNumberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePhoneNumberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePhoneNumberOutputError>
}

public struct DeletePhoneNumberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePhoneNumberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePhoneNumberOutputError>
}

public struct DeletePhoneNumberInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePhoneNumberInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeletePhoneNumberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePhoneNumberInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePhoneNumberOutputError>
}

public struct DeletePhoneNumberInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePhoneNumberInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeletePhoneNumberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let phoneNumberId = input.phoneNumberId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("phoneNumberId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePhoneNumberInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePhoneNumberOutputError>
}

public struct DeletePhoneNumberInput: Swift.Equatable {
    /// The phone number ID.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init (
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct DeletePhoneNumberInputBody: Swift.Equatable {
}

extension DeletePhoneNumberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePhoneNumberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePhoneNumberOutputResponse()"}
}

extension DeletePhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePhoneNumberOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePhoneNumberOutputResponseBody: Swift.Equatable {
}

extension DeletePhoneNumberOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProxySessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProxySessionInput(proxySessionId: \(Swift.String(describing: proxySessionId)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension DeleteProxySessionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteProxySessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProxySessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProxySessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProxySessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProxySessionOutputError>
}

public struct DeleteProxySessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProxySessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProxySessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProxySessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProxySessionOutputError>
}

public struct DeleteProxySessionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProxySessionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteProxySessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProxySessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProxySessionOutputError>
}

public struct DeleteProxySessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProxySessionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteProxySessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        guard let proxySessionId = input.proxySessionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("proxySessionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProxySessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProxySessionOutputError>
}

public struct DeleteProxySessionInput: Swift.Equatable {
    /// The proxy session ID.
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteProxySessionInputBody: Swift.Equatable {
}

extension DeleteProxySessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProxySessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProxySessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProxySessionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProxySessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProxySessionOutputResponse()"}
}

extension DeleteProxySessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProxySessionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteProxySessionOutputResponseBody: Swift.Equatable {
}

extension DeleteProxySessionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRoomInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRoomInput(accountId: \(Swift.String(describing: accountId)), roomId: \(Swift.String(describing: roomId)))"}
}

extension DeleteRoomInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteRoomInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRoomInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRoomInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRoomInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRoomOutputError>
}

public struct DeleteRoomInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRoomInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRoomInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRoomInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRoomOutputError>
}

public struct DeleteRoomInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRoomInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteRoomInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRoomInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRoomOutputError>
}

public struct DeleteRoomInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRoomInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteRoomInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let roomId = input.roomId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("roomId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRoomInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRoomOutputError>
}

public struct DeleteRoomInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The chat room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.roomId = roomId
    }
}

struct DeleteRoomInputBody: Swift.Equatable {
}

extension DeleteRoomInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRoomMembershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRoomMembershipInput(accountId: \(Swift.String(describing: accountId)), memberId: \(Swift.String(describing: memberId)), roomId: \(Swift.String(describing: roomId)))"}
}

extension DeleteRoomMembershipInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteRoomMembershipInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRoomMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRoomMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRoomMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRoomMembershipOutputError>
}

public struct DeleteRoomMembershipInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRoomMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRoomMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRoomMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRoomMembershipOutputError>
}

public struct DeleteRoomMembershipInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRoomMembershipInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteRoomMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRoomMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRoomMembershipOutputError>
}

public struct DeleteRoomMembershipInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRoomMembershipInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteRoomMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let roomId = input.roomId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("roomId is nil and needs a value for the path of this operation"))))
        }
        guard let memberId = input.memberId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("memberId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/memberships/\(memberId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRoomMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRoomMembershipOutputError>
}

public struct DeleteRoomMembershipInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The member ID (user ID or bot ID).
    /// This member is required.
    public var memberId: Swift.String?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.memberId = memberId
        self.roomId = roomId
    }
}

struct DeleteRoomMembershipInputBody: Swift.Equatable {
}

extension DeleteRoomMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRoomMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRoomMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRoomMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRoomMembershipOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRoomMembershipOutputResponse()"}
}

extension DeleteRoomMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRoomMembershipOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRoomMembershipOutputResponseBody: Swift.Equatable {
}

extension DeleteRoomMembershipOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRoomOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRoomOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRoomOutputResponse()"}
}

extension DeleteRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRoomOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRoomOutputResponseBody: Swift.Equatable {
}

extension DeleteRoomOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSipMediaApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSipMediaApplicationInput(sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)))"}
}

extension DeleteSipMediaApplicationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteSipMediaApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSipMediaApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSipMediaApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSipMediaApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSipMediaApplicationOutputError>
}

public struct DeleteSipMediaApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSipMediaApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSipMediaApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSipMediaApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSipMediaApplicationOutputError>
}

public struct DeleteSipMediaApplicationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSipMediaApplicationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteSipMediaApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSipMediaApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSipMediaApplicationOutputError>
}

public struct DeleteSipMediaApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSipMediaApplicationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteSipMediaApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sipMediaApplicationId = input.sipMediaApplicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sipMediaApplicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSipMediaApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSipMediaApplicationOutputError>
}

public struct DeleteSipMediaApplicationInput: Swift.Equatable {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init (
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct DeleteSipMediaApplicationInputBody: Swift.Equatable {
}

extension DeleteSipMediaApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSipMediaApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSipMediaApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSipMediaApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSipMediaApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSipMediaApplicationOutputResponse()"}
}

extension DeleteSipMediaApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSipMediaApplicationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteSipMediaApplicationOutputResponseBody: Swift.Equatable {
}

extension DeleteSipMediaApplicationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSipRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSipRuleInput(sipRuleId: \(Swift.String(describing: sipRuleId)))"}
}

extension DeleteSipRuleInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteSipRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSipRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSipRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSipRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSipRuleOutputError>
}

public struct DeleteSipRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSipRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSipRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSipRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSipRuleOutputError>
}

public struct DeleteSipRuleInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSipRuleInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteSipRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSipRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSipRuleOutputError>
}

public struct DeleteSipRuleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSipRuleInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteSipRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sipRuleId = input.sipRuleId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sipRuleId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sip-rules/\(sipRuleId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSipRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSipRuleOutputError>
}

public struct DeleteSipRuleInput: Swift.Equatable {
    /// The SIP rule ID.
    /// This member is required.
    public var sipRuleId: Swift.String?

    public init (
        sipRuleId: Swift.String? = nil
    )
    {
        self.sipRuleId = sipRuleId
    }
}

struct DeleteSipRuleInputBody: Swift.Equatable {
}

extension DeleteSipRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSipRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSipRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSipRuleOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSipRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSipRuleOutputResponse()"}
}

extension DeleteSipRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSipRuleOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteSipRuleOutputResponseBody: Swift.Equatable {
}

extension DeleteSipRuleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorEmergencyCallingConfigurationInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorEmergencyCallingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorEmergencyCallingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorEmergencyCallingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorEmergencyCallingConfigurationOutputError>
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorEmergencyCallingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorEmergencyCallingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorEmergencyCallingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorEmergencyCallingConfigurationOutputError>
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorEmergencyCallingConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorEmergencyCallingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorEmergencyCallingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorEmergencyCallingConfigurationOutputError>
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorEmergencyCallingConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorEmergencyCallingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorEmergencyCallingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorEmergencyCallingConfigurationOutputError>
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVoiceConnectorEmergencyCallingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse()"}
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponseBody: Swift.Equatable {
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorGroupInput(voiceConnectorGroupId: \(Swift.String(describing: voiceConnectorGroupId)))"}
}

extension DeleteVoiceConnectorGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteVoiceConnectorGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorGroupOutputError>
}

public struct DeleteVoiceConnectorGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorGroupOutputError>
}

public struct DeleteVoiceConnectorGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorGroupOutputError>
}

public struct DeleteVoiceConnectorGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorGroupId = input.voiceConnectorGroupId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorGroupId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorGroupOutputError>
}

public struct DeleteVoiceConnectorGroupInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init (
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct DeleteVoiceConnectorGroupInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVoiceConnectorGroupOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorGroupOutputResponse()"}
}

extension DeleteVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteVoiceConnectorGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension DeleteVoiceConnectorInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteVoiceConnectorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorOutputError>
}

public struct DeleteVoiceConnectorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorOutputError>
}

public struct DeleteVoiceConnectorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorOutputError>
}

public struct DeleteVoiceConnectorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorOutputError>
}

public struct DeleteVoiceConnectorInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorOriginationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorOriginationInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension DeleteVoiceConnectorOriginationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteVoiceConnectorOriginationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorOriginationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorOriginationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorOriginationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorOriginationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorOriginationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorOriginationOutputError>
}

public struct DeleteVoiceConnectorOriginationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorOriginationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorOriginationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorOriginationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorOriginationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorOriginationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorOriginationOutputError>
}

public struct DeleteVoiceConnectorOriginationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorOriginationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorOriginationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorOriginationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorOriginationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorOriginationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorOriginationOutputError>
}

public struct DeleteVoiceConnectorOriginationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorOriginationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorOriginationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorOriginationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorOriginationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorOriginationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorOriginationOutputError>
}

public struct DeleteVoiceConnectorOriginationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorOriginationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorOriginationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorOriginationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorOriginationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVoiceConnectorOriginationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorOriginationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorOriginationOutputResponse()"}
}

extension DeleteVoiceConnectorOriginationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorOriginationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteVoiceConnectorOriginationOutputResponseBody: Swift.Equatable {
}

extension DeleteVoiceConnectorOriginationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVoiceConnectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorOutputResponse()"}
}

extension DeleteVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteVoiceConnectorOutputResponseBody: Swift.Equatable {
}

extension DeleteVoiceConnectorOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorProxyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorProxyInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension DeleteVoiceConnectorProxyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteVoiceConnectorProxyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorProxyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorProxyOutputError>
}

public struct DeleteVoiceConnectorProxyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorProxyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorProxyOutputError>
}

public struct DeleteVoiceConnectorProxyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorProxyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorProxyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorProxyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorProxyOutputError>
}

public struct DeleteVoiceConnectorProxyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorProxyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorProxyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorProxyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorProxyOutputError>
}

public struct DeleteVoiceConnectorProxyInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorProxyInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorProxyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorProxyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorProxyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVoiceConnectorProxyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorProxyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorProxyOutputResponse()"}
}

extension DeleteVoiceConnectorProxyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorProxyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteVoiceConnectorProxyOutputResponseBody: Swift.Equatable {
}

extension DeleteVoiceConnectorProxyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorStreamingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorStreamingConfigurationInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension DeleteVoiceConnectorStreamingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteVoiceConnectorStreamingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorStreamingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorStreamingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorStreamingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorStreamingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorStreamingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorStreamingConfigurationOutputError>
}

public struct DeleteVoiceConnectorStreamingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorStreamingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorStreamingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorStreamingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorStreamingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorStreamingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorStreamingConfigurationOutputError>
}

public struct DeleteVoiceConnectorStreamingConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorStreamingConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorStreamingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorStreamingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorStreamingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorStreamingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorStreamingConfigurationOutputError>
}

public struct DeleteVoiceConnectorStreamingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorStreamingConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorStreamingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorStreamingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorStreamingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorStreamingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorStreamingConfigurationOutputError>
}

public struct DeleteVoiceConnectorStreamingConfigurationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorStreamingConfigurationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorStreamingConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorStreamingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorStreamingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVoiceConnectorStreamingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorStreamingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorStreamingConfigurationOutputResponse()"}
}

extension DeleteVoiceConnectorStreamingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorStreamingConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteVoiceConnectorStreamingConfigurationOutputResponseBody: Swift.Equatable {
}

extension DeleteVoiceConnectorStreamingConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteVoiceConnectorTerminationCredentialsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorTerminationCredentialsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorTerminationCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorTerminationCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorTerminationCredentialsOutputError>
}

extension DeleteVoiceConnectorTerminationCredentialsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorTerminationCredentialsInput(usernames: \(Swift.String(describing: usernames)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension DeleteVoiceConnectorTerminationCredentialsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usernames = "Usernames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let usernames = usernames {
            var usernamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usernames)
            for sensitivestringlist0 in usernames {
                try usernamesContainer.encode(sensitivestringlist0)
            }
        }
    }
}

public struct DeleteVoiceConnectorTerminationCredentialsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorTerminationCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorTerminationCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorTerminationCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorTerminationCredentialsOutputError>
}

public struct DeleteVoiceConnectorTerminationCredentialsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorTerminationCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorTerminationCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "delete"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorTerminationCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorTerminationCredentialsOutputError>
}

public struct DeleteVoiceConnectorTerminationCredentialsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorTerminationCredentialsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorTerminationCredentialsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorTerminationCredentialsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorTerminationCredentialsOutputError>
}

public struct DeleteVoiceConnectorTerminationCredentialsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorTerminationCredentialsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorTerminationCredentialsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorTerminationCredentialsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorTerminationCredentialsOutputError>
}

public struct DeleteVoiceConnectorTerminationCredentialsInput: Swift.Equatable {
    /// The RFC2617 compliant username associated with the SIP credentials, in US-ASCII format.
    /// This member is required.
    public var usernames: [Swift.String]?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        usernames: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.usernames = usernames
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorTerminationCredentialsInputBody: Swift.Equatable {
    public let usernames: [Swift.String]?
}

extension DeleteVoiceConnectorTerminationCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usernames = "Usernames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usernames)
        var usernamesDecoded0:[Swift.String]? = nil
        if let usernamesContainer = usernamesContainer {
            usernamesDecoded0 = [Swift.String]()
            for string0 in usernamesContainer {
                if let string0 = string0 {
                    usernamesDecoded0?.append(string0)
                }
            }
        }
        usernames = usernamesDecoded0
    }
}

extension DeleteVoiceConnectorTerminationCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorTerminationCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVoiceConnectorTerminationCredentialsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorTerminationCredentialsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorTerminationCredentialsOutputResponse()"}
}

extension DeleteVoiceConnectorTerminationCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorTerminationCredentialsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteVoiceConnectorTerminationCredentialsOutputResponseBody: Swift.Equatable {
}

extension DeleteVoiceConnectorTerminationCredentialsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorTerminationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorTerminationInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension DeleteVoiceConnectorTerminationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteVoiceConnectorTerminationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorTerminationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorTerminationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorTerminationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorTerminationOutputError>
}

public struct DeleteVoiceConnectorTerminationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorTerminationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVoiceConnectorTerminationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVoiceConnectorTerminationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorTerminationOutputError>
}

public struct DeleteVoiceConnectorTerminationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorTerminationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorTerminationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorTerminationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorTerminationOutputError>
}

public struct DeleteVoiceConnectorTerminationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVoiceConnectorTerminationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteVoiceConnectorTerminationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteVoiceConnectorTerminationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVoiceConnectorTerminationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVoiceConnectorTerminationOutputError>
}

public struct DeleteVoiceConnectorTerminationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorTerminationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorTerminationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorTerminationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorTerminationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVoiceConnectorTerminationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorTerminationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorTerminationOutputResponse()"}
}

extension DeleteVoiceConnectorTerminationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorTerminationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteVoiceConnectorTerminationOutputResponseBody: Swift.Equatable {
}

extension DeleteVoiceConnectorTerminationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceAdminInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppInstanceAdminInput(appInstanceAdminArn: \(Swift.String(describing: appInstanceAdminArn)), appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension DescribeAppInstanceAdminInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAppInstanceAdminInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceAdminInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInstanceAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInstanceAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceAdminOutputError>
}

public struct DescribeAppInstanceAdminInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceAdminInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInstanceAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInstanceAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceAdminOutputError>
}

public struct DescribeAppInstanceAdminInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceAdminInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInstanceAdminInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInstanceAdminInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceAdminOutputError>
}

public struct DescribeAppInstanceAdminInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceAdminInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInstanceAdminInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        guard let appInstanceAdminArn = input.appInstanceAdminArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceAdminArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins/\(appInstanceAdminArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInstanceAdminInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceAdminOutputError>
}

public struct DescribeAppInstanceAdminInput: Swift.Equatable {
    /// The ARN of the AppInstanceAdmin.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

struct DescribeAppInstanceAdminInputBody: Swift.Equatable {
}

extension DescribeAppInstanceAdminInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceAdminOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppInstanceAdminOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppInstanceAdminOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppInstanceAdminOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppInstanceAdminOutputResponse(appInstanceAdmin: \(Swift.String(describing: appInstanceAdmin)))"}
}

extension DescribeAppInstanceAdminOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppInstanceAdminOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceAdmin = output.appInstanceAdmin
        } else {
            self.appInstanceAdmin = nil
        }
    }
}

public struct DescribeAppInstanceAdminOutputResponse: Swift.Equatable {
    /// The ARN and name of the AppInstanceUser, the ARN of the AppInstance, and the created and
    ///             last-updated timestamps. All timestamps use epoch milliseconds.
    public var appInstanceAdmin: ChimeClientTypes.AppInstanceAdmin?

    public init (
        appInstanceAdmin: ChimeClientTypes.AppInstanceAdmin? = nil
    )
    {
        self.appInstanceAdmin = appInstanceAdmin
    }
}

struct DescribeAppInstanceAdminOutputResponseBody: Swift.Equatable {
    public let appInstanceAdmin: ChimeClientTypes.AppInstanceAdmin?
}

extension DescribeAppInstanceAdminOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdmin = "AppInstanceAdmin"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceAdminDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstanceAdmin.self, forKey: .appInstanceAdmin)
        appInstanceAdmin = appInstanceAdminDecoded
    }
}

extension DescribeAppInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppInstanceInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension DescribeAppInstanceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAppInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceOutputError>
}

public struct DescribeAppInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceOutputError>
}

public struct DescribeAppInstanceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceOutputError>
}

public struct DescribeAppInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceOutputError>
}

public struct DescribeAppInstanceInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct DescribeAppInstanceInputBody: Swift.Equatable {
}

extension DescribeAppInstanceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppInstanceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppInstanceOutputResponse(appInstance: \(Swift.String(describing: appInstance)))"}
}

extension DescribeAppInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstance = output.appInstance
        } else {
            self.appInstance = nil
        }
    }
}

public struct DescribeAppInstanceOutputResponse: Swift.Equatable {
    /// The ARN, metadata, created and last-updated timestamps, and the name of the AppInstance. All
    ///             timestamps use epoch milliseconds.
    public var appInstance: ChimeClientTypes.AppInstance?

    public init (
        appInstance: ChimeClientTypes.AppInstance? = nil
    )
    {
        self.appInstance = appInstance
    }
}

struct DescribeAppInstanceOutputResponseBody: Swift.Equatable {
    public let appInstance: ChimeClientTypes.AppInstance?
}

extension DescribeAppInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstance = "AppInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstance.self, forKey: .appInstance)
        appInstance = appInstanceDecoded
    }
}

extension DescribeAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)))"}
}

extension DescribeAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceUserOutputError>
}

public struct DescribeAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceUserOutputError>
}

public struct DescribeAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceUserOutputError>
}

public struct DescribeAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceUserArn = input.appInstanceUserArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceUserArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAppInstanceUserOutputError>
}

public struct DescribeAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct DescribeAppInstanceUserInputBody: Swift.Equatable {
}

extension DescribeAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAppInstanceUserOutputResponse(appInstanceUser: \(Swift.String(describing: appInstanceUser)))"}
}

extension DescribeAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUser = output.appInstanceUser
        } else {
            self.appInstanceUser = nil
        }
    }
}

public struct DescribeAppInstanceUserOutputResponse: Swift.Equatable {
    /// The name of the AppInstanceUser.
    public var appInstanceUser: ChimeClientTypes.AppInstanceUser?

    public init (
        appInstanceUser: ChimeClientTypes.AppInstanceUser? = nil
    )
    {
        self.appInstanceUser = appInstanceUser
    }
}

struct DescribeAppInstanceUserOutputResponseBody: Swift.Equatable {
    public let appInstanceUser: ChimeClientTypes.AppInstanceUser?
}

extension DescribeAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUser = "AppInstanceUser"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstanceUser.self, forKey: .appInstanceUser)
        appInstanceUser = appInstanceUserDecoded
    }
}

extension DescribeChannelBanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelBanInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), memberArn: \(Swift.String(describing: memberArn)))"}
}

extension DescribeChannelBanInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeChannelBanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelBanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelBanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelBanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelBanOutputError>
}

public struct DescribeChannelBanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelBanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelBanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelBanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelBanOutputError>
}

public struct DescribeChannelBanInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelBanInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelBanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelBanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelBanOutputError>
}

public struct DescribeChannelBanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelBanInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelBanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let memberArn = input.memberArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("memberArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/bans/\(memberArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelBanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelBanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelBanOutputError>
}

public struct DescribeChannelBanInput: Swift.Equatable {
    /// The ARN of the channel from which the user is banned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the member being banned.
    /// This member is required.
    public var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct DescribeChannelBanInputBody: Swift.Equatable {
}

extension DescribeChannelBanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelBanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelBanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelBanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelBanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelBanOutputResponse(channelBan: \(Swift.String(describing: channelBan)))"}
}

extension DescribeChannelBanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelBanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelBan = output.channelBan
        } else {
            self.channelBan = nil
        }
    }
}

public struct DescribeChannelBanOutputResponse: Swift.Equatable {
    /// The details of the ban.
    public var channelBan: ChimeClientTypes.ChannelBan?

    public init (
        channelBan: ChimeClientTypes.ChannelBan? = nil
    )
    {
        self.channelBan = channelBan
    }
}

struct DescribeChannelBanOutputResponseBody: Swift.Equatable {
    public let channelBan: ChimeClientTypes.ChannelBan?
}

extension DescribeChannelBanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelBan = "ChannelBan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelBanDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelBan.self, forKey: .channelBan)
        channelBan = channelBanDecoded
    }
}

extension DescribeChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension DescribeChannelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelInputBody: Swift.Equatable {
}

extension DescribeChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelMembershipForAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension DescribeChannelMembershipForAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeChannelMembershipForAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipForAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelMembershipForAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelMembershipForAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipForAppInstanceUserOutputError>
}

public struct DescribeChannelMembershipForAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipForAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelMembershipForAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-membership"))
        if let appInstanceUserArn = input.operationInput.appInstanceUserArn {
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            input.builder.withQueryItem(appInstanceUserArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelMembershipForAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipForAppInstanceUserOutputError>
}

public struct DescribeChannelMembershipForAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipForAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelMembershipForAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelMembershipForAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipForAppInstanceUserOutputError>
}

public struct DescribeChannelMembershipForAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipForAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelMembershipForAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelMembershipForAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipForAppInstanceUserOutputError>
}

public struct DescribeChannelMembershipForAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the user in a channel.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The ARN of the channel to which the user belongs.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelMembershipForAppInstanceUserInputBody: Swift.Equatable {
}

extension DescribeChannelMembershipForAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelMembershipForAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelMembershipForAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelMembershipForAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelMembershipForAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelMembershipForAppInstanceUserOutputResponse(channelMembership: \(Swift.String(describing: channelMembership)))"}
}

extension DescribeChannelMembershipForAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelMembershipForAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMembership = output.channelMembership
        } else {
            self.channelMembership = nil
        }
    }
}

public struct DescribeChannelMembershipForAppInstanceUserOutputResponse: Swift.Equatable {
    /// The channel to which a user belongs.
    public var channelMembership: ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary?

    public init (
        channelMembership: ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary? = nil
    )
    {
        self.channelMembership = channelMembership
    }
}

struct DescribeChannelMembershipForAppInstanceUserOutputResponseBody: Swift.Equatable {
    public let channelMembership: ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary?
}

extension DescribeChannelMembershipForAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMembership = "ChannelMembership"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMembershipDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary.self, forKey: .channelMembership)
        channelMembership = channelMembershipDecoded
    }
}

extension DescribeChannelMembershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelMembershipInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), memberArn: \(Swift.String(describing: memberArn)))"}
}

extension DescribeChannelMembershipInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeChannelMembershipInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipOutputError>
}

public struct DescribeChannelMembershipInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipOutputError>
}

public struct DescribeChannelMembershipInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipOutputError>
}

public struct DescribeChannelMembershipInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelMembershipInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let memberArn = input.memberArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("memberArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelMembershipOutputError>
}

public struct DescribeChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the member.
    /// This member is required.
    public var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct DescribeChannelMembershipInputBody: Swift.Equatable {
}

extension DescribeChannelMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelMembershipOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelMembershipOutputResponse(channelMembership: \(Swift.String(describing: channelMembership)))"}
}

extension DescribeChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMembership = output.channelMembership
        } else {
            self.channelMembership = nil
        }
    }
}

public struct DescribeChannelMembershipOutputResponse: Swift.Equatable {
    /// The details of the membership.
    public var channelMembership: ChimeClientTypes.ChannelMembership?

    public init (
        channelMembership: ChimeClientTypes.ChannelMembership? = nil
    )
    {
        self.channelMembership = channelMembership
    }
}

struct DescribeChannelMembershipOutputResponseBody: Swift.Equatable {
    public let channelMembership: ChimeClientTypes.ChannelMembership?
}

extension DescribeChannelMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMembership = "ChannelMembership"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMembershipDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMembership.self, forKey: .channelMembership)
        channelMembership = channelMembershipDecoded
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelModeratedByAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension DescribeChannelModeratedByAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeChannelModeratedByAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratedByAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelModeratedByAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelModeratedByAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratedByAppInstanceUserOutputError>
}

public struct DescribeChannelModeratedByAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratedByAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelModeratedByAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-moderated-channel"))
        if let appInstanceUserArn = input.operationInput.appInstanceUserArn {
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            input.builder.withQueryItem(appInstanceUserArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelModeratedByAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratedByAppInstanceUserOutputError>
}

public struct DescribeChannelModeratedByAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratedByAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelModeratedByAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelModeratedByAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratedByAppInstanceUserOutputError>
}

public struct DescribeChannelModeratedByAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratedByAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelModeratedByAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelModeratedByAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratedByAppInstanceUserOutputError>
}

public struct DescribeChannelModeratedByAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser in the moderated channel.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The ARN of the moderated channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelModeratedByAppInstanceUserInputBody: Swift.Equatable {
}

extension DescribeChannelModeratedByAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelModeratedByAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelModeratedByAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelModeratedByAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelModeratedByAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelModeratedByAppInstanceUserOutputResponse(channel: \(Swift.String(describing: channel)))"}
}

extension DescribeChannelModeratedByAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelModeratedByAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct DescribeChannelModeratedByAppInstanceUserOutputResponse: Swift.Equatable {
    /// The moderated channel.
    public var channel: ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary?

    public init (
        channel: ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary? = nil
    )
    {
        self.channel = channel
    }
}

struct DescribeChannelModeratedByAppInstanceUserOutputResponseBody: Swift.Equatable {
    public let channel: ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary?
}

extension DescribeChannelModeratedByAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension DescribeChannelModeratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelModeratorInput(channelArn: \(Swift.String(describing: channelArn)), channelModeratorArn: \(Swift.String(describing: channelModeratorArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension DescribeChannelModeratorInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeChannelModeratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelModeratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelModeratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratorOutputError>
}

public struct DescribeChannelModeratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelModeratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelModeratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratorOutputError>
}

public struct DescribeChannelModeratorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelModeratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelModeratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratorOutputError>
}

public struct DescribeChannelModeratorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelModeratorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeChannelModeratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let channelModeratorArn = input.channelModeratorArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelModeratorArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/moderators/\(channelModeratorArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelModeratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelModeratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelModeratorOutputError>
}

public struct DescribeChannelModeratorInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the channel moderator.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelModeratorInputBody: Swift.Equatable {
}

extension DescribeChannelModeratorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelModeratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelModeratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelModeratorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelModeratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelModeratorOutputResponse(channelModerator: \(Swift.String(describing: channelModerator)))"}
}

extension DescribeChannelModeratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelModeratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelModerator = output.channelModerator
        } else {
            self.channelModerator = nil
        }
    }
}

public struct DescribeChannelModeratorOutputResponse: Swift.Equatable {
    /// The details of the channel moderator.
    public var channelModerator: ChimeClientTypes.ChannelModerator?

    public init (
        channelModerator: ChimeClientTypes.ChannelModerator? = nil
    )
    {
        self.channelModerator = channelModerator
    }
}

struct DescribeChannelModeratorOutputResponseBody: Swift.Equatable {
    public let channelModerator: ChimeClientTypes.ChannelModerator?
}

extension DescribeChannelModeratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelModerator = "ChannelModerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelModeratorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelModerator.self, forKey: .channelModerator)
        channelModerator = channelModeratorDecoded
    }
}

extension DescribeChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelOutputResponse(channel: \(Swift.String(describing: channel)))"}
}

extension DescribeChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct DescribeChannelOutputResponse: Swift.Equatable {
    /// The channel details.
    public var channel: ChimeClientTypes.Channel?

    public init (
        channel: ChimeClientTypes.Channel? = nil
    )
    {
        self.channel = channel
    }
}

struct DescribeChannelOutputResponseBody: Swift.Equatable {
    public let channel: ChimeClientTypes.Channel?
}

extension DescribeChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension DisassociatePhoneNumberFromUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociatePhoneNumberFromUserInput(accountId: \(Swift.String(describing: accountId)), userId: \(Swift.String(describing: userId)))"}
}

extension DisassociatePhoneNumberFromUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociatePhoneNumberFromUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePhoneNumberFromUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociatePhoneNumberFromUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePhoneNumberFromUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociatePhoneNumberFromUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePhoneNumberFromUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePhoneNumberFromUserOutputError>
}

public struct DisassociatePhoneNumberFromUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePhoneNumberFromUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociatePhoneNumberFromUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePhoneNumberFromUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "disassociate-phone-number"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociatePhoneNumberFromUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePhoneNumberFromUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePhoneNumberFromUserOutputError>
}

public struct DisassociatePhoneNumberFromUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePhoneNumberFromUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociatePhoneNumberFromUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePhoneNumberFromUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociatePhoneNumberFromUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePhoneNumberFromUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePhoneNumberFromUserOutputError>
}

public struct DisassociatePhoneNumberFromUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePhoneNumberFromUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociatePhoneNumberFromUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePhoneNumberFromUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let userId = input.userId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("userId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociatePhoneNumberFromUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePhoneNumberFromUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePhoneNumberFromUserOutputError>
}

public struct DisassociatePhoneNumberFromUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
    }
}

struct DisassociatePhoneNumberFromUserInputBody: Swift.Equatable {
}

extension DisassociatePhoneNumberFromUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociatePhoneNumberFromUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociatePhoneNumberFromUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociatePhoneNumberFromUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociatePhoneNumberFromUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociatePhoneNumberFromUserOutputResponse()"}
}

extension DisassociatePhoneNumberFromUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociatePhoneNumberFromUserOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociatePhoneNumberFromUserOutputResponseBody: Swift.Equatable {
}

extension DisassociatePhoneNumberFromUserOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePhoneNumbersFromVoiceConnectorGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociatePhoneNumbersFromVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociatePhoneNumbersFromVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePhoneNumbersFromVoiceConnectorGroupOutputError>
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociatePhoneNumbersFromVoiceConnectorGroupInput(e164PhoneNumbers: \(Swift.String(describing: e164PhoneNumbers)), voiceConnectorGroupId: \(Swift.String(describing: voiceConnectorGroupId)))"}
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumberlist0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumberlist0)
            }
        }
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePhoneNumbersFromVoiceConnectorGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociatePhoneNumbersFromVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociatePhoneNumbersFromVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePhoneNumbersFromVoiceConnectorGroupOutputError>
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePhoneNumbersFromVoiceConnectorGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociatePhoneNumbersFromVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "disassociate-phone-numbers"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociatePhoneNumbersFromVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePhoneNumbersFromVoiceConnectorGroupOutputError>
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePhoneNumbersFromVoiceConnectorGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociatePhoneNumbersFromVoiceConnectorGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociatePhoneNumbersFromVoiceConnectorGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePhoneNumbersFromVoiceConnectorGroupOutputError>
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePhoneNumbersFromVoiceConnectorGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociatePhoneNumbersFromVoiceConnectorGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorGroupId = input.voiceConnectorGroupId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorGroupId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociatePhoneNumbersFromVoiceConnectorGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePhoneNumbersFromVoiceConnectorGroupOutputError>
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupInput: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// The Amazon Chime Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init (
        e164PhoneNumbers: [Swift.String]? = nil,
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorGroupInputBody: Swift.Equatable {
    public let e164PhoneNumbers: [Swift.String]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociatePhoneNumbersFromVoiceConnectorGroupOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse(phoneNumberErrors: \(Swift.String(describing: phoneNumberErrors)))"}
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init (
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
    public let phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePhoneNumbersFromVoiceConnectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociatePhoneNumbersFromVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociatePhoneNumbersFromVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePhoneNumbersFromVoiceConnectorOutputError>
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociatePhoneNumbersFromVoiceConnectorInput(e164PhoneNumbers: \(Swift.String(describing: e164PhoneNumbers)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumberlist0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumberlist0)
            }
        }
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePhoneNumbersFromVoiceConnectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociatePhoneNumbersFromVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociatePhoneNumbersFromVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePhoneNumbersFromVoiceConnectorOutputError>
}

public struct DisassociatePhoneNumbersFromVoiceConnectorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePhoneNumbersFromVoiceConnectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociatePhoneNumbersFromVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "disassociate-phone-numbers"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociatePhoneNumbersFromVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePhoneNumbersFromVoiceConnectorOutputError>
}

public struct DisassociatePhoneNumbersFromVoiceConnectorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePhoneNumbersFromVoiceConnectorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociatePhoneNumbersFromVoiceConnectorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociatePhoneNumbersFromVoiceConnectorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePhoneNumbersFromVoiceConnectorOutputError>
}

public struct DisassociatePhoneNumbersFromVoiceConnectorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePhoneNumbersFromVoiceConnectorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociatePhoneNumbersFromVoiceConnectorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociatePhoneNumbersFromVoiceConnectorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePhoneNumbersFromVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePhoneNumbersFromVoiceConnectorOutputError>
}

public struct DisassociatePhoneNumbersFromVoiceConnectorInput: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        e164PhoneNumbers: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorInputBody: Swift.Equatable {
    public let e164PhoneNumbers: [Swift.String]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociatePhoneNumbersFromVoiceConnectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociatePhoneNumbersFromVoiceConnectorOutputResponse(phoneNumberErrors: \(Swift.String(describing: phoneNumberErrors)))"}
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociatePhoneNumbersFromVoiceConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorOutputResponse: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init (
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorOutputResponseBody: Swift.Equatable {
    public let phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

public struct DisassociateSigninDelegateGroupsFromAccountInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateSigninDelegateGroupsFromAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateSigninDelegateGroupsFromAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateSigninDelegateGroupsFromAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateSigninDelegateGroupsFromAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateSigninDelegateGroupsFromAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateSigninDelegateGroupsFromAccountOutputError>
}

extension DisassociateSigninDelegateGroupsFromAccountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateSigninDelegateGroupsFromAccountInput(accountId: \(Swift.String(describing: accountId)), groupNames: \(Swift.String(describing: groupNames)))"}
}

extension DisassociateSigninDelegateGroupsFromAccountInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupNames = "GroupNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupNames = groupNames {
            var groupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupNames)
            for nonemptystringlist0 in groupNames {
                try groupNamesContainer.encode(nonemptystringlist0)
            }
        }
    }
}

public struct DisassociateSigninDelegateGroupsFromAccountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateSigninDelegateGroupsFromAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateSigninDelegateGroupsFromAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateSigninDelegateGroupsFromAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateSigninDelegateGroupsFromAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateSigninDelegateGroupsFromAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateSigninDelegateGroupsFromAccountOutputError>
}

public struct DisassociateSigninDelegateGroupsFromAccountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateSigninDelegateGroupsFromAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateSigninDelegateGroupsFromAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateSigninDelegateGroupsFromAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "disassociate-signin-delegate-groups"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateSigninDelegateGroupsFromAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateSigninDelegateGroupsFromAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateSigninDelegateGroupsFromAccountOutputError>
}

public struct DisassociateSigninDelegateGroupsFromAccountInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateSigninDelegateGroupsFromAccountInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateSigninDelegateGroupsFromAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateSigninDelegateGroupsFromAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateSigninDelegateGroupsFromAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateSigninDelegateGroupsFromAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateSigninDelegateGroupsFromAccountOutputError>
}

public struct DisassociateSigninDelegateGroupsFromAccountInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateSigninDelegateGroupsFromAccountInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateSigninDelegateGroupsFromAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateSigninDelegateGroupsFromAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateSigninDelegateGroupsFromAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateSigninDelegateGroupsFromAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateSigninDelegateGroupsFromAccountOutputError>
}

public struct DisassociateSigninDelegateGroupsFromAccountInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The sign-in delegate group names.
    /// This member is required.
    public var groupNames: [Swift.String]?

    public init (
        accountId: Swift.String? = nil,
        groupNames: [Swift.String]? = nil
    )
    {
        self.accountId = accountId
        self.groupNames = groupNames
    }
}

struct DisassociateSigninDelegateGroupsFromAccountInputBody: Swift.Equatable {
    public let groupNames: [Swift.String]?
}

extension DisassociateSigninDelegateGroupsFromAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupNames = "GroupNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupNames)
        var groupNamesDecoded0:[Swift.String]? = nil
        if let groupNamesContainer = groupNamesContainer {
            groupNamesDecoded0 = [Swift.String]()
            for string0 in groupNamesContainer {
                if let string0 = string0 {
                    groupNamesDecoded0?.append(string0)
                }
            }
        }
        groupNames = groupNamesDecoded0
    }
}

extension DisassociateSigninDelegateGroupsFromAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateSigninDelegateGroupsFromAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateSigninDelegateGroupsFromAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateSigninDelegateGroupsFromAccountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateSigninDelegateGroupsFromAccountOutputResponse()"}
}

extension DisassociateSigninDelegateGroupsFromAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateSigninDelegateGroupsFromAccountOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateSigninDelegateGroupsFromAccountOutputResponseBody: Swift.Equatable {
}

extension DisassociateSigninDelegateGroupsFromAccountOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ChimeClientTypes {
    public enum EmailStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case notsent
        case sent
        case sdkUnknown(Swift.String)

        public static var allCases: [EmailStatus] {
            return [
                .failed,
                .notsent,
                .sent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .notsent: return "NotSent"
            case .sent: return "Sent"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EmailStatus(rawValue: rawValue) ?? EmailStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.EmergencyCallingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dNIS = "DNIS"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dNIS = dNIS {
            var dNISContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dNIS)
            for dnisemergencycallingconfigurationlist0 in dNIS {
                try dNISContainer.encode(dnisemergencycallingconfigurationlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dNISContainer = try containerValues.decodeIfPresent([ChimeClientTypes.DNISEmergencyCallingConfiguration?].self, forKey: .dNIS)
        var dNISDecoded0:[ChimeClientTypes.DNISEmergencyCallingConfiguration]? = nil
        if let dNISContainer = dNISContainer {
            dNISDecoded0 = [ChimeClientTypes.DNISEmergencyCallingConfiguration]()
            for structure0 in dNISContainer {
                if let structure0 = structure0 {
                    dNISDecoded0?.append(structure0)
                }
            }
        }
        dNIS = dNISDecoded0
    }
}

extension ChimeClientTypes.EmergencyCallingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EmergencyCallingConfiguration(dNIS: \(Swift.String(describing: dNIS)))"}
}

extension ChimeClientTypes {
    /// The emergency calling configuration details associated with an Amazon Chime Voice Connector.
    public struct EmergencyCallingConfiguration: Swift.Equatable {
        /// The Dialed Number Identification Service (DNIS) emergency calling configuration details.
        public var dNIS: [ChimeClientTypes.DNISEmergencyCallingConfiguration]?

        public init (
            dNIS: [ChimeClientTypes.DNISEmergencyCallingConfiguration]? = nil
        )
        {
            self.dNIS = dNIS
        }
    }

}

extension ChimeClientTypes.EngineTranscribeMedicalSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case region = "Region"
        case specialty = "Specialty"
        case type = "Type"
        case vocabularyName = "VocabularyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let region = region {
            try encodeContainer.encode(region.rawValue, forKey: .region)
        }
        if let specialty = specialty {
            try encodeContainer.encode(specialty.rawValue, forKey: .specialty)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vocabularyName = vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeMedicalLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let specialtyDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeMedicalSpecialty.self, forKey: .specialty)
        specialty = specialtyDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeMedicalType.self, forKey: .type)
        type = typeDecoded
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeMedicalRegion.self, forKey: .region)
        region = regionDecoded
    }
}

extension ChimeClientTypes.EngineTranscribeMedicalSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EngineTranscribeMedicalSettings(languageCode: \(Swift.String(describing: languageCode)), region: \(Swift.String(describing: region)), specialty: \(Swift.String(describing: specialty)), type: \(Swift.String(describing: type)), vocabularyName: \(Swift.String(describing: vocabularyName)))"}
}

extension ChimeClientTypes {
    /// Settings specific to the Amazon Transcribe Medical engine.
    public struct EngineTranscribeMedicalSettings: Swift.Equatable {
        /// The language code specified for the Amazon Transcribe Medical engine.
        /// This member is required.
        public var languageCode: ChimeClientTypes.TranscribeMedicalLanguageCode?
        /// The AWS Region passed to Amazon Transcribe Medical. If you don't specify a Region, Amazon Chime uses the meeting's Region.
        public var region: ChimeClientTypes.TranscribeMedicalRegion?
        /// The specialty specified for the Amazon Transcribe Medical engine.
        /// This member is required.
        public var specialty: ChimeClientTypes.TranscribeMedicalSpecialty?
        /// The type of transcription.
        /// This member is required.
        public var type: ChimeClientTypes.TranscribeMedicalType?
        /// The name of the vocabulary passed to Amazon Transcribe Medical.
        public var vocabularyName: Swift.String?

        public init (
            languageCode: ChimeClientTypes.TranscribeMedicalLanguageCode? = nil,
            region: ChimeClientTypes.TranscribeMedicalRegion? = nil,
            specialty: ChimeClientTypes.TranscribeMedicalSpecialty? = nil,
            type: ChimeClientTypes.TranscribeMedicalType? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.languageCode = languageCode
            self.region = region
            self.specialty = specialty
            self.type = type
            self.vocabularyName = vocabularyName
        }
    }

}

extension ChimeClientTypes.EngineTranscribeSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case region = "Region"
        case vocabularyFilterMethod = "VocabularyFilterMethod"
        case vocabularyFilterName = "VocabularyFilterName"
        case vocabularyName = "VocabularyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let region = region {
            try encodeContainer.encode(region.rawValue, forKey: .region)
        }
        if let vocabularyFilterMethod = vocabularyFilterMethod {
            try encodeContainer.encode(vocabularyFilterMethod.rawValue, forKey: .vocabularyFilterMethod)
        }
        if let vocabularyFilterName = vocabularyFilterName {
            try encodeContainer.encode(vocabularyFilterName, forKey: .vocabularyFilterName)
        }
        if let vocabularyName = vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let vocabularyFilterMethodDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeVocabularyFilterMethod.self, forKey: .vocabularyFilterMethod)
        vocabularyFilterMethod = vocabularyFilterMethodDecoded
        let vocabularyFilterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterName)
        vocabularyFilterName = vocabularyFilterNameDecoded
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeRegion.self, forKey: .region)
        region = regionDecoded
    }
}

extension ChimeClientTypes.EngineTranscribeSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EngineTranscribeSettings(languageCode: \(Swift.String(describing: languageCode)), region: \(Swift.String(describing: region)), vocabularyFilterMethod: \(Swift.String(describing: vocabularyFilterMethod)), vocabularyFilterName: \(Swift.String(describing: vocabularyFilterName)), vocabularyName: \(Swift.String(describing: vocabularyName)))"}
}

extension ChimeClientTypes {
    /// Settings specific to the Amazon Transcribe engine.
    public struct EngineTranscribeSettings: Swift.Equatable {
        /// The language code specified for the Amazon Transcribe engine.
        /// This member is required.
        public var languageCode: ChimeClientTypes.TranscribeLanguageCode?
        /// The AWS Region passed to Amazon Transcribe. If you don't specify a Region, Amazon Chime uses the meeting's Region.
        public var region: ChimeClientTypes.TranscribeRegion?
        /// The filtering method passed to Amazon Transcribe.
        public var vocabularyFilterMethod: ChimeClientTypes.TranscribeVocabularyFilterMethod?
        /// The name of the vocabulary filter passed to Amazon Transcribe.
        public var vocabularyFilterName: Swift.String?
        /// The name of the vocabulary passed to Amazon Transcribe.
        public var vocabularyName: Swift.String?

        public init (
            languageCode: ChimeClientTypes.TranscribeLanguageCode? = nil,
            region: ChimeClientTypes.TranscribeRegion? = nil,
            vocabularyFilterMethod: ChimeClientTypes.TranscribeVocabularyFilterMethod? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.languageCode = languageCode
            self.region = region
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyName = vocabularyName
        }
    }

}

extension ChimeClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case badrequest
        case conflict
        case forbidden
        case notfound
        case phonenumberassociationsexist
        case preconditionfailed
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttled
        case throttling
        case unauthorized
        case unprocessable
        case voiceconnectorgroupassociationsexist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessdenied,
                .badrequest,
                .conflict,
                .forbidden,
                .notfound,
                .phonenumberassociationsexist,
                .preconditionfailed,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttled,
                .throttling,
                .unauthorized,
                .unprocessable,
                .voiceconnectorgroupassociationsexist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .badrequest: return "BadRequest"
            case .conflict: return "Conflict"
            case .forbidden: return "Forbidden"
            case .notfound: return "NotFound"
            case .phonenumberassociationsexist: return "PhoneNumberAssociationsExist"
            case .preconditionfailed: return "PreconditionFailed"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttled: return "Throttled"
            case .throttling: return "Throttling"
            case .unauthorized: return "Unauthorized"
            case .unprocessable: return "Unprocessable"
            case .voiceconnectorgroupassociationsexist: return "VoiceConnectorGroupAssociationsExist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.EventsConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId = "BotId"
        case lambdaFunctionArn = "LambdaFunctionArn"
        case outboundEventsHTTPSEndpoint = "OutboundEventsHTTPSEndpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let lambdaFunctionArn = lambdaFunctionArn {
            try encodeContainer.encode(lambdaFunctionArn, forKey: .lambdaFunctionArn)
        }
        if let outboundEventsHTTPSEndpoint = outboundEventsHTTPSEndpoint {
            try encodeContainer.encode(outboundEventsHTTPSEndpoint, forKey: .outboundEventsHTTPSEndpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let outboundEventsHTTPSEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundEventsHTTPSEndpoint)
        outboundEventsHTTPSEndpoint = outboundEventsHTTPSEndpointDecoded
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
    }
}

extension ChimeClientTypes.EventsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventsConfiguration(botId: \(Swift.String(describing: botId)), lambdaFunctionArn: \(Swift.String(describing: lambdaFunctionArn)), outboundEventsHTTPSEndpoint: \(Swift.String(describing: outboundEventsHTTPSEndpoint)))"}
}

extension ChimeClientTypes {
    /// The configuration that allows a bot to receive outgoing events. Can be either an HTTPS endpoint or a Lambda function ARN.
    public struct EventsConfiguration: Swift.Equatable {
        /// The bot ID.
        public var botId: Swift.String?
        /// Lambda function ARN that allows a bot to receive outgoing events.
        public var lambdaFunctionArn: Swift.String?
        /// HTTPS endpoint that allows a bot to receive outgoing events.
        public var outboundEventsHTTPSEndpoint: Swift.String?

        public init (
            botId: Swift.String? = nil,
            lambdaFunctionArn: Swift.String? = nil,
            outboundEventsHTTPSEndpoint: Swift.String? = nil
        )
        {
            self.botId = botId
            self.lambdaFunctionArn = lambdaFunctionArn
            self.outboundEventsHTTPSEndpoint = outboundEventsHTTPSEndpoint
        }
    }

}

extension ForbiddenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForbiddenException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    public let code: ChimeClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeClientTypes {
    public enum GeoMatchLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case areacode
        case country
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoMatchLevel] {
            return [
                .areacode,
                .country,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .areacode: return "AreaCode"
            case .country: return "Country"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeoMatchLevel(rawValue: rawValue) ?? GeoMatchLevel.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.GeoMatchParams: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areaCode = "AreaCode"
        case country = "Country"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let areaCode = areaCode {
            try encodeContainer.encode(areaCode, forKey: .areaCode)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let areaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .areaCode)
        areaCode = areaCodeDecoded
    }
}

extension ChimeClientTypes.GeoMatchParams: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeoMatchParams(areaCode: \(Swift.String(describing: areaCode)), country: \(Swift.String(describing: country)))"}
}

extension ChimeClientTypes {
    /// The country and area code for a proxy phone number in a proxy phone session.
    public struct GeoMatchParams: Swift.Equatable {
        /// The area code.
        /// This member is required.
        public var areaCode: Swift.String?
        /// The country.
        /// This member is required.
        public var country: Swift.String?

        public init (
            areaCode: Swift.String? = nil,
            country: Swift.String? = nil
        )
        {
            self.areaCode = areaCode
            self.country = country
        }
    }

}

extension GetAccountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccountInput(accountId: \(Swift.String(describing: accountId)))"}
}

extension GetAccountInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAccountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountOutputError>
}

public struct GetAccountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountOutputError>
}

public struct GetAccountInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountOutputError>
}

public struct GetAccountInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountOutputError>
}

public struct GetAccountInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetAccountInputBody: Swift.Equatable {
}

extension GetAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccountOutputResponse(account: \(Swift.String(describing: account)))"}
}

extension GetAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.account = output.account
        } else {
            self.account = nil
        }
    }
}

public struct GetAccountOutputResponse: Swift.Equatable {
    /// The Amazon Chime account details.
    public var account: ChimeClientTypes.Account?

    public init (
        account: ChimeClientTypes.Account? = nil
    )
    {
        self.account = account
    }
}

struct GetAccountOutputResponseBody: Swift.Equatable {
    public let account: ChimeClientTypes.Account?
}

extension GetAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Account.self, forKey: .account)
        account = accountDecoded
    }
}

extension GetAccountSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccountSettingsInput(accountId: \(Swift.String(describing: accountId)))"}
}

extension GetAccountSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAccountSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccountSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccountSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccountSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccountSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAccountSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccountSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccountSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAccountSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccountSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetAccountSettingsInputBody: Swift.Equatable {
}

extension GetAccountSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccountSettingsOutputResponse(accountSettings: \(Swift.String(describing: accountSettings)))"}
}

extension GetAccountSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountSettings = output.accountSettings
        } else {
            self.accountSettings = nil
        }
    }
}

public struct GetAccountSettingsOutputResponse: Swift.Equatable {
    /// The Amazon Chime account settings.
    public var accountSettings: ChimeClientTypes.AccountSettings?

    public init (
        accountSettings: ChimeClientTypes.AccountSettings? = nil
    )
    {
        self.accountSettings = accountSettings
    }
}

struct GetAccountSettingsOutputResponseBody: Swift.Equatable {
    public let accountSettings: ChimeClientTypes.AccountSettings?
}

extension GetAccountSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings = "AccountSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
    }
}

extension GetAppInstanceRetentionSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAppInstanceRetentionSettingsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension GetAppInstanceRetentionSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAppInstanceRetentionSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppInstanceRetentionSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAppInstanceRetentionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAppInstanceRetentionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppInstanceRetentionSettingsOutputError>
}

public struct GetAppInstanceRetentionSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppInstanceRetentionSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAppInstanceRetentionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAppInstanceRetentionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppInstanceRetentionSettingsOutputError>
}

public struct GetAppInstanceRetentionSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppInstanceRetentionSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAppInstanceRetentionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAppInstanceRetentionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppInstanceRetentionSettingsOutputError>
}

public struct GetAppInstanceRetentionSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppInstanceRetentionSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAppInstanceRetentionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())/retention-settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAppInstanceRetentionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppInstanceRetentionSettingsOutputError>
}

public struct GetAppInstanceRetentionSettingsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct GetAppInstanceRetentionSettingsInputBody: Swift.Equatable {
}

extension GetAppInstanceRetentionSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAppInstanceRetentionSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppInstanceRetentionSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppInstanceRetentionSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppInstanceRetentionSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAppInstanceRetentionSettingsOutputResponse(appInstanceRetentionSettings: \(Swift.String(describing: appInstanceRetentionSettings)), initiateDeletionTimestamp: \(Swift.String(describing: initiateDeletionTimestamp)))"}
}

extension GetAppInstanceRetentionSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAppInstanceRetentionSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceRetentionSettings = output.appInstanceRetentionSettings
            self.initiateDeletionTimestamp = output.initiateDeletionTimestamp
        } else {
            self.appInstanceRetentionSettings = nil
            self.initiateDeletionTimestamp = nil
        }
    }
}

public struct GetAppInstanceRetentionSettingsOutputResponse: Swift.Equatable {
    /// The retention settings for the AppInstance.
    public var appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings?
    /// The timestamp representing the time at which the specified items are retained, in Epoch Seconds.
    public var initiateDeletionTimestamp: ClientRuntime.Date?

    public init (
        appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings? = nil,
        initiateDeletionTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
    }
}

struct GetAppInstanceRetentionSettingsOutputResponseBody: Swift.Equatable {
    public let appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings?
    public let initiateDeletionTimestamp: ClientRuntime.Date?
}

extension GetAppInstanceRetentionSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
        case initiateDeletionTimestamp = "InitiateDeletionTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstanceRetentionSettings.self, forKey: .appInstanceRetentionSettings)
        appInstanceRetentionSettings = appInstanceRetentionSettingsDecoded
        let initiateDeletionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .initiateDeletionTimestamp)
        initiateDeletionTimestamp = initiateDeletionTimestampDecoded
    }
}

extension GetAppInstanceStreamingConfigurationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAppInstanceStreamingConfigurationsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension GetAppInstanceStreamingConfigurationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAppInstanceStreamingConfigurationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppInstanceStreamingConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAppInstanceStreamingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppInstanceStreamingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAppInstanceStreamingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppInstanceStreamingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppInstanceStreamingConfigurationsOutputError>
}

public struct GetAppInstanceStreamingConfigurationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppInstanceStreamingConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAppInstanceStreamingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppInstanceStreamingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAppInstanceStreamingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppInstanceStreamingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppInstanceStreamingConfigurationsOutputError>
}

public struct GetAppInstanceStreamingConfigurationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppInstanceStreamingConfigurationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAppInstanceStreamingConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppInstanceStreamingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAppInstanceStreamingConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppInstanceStreamingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppInstanceStreamingConfigurationsOutputError>
}

public struct GetAppInstanceStreamingConfigurationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAppInstanceStreamingConfigurationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAppInstanceStreamingConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAppInstanceStreamingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())/streaming-configurations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAppInstanceStreamingConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAppInstanceStreamingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAppInstanceStreamingConfigurationsOutputError>
}

public struct GetAppInstanceStreamingConfigurationsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct GetAppInstanceStreamingConfigurationsInputBody: Swift.Equatable {
}

extension GetAppInstanceStreamingConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAppInstanceStreamingConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppInstanceStreamingConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppInstanceStreamingConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppInstanceStreamingConfigurationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAppInstanceStreamingConfigurationsOutputResponse(appInstanceStreamingConfigurations: \(Swift.String(describing: appInstanceStreamingConfigurations)))"}
}

extension GetAppInstanceStreamingConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAppInstanceStreamingConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceStreamingConfigurations = output.appInstanceStreamingConfigurations
        } else {
            self.appInstanceStreamingConfigurations = nil
        }
    }
}

public struct GetAppInstanceStreamingConfigurationsOutputResponse: Swift.Equatable {
    /// The streaming settings.
    public var appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]?

    public init (
        appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]? = nil
    )
    {
        self.appInstanceStreamingConfigurations = appInstanceStreamingConfigurations
    }
}

struct GetAppInstanceStreamingConfigurationsOutputResponseBody: Swift.Equatable {
    public let appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]?
}

extension GetAppInstanceStreamingConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceStreamingConfigurations = "AppInstanceStreamingConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceStreamingConfigurationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.AppInstanceStreamingConfiguration?].self, forKey: .appInstanceStreamingConfigurations)
        var appInstanceStreamingConfigurationsDecoded0:[ChimeClientTypes.AppInstanceStreamingConfiguration]? = nil
        if let appInstanceStreamingConfigurationsContainer = appInstanceStreamingConfigurationsContainer {
            appInstanceStreamingConfigurationsDecoded0 = [ChimeClientTypes.AppInstanceStreamingConfiguration]()
            for structure0 in appInstanceStreamingConfigurationsContainer {
                if let structure0 = structure0 {
                    appInstanceStreamingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        appInstanceStreamingConfigurations = appInstanceStreamingConfigurationsDecoded0
    }
}

extension GetAttendeeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAttendeeInput(attendeeId: \(Swift.String(describing: attendeeId)), meetingId: \(Swift.String(describing: meetingId)))"}
}

extension GetAttendeeInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAttendeeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAttendeeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAttendeeOutputError>
}

public struct GetAttendeeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAttendeeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAttendeeOutputError>
}

public struct GetAttendeeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAttendeeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAttendeeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAttendeeInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAttendeeOutputError>
}

public struct GetAttendeeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAttendeeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAttendeeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        guard let attendeeId = input.attendeeId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("attendeeId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAttendeeInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAttendeeOutputError>
}

public struct GetAttendeeInput: Swift.Equatable {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init (
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
    }
}

struct GetAttendeeInputBody: Swift.Equatable {
}

extension GetAttendeeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAttendeeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAttendeeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAttendeeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAttendeeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAttendeeOutputResponse(attendee: \(Swift.String(describing: attendee)))"}
}

extension GetAttendeeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAttendeeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attendee = output.attendee
        } else {
            self.attendee = nil
        }
    }
}

public struct GetAttendeeOutputResponse: Swift.Equatable {
    /// The Amazon Chime SDK attendee information.
    public var attendee: ChimeClientTypes.Attendee?

    public init (
        attendee: ChimeClientTypes.Attendee? = nil
    )
    {
        self.attendee = attendee
    }
}

struct GetAttendeeOutputResponseBody: Swift.Equatable {
    public let attendee: ChimeClientTypes.Attendee?
}

extension GetAttendeeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendee = "Attendee"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Attendee.self, forKey: .attendee)
        attendee = attendeeDecoded
    }
}

extension GetBotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBotInput(accountId: \(Swift.String(describing: accountId)), botId: \(Swift.String(describing: botId)))"}
}

extension GetBotInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetBotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBotOutputError>
}

public struct GetBotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBotOutputError>
}

public struct GetBotInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBotInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetBotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBotInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBotOutputError>
}

public struct GetBotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBotInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetBotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let botId = input.botId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("botId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBotInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBotOutputError>
}

public struct GetBotInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
    }
}

struct GetBotInputBody: Swift.Equatable {
}

extension GetBotInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBotOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBotOutputResponse(bot: \(Swift.String(describing: bot)))"}
}

extension GetBotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bot = output.bot
        } else {
            self.bot = nil
        }
    }
}

public struct GetBotOutputResponse: Swift.Equatable {
    /// The chat bot details.
    public var bot: ChimeClientTypes.Bot?

    public init (
        bot: ChimeClientTypes.Bot? = nil
    )
    {
        self.bot = bot
    }
}

struct GetBotOutputResponseBody: Swift.Equatable {
    public let bot: ChimeClientTypes.Bot?
}

extension GetBotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bot = "Bot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Bot.self, forKey: .bot)
        bot = botDecoded
    }
}

extension GetChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), messageId: \(Swift.String(describing: messageId)))"}
}

extension GetChannelMessageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetChannelMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelMessageOutputError>
}

public struct GetChannelMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelMessageOutputError>
}

public struct GetChannelMessageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelMessageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelMessageOutputError>
}

public struct GetChannelMessageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelMessageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let messageId = input.messageId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("messageId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelMessageOutputError>
}

public struct GetChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ID of the message.
    /// This member is required.
    public var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

struct GetChannelMessageInputBody: Swift.Equatable {
}

extension GetChannelMessageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetChannelMessageOutputResponse(channelMessage: \(Swift.String(describing: channelMessage)))"}
}

extension GetChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMessage = output.channelMessage
        } else {
            self.channelMessage = nil
        }
    }
}

public struct GetChannelMessageOutputResponse: Swift.Equatable {
    /// The details of and content in the message.
    public var channelMessage: ChimeClientTypes.ChannelMessage?

    public init (
        channelMessage: ChimeClientTypes.ChannelMessage? = nil
    )
    {
        self.channelMessage = channelMessage
    }
}

struct GetChannelMessageOutputResponseBody: Swift.Equatable {
    public let channelMessage: ChimeClientTypes.ChannelMessage?
}

extension GetChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMessage = "ChannelMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMessageDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMessage.self, forKey: .channelMessage)
        channelMessage = channelMessageDecoded
    }
}

extension GetEventsConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEventsConfigurationInput(accountId: \(Swift.String(describing: accountId)), botId: \(Swift.String(describing: botId)))"}
}

extension GetEventsConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetEventsConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventsConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEventsConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEventsConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventsConfigurationOutputError>
}

public struct GetEventsConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventsConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEventsConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEventsConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventsConfigurationOutputError>
}

public struct GetEventsConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventsConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetEventsConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEventsConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventsConfigurationOutputError>
}

public struct GetEventsConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventsConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetEventsConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let botId = input.botId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("botId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())/events-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEventsConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventsConfigurationOutputError>
}

public struct GetEventsConfigurationInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
    }
}

struct GetEventsConfigurationInputBody: Swift.Equatable {
}

extension GetEventsConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEventsConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventsConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEventsConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventsConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEventsConfigurationOutputResponse(eventsConfiguration: \(Swift.String(describing: eventsConfiguration)))"}
}

extension GetEventsConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEventsConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventsConfiguration = output.eventsConfiguration
        } else {
            self.eventsConfiguration = nil
        }
    }
}

public struct GetEventsConfigurationOutputResponse: Swift.Equatable {
    /// The events configuration details.
    public var eventsConfiguration: ChimeClientTypes.EventsConfiguration?

    public init (
        eventsConfiguration: ChimeClientTypes.EventsConfiguration? = nil
    )
    {
        self.eventsConfiguration = eventsConfiguration
    }
}

struct GetEventsConfigurationOutputResponseBody: Swift.Equatable {
    public let eventsConfiguration: ChimeClientTypes.EventsConfiguration?
}

extension GetEventsConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventsConfiguration = "EventsConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EventsConfiguration.self, forKey: .eventsConfiguration)
        eventsConfiguration = eventsConfigurationDecoded
    }
}

extension GetGlobalSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGlobalSettingsInput()"}
}

extension GetGlobalSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetGlobalSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGlobalSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetGlobalSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetGlobalSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGlobalSettingsOutputError>
}

public struct GetGlobalSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGlobalSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetGlobalSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetGlobalSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGlobalSettingsOutputError>
}

public struct GetGlobalSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGlobalSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetGlobalSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetGlobalSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGlobalSettingsOutputError>
}

public struct GetGlobalSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGlobalSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetGlobalSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetGlobalSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGlobalSettingsOutputError>
}

public struct GetGlobalSettingsInput: Swift.Equatable {

    public init() {}
}

struct GetGlobalSettingsInputBody: Swift.Equatable {
}

extension GetGlobalSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGlobalSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGlobalSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGlobalSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGlobalSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGlobalSettingsOutputResponse(businessCalling: \(Swift.String(describing: businessCalling)), voiceConnector: \(Swift.String(describing: voiceConnector)))"}
}

extension GetGlobalSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetGlobalSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.businessCalling = output.businessCalling
            self.voiceConnector = output.voiceConnector
        } else {
            self.businessCalling = nil
            self.voiceConnector = nil
        }
    }
}

public struct GetGlobalSettingsOutputResponse: Swift.Equatable {
    /// The Amazon Chime Business Calling settings.
    public var businessCalling: ChimeClientTypes.BusinessCallingSettings?
    /// The Amazon Chime Voice Connector settings.
    public var voiceConnector: ChimeClientTypes.VoiceConnectorSettings?

    public init (
        businessCalling: ChimeClientTypes.BusinessCallingSettings? = nil,
        voiceConnector: ChimeClientTypes.VoiceConnectorSettings? = nil
    )
    {
        self.businessCalling = businessCalling
        self.voiceConnector = voiceConnector
    }
}

struct GetGlobalSettingsOutputResponseBody: Swift.Equatable {
    public let businessCalling: ChimeClientTypes.BusinessCallingSettings?
    public let voiceConnector: ChimeClientTypes.VoiceConnectorSettings?
}

extension GetGlobalSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessCalling = "BusinessCalling"
        case voiceConnector = "VoiceConnector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let businessCallingDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.BusinessCallingSettings.self, forKey: .businessCalling)
        businessCalling = businessCallingDecoded
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnectorSettings.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension GetMediaCapturePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMediaCapturePipelineInput(mediaPipelineId: \(Swift.String(describing: mediaPipelineId)))"}
}

extension GetMediaCapturePipelineInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetMediaCapturePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMediaCapturePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMediaCapturePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMediaCapturePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMediaCapturePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMediaCapturePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMediaCapturePipelineOutputError>
}

public struct GetMediaCapturePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMediaCapturePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMediaCapturePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMediaCapturePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMediaCapturePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMediaCapturePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMediaCapturePipelineOutputError>
}

public struct GetMediaCapturePipelineInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMediaCapturePipelineInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMediaCapturePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMediaCapturePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMediaCapturePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMediaCapturePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMediaCapturePipelineOutputError>
}

public struct GetMediaCapturePipelineInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMediaCapturePipelineInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMediaCapturePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMediaCapturePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let mediaPipelineId = input.mediaPipelineId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("mediaPipelineId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/media-capture-pipelines/\(mediaPipelineId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMediaCapturePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMediaCapturePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMediaCapturePipelineOutputError>
}

public struct GetMediaCapturePipelineInput: Swift.Equatable {
    /// The ID of the pipeline that you want to get.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init (
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

struct GetMediaCapturePipelineInputBody: Swift.Equatable {
}

extension GetMediaCapturePipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMediaCapturePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMediaCapturePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMediaCapturePipelineOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMediaCapturePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMediaCapturePipelineOutputResponse(mediaCapturePipeline: \(Swift.String(describing: mediaCapturePipeline)))"}
}

extension GetMediaCapturePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMediaCapturePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mediaCapturePipeline = output.mediaCapturePipeline
        } else {
            self.mediaCapturePipeline = nil
        }
    }
}

public struct GetMediaCapturePipelineOutputResponse: Swift.Equatable {
    /// The media capture pipeline object.
    public var mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline?

    public init (
        mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline? = nil
    )
    {
        self.mediaCapturePipeline = mediaCapturePipeline
    }
}

struct GetMediaCapturePipelineOutputResponseBody: Swift.Equatable {
    public let mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline?
}

extension GetMediaCapturePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipeline = "MediaCapturePipeline"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelineDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaCapturePipeline.self, forKey: .mediaCapturePipeline)
        mediaCapturePipeline = mediaCapturePipelineDecoded
    }
}

extension GetMeetingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMeetingInput(meetingId: \(Swift.String(describing: meetingId)))"}
}

extension GetMeetingInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetMeetingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMeetingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMeetingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMeetingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMeetingOutputError>
}

public struct GetMeetingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMeetingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMeetingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMeetingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMeetingOutputError>
}

public struct GetMeetingInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMeetingInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMeetingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMeetingInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMeetingOutputError>
}

public struct GetMeetingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMeetingInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMeetingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMeetingInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMeetingOutputError>
}

public struct GetMeetingInput: Swift.Equatable {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init (
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

struct GetMeetingInputBody: Swift.Equatable {
}

extension GetMeetingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMeetingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMeetingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMeetingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMeetingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMeetingOutputResponse(meeting: \(Swift.String(describing: meeting)))"}
}

extension GetMeetingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMeetingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.meeting = output.meeting
        } else {
            self.meeting = nil
        }
    }
}

public struct GetMeetingOutputResponse: Swift.Equatable {
    /// The Amazon Chime SDK meeting information.
    public var meeting: ChimeClientTypes.Meeting?

    public init (
        meeting: ChimeClientTypes.Meeting? = nil
    )
    {
        self.meeting = meeting
    }
}

struct GetMeetingOutputResponseBody: Swift.Equatable {
    public let meeting: ChimeClientTypes.Meeting?
}

extension GetMeetingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meeting = "Meeting"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Meeting.self, forKey: .meeting)
        meeting = meetingDecoded
    }
}

extension GetMessagingSessionEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMessagingSessionEndpointInput()"}
}

extension GetMessagingSessionEndpointInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetMessagingSessionEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMessagingSessionEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMessagingSessionEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMessagingSessionEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMessagingSessionEndpointOutputError>
}

public struct GetMessagingSessionEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMessagingSessionEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMessagingSessionEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMessagingSessionEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMessagingSessionEndpointOutputError>
}

public struct GetMessagingSessionEndpointInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMessagingSessionEndpointInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMessagingSessionEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMessagingSessionEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMessagingSessionEndpointOutputError>
}

public struct GetMessagingSessionEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMessagingSessionEndpointInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMessagingSessionEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/endpoints/messaging-session"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMessagingSessionEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMessagingSessionEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMessagingSessionEndpointOutputError>
}

public struct GetMessagingSessionEndpointInput: Swift.Equatable {

    public init() {}
}

struct GetMessagingSessionEndpointInputBody: Swift.Equatable {
}

extension GetMessagingSessionEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMessagingSessionEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMessagingSessionEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMessagingSessionEndpointOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMessagingSessionEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMessagingSessionEndpointOutputResponse(endpoint: \(Swift.String(describing: endpoint)))"}
}

extension GetMessagingSessionEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMessagingSessionEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct GetMessagingSessionEndpointOutputResponse: Swift.Equatable {
    /// The endpoint returned in the response.
    public var endpoint: ChimeClientTypes.MessagingSessionEndpoint?

    public init (
        endpoint: ChimeClientTypes.MessagingSessionEndpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct GetMessagingSessionEndpointOutputResponseBody: Swift.Equatable {
    public let endpoint: ChimeClientTypes.MessagingSessionEndpoint?
}

extension GetMessagingSessionEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MessagingSessionEndpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension GetPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPhoneNumberInput(phoneNumberId: \(Swift.String(describing: phoneNumberId)))"}
}

extension GetPhoneNumberInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetPhoneNumberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPhoneNumberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPhoneNumberOutputError>
}

public struct GetPhoneNumberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPhoneNumberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPhoneNumberOutputError>
}

public struct GetPhoneNumberInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPhoneNumberInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetPhoneNumberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPhoneNumberInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPhoneNumberOutputError>
}

public struct GetPhoneNumberInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPhoneNumberInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetPhoneNumberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let phoneNumberId = input.phoneNumberId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("phoneNumberId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPhoneNumberInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPhoneNumberOutputError>
}

public struct GetPhoneNumberInput: Swift.Equatable {
    /// The phone number ID.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init (
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct GetPhoneNumberInputBody: Swift.Equatable {
}

extension GetPhoneNumberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPhoneNumberOrderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPhoneNumberOrderInput(phoneNumberOrderId: \(Swift.String(describing: phoneNumberOrderId)))"}
}

extension GetPhoneNumberOrderInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetPhoneNumberOrderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPhoneNumberOrderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPhoneNumberOrderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPhoneNumberOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPhoneNumberOrderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPhoneNumberOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPhoneNumberOrderOutputError>
}

public struct GetPhoneNumberOrderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPhoneNumberOrderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPhoneNumberOrderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPhoneNumberOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPhoneNumberOrderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPhoneNumberOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPhoneNumberOrderOutputError>
}

public struct GetPhoneNumberOrderInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPhoneNumberOrderInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetPhoneNumberOrderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPhoneNumberOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPhoneNumberOrderInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPhoneNumberOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPhoneNumberOrderOutputError>
}

public struct GetPhoneNumberOrderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPhoneNumberOrderInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetPhoneNumberOrderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPhoneNumberOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let phoneNumberOrderId = input.phoneNumberOrderId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("phoneNumberOrderId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/phone-number-orders/\(phoneNumberOrderId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPhoneNumberOrderInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPhoneNumberOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPhoneNumberOrderOutputError>
}

public struct GetPhoneNumberOrderInput: Swift.Equatable {
    /// The ID for the phone number order.
    /// This member is required.
    public var phoneNumberOrderId: Swift.String?

    public init (
        phoneNumberOrderId: Swift.String? = nil
    )
    {
        self.phoneNumberOrderId = phoneNumberOrderId
    }
}

struct GetPhoneNumberOrderInputBody: Swift.Equatable {
}

extension GetPhoneNumberOrderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPhoneNumberOrderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPhoneNumberOrderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPhoneNumberOrderOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPhoneNumberOrderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPhoneNumberOrderOutputResponse(phoneNumberOrder: \(Swift.String(describing: phoneNumberOrder)))"}
}

extension GetPhoneNumberOrderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPhoneNumberOrderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberOrder = output.phoneNumberOrder
        } else {
            self.phoneNumberOrder = nil
        }
    }
}

public struct GetPhoneNumberOrderOutputResponse: Swift.Equatable {
    /// The phone number order details.
    public var phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder?

    public init (
        phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder? = nil
    )
    {
        self.phoneNumberOrder = phoneNumberOrder
    }
}

struct GetPhoneNumberOrderOutputResponseBody: Swift.Equatable {
    public let phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder?
}

extension GetPhoneNumberOrderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberOrder = "PhoneNumberOrder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrderDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberOrder.self, forKey: .phoneNumberOrder)
        phoneNumberOrder = phoneNumberOrderDecoded
    }
}

extension GetPhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPhoneNumberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPhoneNumberOutputResponse(phoneNumber: \(Swift.String(describing: phoneNumber)))"}
}

extension GetPhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPhoneNumberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumber = output.phoneNumber
        } else {
            self.phoneNumber = nil
        }
    }
}

public struct GetPhoneNumberOutputResponse: Swift.Equatable {
    /// The phone number details.
    public var phoneNumber: ChimeClientTypes.PhoneNumber?

    public init (
        phoneNumber: ChimeClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct GetPhoneNumberOutputResponseBody: Swift.Equatable {
    public let phoneNumber: ChimeClientTypes.PhoneNumber?
}

extension GetPhoneNumberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumber.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension GetPhoneNumberSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPhoneNumberSettingsInput()"}
}

extension GetPhoneNumberSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetPhoneNumberSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPhoneNumberSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPhoneNumberSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPhoneNumberSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPhoneNumberSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPhoneNumberSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPhoneNumberSettingsOutputError>
}

public struct GetPhoneNumberSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPhoneNumberSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPhoneNumberSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPhoneNumberSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPhoneNumberSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPhoneNumberSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPhoneNumberSettingsOutputError>
}

public struct GetPhoneNumberSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPhoneNumberSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetPhoneNumberSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPhoneNumberSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPhoneNumberSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPhoneNumberSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPhoneNumberSettingsOutputError>
}

public struct GetPhoneNumberSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPhoneNumberSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetPhoneNumberSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPhoneNumberSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/settings/phone-number"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPhoneNumberSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPhoneNumberSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPhoneNumberSettingsOutputError>
}

public struct GetPhoneNumberSettingsInput: Swift.Equatable {

    public init() {}
}

struct GetPhoneNumberSettingsInputBody: Swift.Equatable {
}

extension GetPhoneNumberSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPhoneNumberSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPhoneNumberSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPhoneNumberSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPhoneNumberSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPhoneNumberSettingsOutputResponse(callingName: \(Swift.String(describing: callingName)), callingNameUpdatedTimestamp: \(Swift.String(describing: callingNameUpdatedTimestamp)))"}
}

extension GetPhoneNumberSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPhoneNumberSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.callingName = output.callingName
            self.callingNameUpdatedTimestamp = output.callingNameUpdatedTimestamp
        } else {
            self.callingName = nil
            self.callingNameUpdatedTimestamp = nil
        }
    }
}

public struct GetPhoneNumberSettingsOutputResponse: Swift.Equatable {
    /// The default outbound calling name for the account.
    public var callingName: Swift.String?
    /// The updated outbound calling name timestamp, in ISO 8601 format.
    public var callingNameUpdatedTimestamp: ClientRuntime.Date?

    public init (
        callingName: Swift.String? = nil,
        callingNameUpdatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.callingName = callingName
        self.callingNameUpdatedTimestamp = callingNameUpdatedTimestamp
    }
}

struct GetPhoneNumberSettingsOutputResponseBody: Swift.Equatable {
    public let callingName: Swift.String?
    public let callingNameUpdatedTimestamp: ClientRuntime.Date?
}

extension GetPhoneNumberSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case callingNameUpdatedTimestamp = "CallingNameUpdatedTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
        let callingNameUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .callingNameUpdatedTimestamp)
        callingNameUpdatedTimestamp = callingNameUpdatedTimestampDecoded
    }
}

extension GetProxySessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProxySessionInput(proxySessionId: \(Swift.String(describing: proxySessionId)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension GetProxySessionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetProxySessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProxySessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProxySessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProxySessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProxySessionOutputError>
}

public struct GetProxySessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProxySessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProxySessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProxySessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProxySessionOutputError>
}

public struct GetProxySessionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProxySessionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetProxySessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetProxySessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProxySessionOutputError>
}

public struct GetProxySessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProxySessionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetProxySessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        guard let proxySessionId = input.proxySessionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("proxySessionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetProxySessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProxySessionOutputError>
}

public struct GetProxySessionInput: Swift.Equatable {
    /// The proxy session ID.
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetProxySessionInputBody: Swift.Equatable {
}

extension GetProxySessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetProxySessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProxySessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProxySessionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProxySessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProxySessionOutputResponse(proxySession: \(Swift.String(describing: proxySession)))"}
}

extension GetProxySessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetProxySessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proxySession = output.proxySession
        } else {
            self.proxySession = nil
        }
    }
}

public struct GetProxySessionOutputResponse: Swift.Equatable {
    /// The proxy session details.
    public var proxySession: ChimeClientTypes.ProxySession?

    public init (
        proxySession: ChimeClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

struct GetProxySessionOutputResponseBody: Swift.Equatable {
    public let proxySession: ChimeClientTypes.ProxySession?
}

extension GetProxySessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxySession = "ProxySession"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ProxySession.self, forKey: .proxySession)
        proxySession = proxySessionDecoded
    }
}

extension GetRetentionSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRetentionSettingsInput(accountId: \(Swift.String(describing: accountId)))"}
}

extension GetRetentionSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRetentionSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRetentionSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRetentionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRetentionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRetentionSettingsOutputError>
}

public struct GetRetentionSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRetentionSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRetentionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRetentionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRetentionSettingsOutputError>
}

public struct GetRetentionSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRetentionSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetRetentionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRetentionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRetentionSettingsOutputError>
}

public struct GetRetentionSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRetentionSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetRetentionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/retention-settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRetentionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRetentionSettingsOutputError>
}

public struct GetRetentionSettingsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetRetentionSettingsInputBody: Swift.Equatable {
}

extension GetRetentionSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRetentionSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRetentionSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRetentionSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRetentionSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRetentionSettingsOutputResponse(initiateDeletionTimestamp: \(Swift.String(describing: initiateDeletionTimestamp)), retentionSettings: \(Swift.String(describing: retentionSettings)))"}
}

extension GetRetentionSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRetentionSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.initiateDeletionTimestamp = output.initiateDeletionTimestamp
            self.retentionSettings = output.retentionSettings
        } else {
            self.initiateDeletionTimestamp = nil
            self.retentionSettings = nil
        }
    }
}

public struct GetRetentionSettingsOutputResponse: Swift.Equatable {
    /// The timestamp representing the time at which the specified items are permanently deleted, in ISO 8601 format.
    public var initiateDeletionTimestamp: ClientRuntime.Date?
    /// The retention settings.
    public var retentionSettings: ChimeClientTypes.RetentionSettings?

    public init (
        initiateDeletionTimestamp: ClientRuntime.Date? = nil,
        retentionSettings: ChimeClientTypes.RetentionSettings? = nil
    )
    {
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
        self.retentionSettings = retentionSettings
    }
}

struct GetRetentionSettingsOutputResponseBody: Swift.Equatable {
    public let retentionSettings: ChimeClientTypes.RetentionSettings?
    public let initiateDeletionTimestamp: ClientRuntime.Date?
}

extension GetRetentionSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiateDeletionTimestamp = "InitiateDeletionTimestamp"
        case retentionSettings = "RetentionSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RetentionSettings.self, forKey: .retentionSettings)
        retentionSettings = retentionSettingsDecoded
        let initiateDeletionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .initiateDeletionTimestamp)
        initiateDeletionTimestamp = initiateDeletionTimestampDecoded
    }
}

extension GetRoomInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRoomInput(accountId: \(Swift.String(describing: accountId)), roomId: \(Swift.String(describing: roomId)))"}
}

extension GetRoomInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRoomInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRoomInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRoomInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRoomInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRoomOutputError>
}

public struct GetRoomInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRoomInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRoomInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRoomInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRoomOutputError>
}

public struct GetRoomInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRoomInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetRoomInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRoomInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRoomOutputError>
}

public struct GetRoomInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRoomInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetRoomInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let roomId = input.roomId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("roomId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRoomInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRoomOutputError>
}

public struct GetRoomInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.roomId = roomId
    }
}

struct GetRoomInputBody: Swift.Equatable {
}

extension GetRoomInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRoomOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRoomOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRoomOutputResponse(room: \(Swift.String(describing: room)))"}
}

extension GetRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRoomOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.room = output.room
        } else {
            self.room = nil
        }
    }
}

public struct GetRoomOutputResponse: Swift.Equatable {
    /// The room details.
    public var room: ChimeClientTypes.Room?

    public init (
        room: ChimeClientTypes.Room? = nil
    )
    {
        self.room = room
    }
}

struct GetRoomOutputResponseBody: Swift.Equatable {
    public let room: ChimeClientTypes.Room?
}

extension GetRoomOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case room = "Room"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Room.self, forKey: .room)
        room = roomDecoded
    }
}

extension GetSipMediaApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSipMediaApplicationInput(sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)))"}
}

extension GetSipMediaApplicationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSipMediaApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSipMediaApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSipMediaApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSipMediaApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSipMediaApplicationOutputError>
}

public struct GetSipMediaApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSipMediaApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSipMediaApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSipMediaApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSipMediaApplicationOutputError>
}

public struct GetSipMediaApplicationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSipMediaApplicationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetSipMediaApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSipMediaApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSipMediaApplicationOutputError>
}

public struct GetSipMediaApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSipMediaApplicationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetSipMediaApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sipMediaApplicationId = input.sipMediaApplicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sipMediaApplicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSipMediaApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSipMediaApplicationOutputError>
}

public struct GetSipMediaApplicationInput: Swift.Equatable {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init (
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct GetSipMediaApplicationInputBody: Swift.Equatable {
}

extension GetSipMediaApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSipMediaApplicationLoggingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSipMediaApplicationLoggingConfigurationInput(sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)))"}
}

extension GetSipMediaApplicationLoggingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSipMediaApplicationLoggingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSipMediaApplicationLoggingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSipMediaApplicationLoggingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSipMediaApplicationLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSipMediaApplicationLoggingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSipMediaApplicationLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSipMediaApplicationLoggingConfigurationOutputError>
}

public struct GetSipMediaApplicationLoggingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSipMediaApplicationLoggingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSipMediaApplicationLoggingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSipMediaApplicationLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSipMediaApplicationLoggingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSipMediaApplicationLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSipMediaApplicationLoggingConfigurationOutputError>
}

public struct GetSipMediaApplicationLoggingConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSipMediaApplicationLoggingConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetSipMediaApplicationLoggingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSipMediaApplicationLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSipMediaApplicationLoggingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSipMediaApplicationLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSipMediaApplicationLoggingConfigurationOutputError>
}

public struct GetSipMediaApplicationLoggingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSipMediaApplicationLoggingConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetSipMediaApplicationLoggingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSipMediaApplicationLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sipMediaApplicationId = input.sipMediaApplicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sipMediaApplicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/logging-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSipMediaApplicationLoggingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSipMediaApplicationLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSipMediaApplicationLoggingConfigurationOutputError>
}

public struct GetSipMediaApplicationLoggingConfigurationInput: Swift.Equatable {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init (
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct GetSipMediaApplicationLoggingConfigurationInputBody: Swift.Equatable {
}

extension GetSipMediaApplicationLoggingConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSipMediaApplicationLoggingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSipMediaApplicationLoggingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSipMediaApplicationLoggingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSipMediaApplicationLoggingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSipMediaApplicationLoggingConfigurationOutputResponse(sipMediaApplicationLoggingConfiguration: \(Swift.String(describing: sipMediaApplicationLoggingConfiguration)))"}
}

extension GetSipMediaApplicationLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSipMediaApplicationLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationLoggingConfiguration = output.sipMediaApplicationLoggingConfiguration
        } else {
            self.sipMediaApplicationLoggingConfiguration = nil
        }
    }
}

public struct GetSipMediaApplicationLoggingConfigurationOutputResponse: Swift.Equatable {
    /// The actual logging configuration.
    public var sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?

    public init (
        sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

struct GetSipMediaApplicationLoggingConfigurationOutputResponseBody: Swift.Equatable {
    public let sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?
}

extension GetSipMediaApplicationLoggingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationLoggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplicationLoggingConfiguration.self, forKey: .sipMediaApplicationLoggingConfiguration)
        sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfigurationDecoded
    }
}

extension GetSipMediaApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSipMediaApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSipMediaApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSipMediaApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSipMediaApplicationOutputResponse(sipMediaApplication: \(Swift.String(describing: sipMediaApplication)))"}
}

extension GetSipMediaApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSipMediaApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplication = output.sipMediaApplication
        } else {
            self.sipMediaApplication = nil
        }
    }
}

public struct GetSipMediaApplicationOutputResponse: Swift.Equatable {
    /// The SIP media application details.
    public var sipMediaApplication: ChimeClientTypes.SipMediaApplication?

    public init (
        sipMediaApplication: ChimeClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

struct GetSipMediaApplicationOutputResponseBody: Swift.Equatable {
    public let sipMediaApplication: ChimeClientTypes.SipMediaApplication?
}

extension GetSipMediaApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplication = "SipMediaApplication"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplication.self, forKey: .sipMediaApplication)
        sipMediaApplication = sipMediaApplicationDecoded
    }
}

extension GetSipRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSipRuleInput(sipRuleId: \(Swift.String(describing: sipRuleId)))"}
}

extension GetSipRuleInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSipRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSipRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSipRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSipRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSipRuleOutputError>
}

public struct GetSipRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSipRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSipRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSipRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSipRuleOutputError>
}

public struct GetSipRuleInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSipRuleInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetSipRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSipRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSipRuleOutputError>
}

public struct GetSipRuleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSipRuleInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetSipRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sipRuleId = input.sipRuleId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sipRuleId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sip-rules/\(sipRuleId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSipRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSipRuleOutputError>
}

public struct GetSipRuleInput: Swift.Equatable {
    /// The SIP rule ID.
    /// This member is required.
    public var sipRuleId: Swift.String?

    public init (
        sipRuleId: Swift.String? = nil
    )
    {
        self.sipRuleId = sipRuleId
    }
}

struct GetSipRuleInputBody: Swift.Equatable {
}

extension GetSipRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSipRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSipRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSipRuleOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSipRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSipRuleOutputResponse(sipRule: \(Swift.String(describing: sipRule)))"}
}

extension GetSipRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSipRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipRule = output.sipRule
        } else {
            self.sipRule = nil
        }
    }
}

public struct GetSipRuleOutputResponse: Swift.Equatable {
    /// The SIP rule details.
    public var sipRule: ChimeClientTypes.SipRule?

    public init (
        sipRule: ChimeClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

struct GetSipRuleOutputResponseBody: Swift.Equatable {
    public let sipRule: ChimeClientTypes.SipRule?
}

extension GetSipRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipRule = "SipRule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipRule.self, forKey: .sipRule)
        sipRule = sipRuleDecoded
    }
}

extension GetUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetUserInput(accountId: \(Swift.String(describing: accountId)), userId: \(Swift.String(describing: userId)))"}
}

extension GetUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUserOutputError>
}

public struct GetUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUserOutputError>
}

public struct GetUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUserOutputError>
}

public struct GetUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let userId = input.userId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("userId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUserOutputError>
}

public struct GetUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
    }
}

struct GetUserInputBody: Swift.Equatable {
}

extension GetUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetUserOutputResponse(user: \(Swift.String(describing: user)))"}
}

extension GetUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct GetUserOutputResponse: Swift.Equatable {
    /// The user details.
    public var user: ChimeClientTypes.User?

    public init (
        user: ChimeClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct GetUserOutputResponseBody: Swift.Equatable {
    public let user: ChimeClientTypes.User?
}

extension GetUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

extension GetUserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetUserSettingsInput(accountId: \(Swift.String(describing: accountId)), userId: \(Swift.String(describing: userId)))"}
}

extension GetUserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetUserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUserSettingsOutputError>
}

public struct GetUserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUserSettingsOutputError>
}

public struct GetUserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUserSettingsOutputError>
}

public struct GetUserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let userId = input.userId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("userId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())/settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUserSettingsOutputError>
}

public struct GetUserSettingsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
    }
}

struct GetUserSettingsInputBody: Swift.Equatable {
}

extension GetUserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetUserSettingsOutputResponse(userSettings: \(Swift.String(describing: userSettings)))"}
}

extension GetUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userSettings = output.userSettings
        } else {
            self.userSettings = nil
        }
    }
}

public struct GetUserSettingsOutputResponse: Swift.Equatable {
    /// The user settings.
    public var userSettings: ChimeClientTypes.UserSettings?

    public init (
        userSettings: ChimeClientTypes.UserSettings? = nil
    )
    {
        self.userSettings = userSettings
    }
}

struct GetUserSettingsOutputResponseBody: Swift.Equatable {
    public let userSettings: ChimeClientTypes.UserSettings?
}

extension GetUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettings = "UserSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.UserSettings.self, forKey: .userSettings)
        userSettings = userSettingsDecoded
    }
}

extension GetVoiceConnectorEmergencyCallingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorEmergencyCallingConfigurationInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension GetVoiceConnectorEmergencyCallingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetVoiceConnectorEmergencyCallingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorEmergencyCallingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorEmergencyCallingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorEmergencyCallingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorEmergencyCallingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorEmergencyCallingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorEmergencyCallingConfigurationOutputError>
}

public struct GetVoiceConnectorEmergencyCallingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorEmergencyCallingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorEmergencyCallingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorEmergencyCallingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorEmergencyCallingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorEmergencyCallingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorEmergencyCallingConfigurationOutputError>
}

public struct GetVoiceConnectorEmergencyCallingConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorEmergencyCallingConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorEmergencyCallingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorEmergencyCallingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorEmergencyCallingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorEmergencyCallingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorEmergencyCallingConfigurationOutputError>
}

public struct GetVoiceConnectorEmergencyCallingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorEmergencyCallingConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorEmergencyCallingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorEmergencyCallingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorEmergencyCallingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorEmergencyCallingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorEmergencyCallingConfigurationOutputError>
}

public struct GetVoiceConnectorEmergencyCallingConfigurationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVoiceConnectorEmergencyCallingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorEmergencyCallingConfigurationOutputResponse(emergencyCallingConfiguration: \(Swift.String(describing: emergencyCallingConfiguration)))"}
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVoiceConnectorEmergencyCallingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.emergencyCallingConfiguration = output.emergencyCallingConfiguration
        } else {
            self.emergencyCallingConfiguration = nil
        }
    }
}

public struct GetVoiceConnectorEmergencyCallingConfigurationOutputResponse: Swift.Equatable {
    /// The emergency calling configuration details.
    public var emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration?

    public init (
        emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
    }
}

struct GetVoiceConnectorEmergencyCallingConfigurationOutputResponseBody: Swift.Equatable {
    public let emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration?
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyCallingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EmergencyCallingConfiguration.self, forKey: .emergencyCallingConfiguration)
        emergencyCallingConfiguration = emergencyCallingConfigurationDecoded
    }
}

extension GetVoiceConnectorGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorGroupInput(voiceConnectorGroupId: \(Swift.String(describing: voiceConnectorGroupId)))"}
}

extension GetVoiceConnectorGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetVoiceConnectorGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorGroupOutputError>
}

public struct GetVoiceConnectorGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorGroupOutputError>
}

public struct GetVoiceConnectorGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorGroupOutputError>
}

public struct GetVoiceConnectorGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorGroupId = input.voiceConnectorGroupId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorGroupId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorGroupOutputError>
}

public struct GetVoiceConnectorGroupInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init (
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct GetVoiceConnectorGroupInputBody: Swift.Equatable {
}

extension GetVoiceConnectorGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVoiceConnectorGroupOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorGroupOutputResponse(voiceConnectorGroup: \(Swift.String(describing: voiceConnectorGroup)))"}
}

extension GetVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVoiceConnectorGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorGroup = output.voiceConnectorGroup
        } else {
            self.voiceConnectorGroup = nil
        }
    }
}

public struct GetVoiceConnectorGroupOutputResponse: Swift.Equatable {
    /// The Amazon Chime Voice Connector group details.
    public var voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup?

    public init (
        voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

struct GetVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
    public let voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup?
}

extension GetVoiceConnectorGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorGroup = "VoiceConnectorGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnectorGroup.self, forKey: .voiceConnectorGroup)
        voiceConnectorGroup = voiceConnectorGroupDecoded
    }
}

extension GetVoiceConnectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension GetVoiceConnectorInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetVoiceConnectorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorOutputError>
}

public struct GetVoiceConnectorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorOutputError>
}

public struct GetVoiceConnectorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorOutputError>
}

public struct GetVoiceConnectorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorOutputError>
}

public struct GetVoiceConnectorInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorInputBody: Swift.Equatable {
}

extension GetVoiceConnectorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorLoggingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorLoggingConfigurationInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension GetVoiceConnectorLoggingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetVoiceConnectorLoggingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorLoggingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorLoggingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorLoggingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorLoggingConfigurationOutputError>
}

public struct GetVoiceConnectorLoggingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorLoggingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorLoggingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorLoggingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorLoggingConfigurationOutputError>
}

public struct GetVoiceConnectorLoggingConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorLoggingConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorLoggingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorLoggingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorLoggingConfigurationOutputError>
}

public struct GetVoiceConnectorLoggingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorLoggingConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorLoggingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/logging-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorLoggingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorLoggingConfigurationOutputError>
}

public struct GetVoiceConnectorLoggingConfigurationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorLoggingConfigurationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorLoggingConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorLoggingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorLoggingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVoiceConnectorLoggingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorLoggingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorLoggingConfigurationOutputResponse(loggingConfiguration: \(Swift.String(describing: loggingConfiguration)))"}
}

extension GetVoiceConnectorLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVoiceConnectorLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.loggingConfiguration = nil
        }
    }
}

public struct GetVoiceConnectorLoggingConfigurationOutputResponse: Swift.Equatable {
    /// The logging configuration details.
    public var loggingConfiguration: ChimeClientTypes.LoggingConfiguration?

    public init (
        loggingConfiguration: ChimeClientTypes.LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct GetVoiceConnectorLoggingConfigurationOutputResponseBody: Swift.Equatable {
    public let loggingConfiguration: ChimeClientTypes.LoggingConfiguration?
}

extension GetVoiceConnectorLoggingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

extension GetVoiceConnectorOriginationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorOriginationInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension GetVoiceConnectorOriginationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetVoiceConnectorOriginationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorOriginationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorOriginationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorOriginationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorOriginationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorOriginationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorOriginationOutputError>
}

public struct GetVoiceConnectorOriginationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorOriginationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorOriginationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorOriginationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorOriginationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorOriginationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorOriginationOutputError>
}

public struct GetVoiceConnectorOriginationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorOriginationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorOriginationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorOriginationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorOriginationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorOriginationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorOriginationOutputError>
}

public struct GetVoiceConnectorOriginationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorOriginationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorOriginationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorOriginationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorOriginationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorOriginationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorOriginationOutputError>
}

public struct GetVoiceConnectorOriginationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorOriginationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorOriginationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorOriginationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorOriginationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVoiceConnectorOriginationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorOriginationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorOriginationOutputResponse(origination: \(Swift.String(describing: origination)))"}
}

extension GetVoiceConnectorOriginationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVoiceConnectorOriginationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.origination = output.origination
        } else {
            self.origination = nil
        }
    }
}

public struct GetVoiceConnectorOriginationOutputResponse: Swift.Equatable {
    /// The origination setting details.
    public var origination: ChimeClientTypes.Origination?

    public init (
        origination: ChimeClientTypes.Origination? = nil
    )
    {
        self.origination = origination
    }
}

struct GetVoiceConnectorOriginationOutputResponseBody: Swift.Equatable {
    public let origination: ChimeClientTypes.Origination?
}

extension GetVoiceConnectorOriginationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
    }
}

extension GetVoiceConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVoiceConnectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorOutputResponse(voiceConnector: \(Swift.String(describing: voiceConnector)))"}
}

extension GetVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVoiceConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct GetVoiceConnectorOutputResponse: Swift.Equatable {
    /// The Amazon Chime Voice Connector details.
    public var voiceConnector: ChimeClientTypes.VoiceConnector?

    public init (
        voiceConnector: ChimeClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct GetVoiceConnectorOutputResponseBody: Swift.Equatable {
    public let voiceConnector: ChimeClientTypes.VoiceConnector?
}

extension GetVoiceConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnector.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension GetVoiceConnectorProxyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorProxyInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension GetVoiceConnectorProxyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetVoiceConnectorProxyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorProxyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorProxyOutputError>
}

public struct GetVoiceConnectorProxyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorProxyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorProxyOutputError>
}

public struct GetVoiceConnectorProxyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorProxyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorProxyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorProxyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorProxyOutputError>
}

public struct GetVoiceConnectorProxyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorProxyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorProxyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorProxyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorProxyOutputError>
}

public struct GetVoiceConnectorProxyInput: Swift.Equatable {
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorProxyInputBody: Swift.Equatable {
}

extension GetVoiceConnectorProxyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorProxyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorProxyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVoiceConnectorProxyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorProxyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorProxyOutputResponse(proxy: \(Swift.String(describing: proxy)))"}
}

extension GetVoiceConnectorProxyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVoiceConnectorProxyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proxy = output.proxy
        } else {
            self.proxy = nil
        }
    }
}

public struct GetVoiceConnectorProxyOutputResponse: Swift.Equatable {
    /// The proxy configuration details.
    public var proxy: ChimeClientTypes.Proxy?

    public init (
        proxy: ChimeClientTypes.Proxy? = nil
    )
    {
        self.proxy = proxy
    }
}

struct GetVoiceConnectorProxyOutputResponseBody: Swift.Equatable {
    public let proxy: ChimeClientTypes.Proxy?
}

extension GetVoiceConnectorProxyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxy = "Proxy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxyDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Proxy.self, forKey: .proxy)
        proxy = proxyDecoded
    }
}

extension GetVoiceConnectorStreamingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorStreamingConfigurationInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension GetVoiceConnectorStreamingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetVoiceConnectorStreamingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorStreamingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorStreamingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorStreamingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorStreamingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorStreamingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorStreamingConfigurationOutputError>
}

public struct GetVoiceConnectorStreamingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorStreamingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorStreamingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorStreamingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorStreamingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorStreamingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorStreamingConfigurationOutputError>
}

public struct GetVoiceConnectorStreamingConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorStreamingConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorStreamingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorStreamingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorStreamingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorStreamingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorStreamingConfigurationOutputError>
}

public struct GetVoiceConnectorStreamingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorStreamingConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorStreamingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorStreamingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorStreamingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorStreamingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorStreamingConfigurationOutputError>
}

public struct GetVoiceConnectorStreamingConfigurationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorStreamingConfigurationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorStreamingConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorStreamingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorStreamingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVoiceConnectorStreamingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorStreamingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorStreamingConfigurationOutputResponse(streamingConfiguration: \(Swift.String(describing: streamingConfiguration)))"}
}

extension GetVoiceConnectorStreamingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVoiceConnectorStreamingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingConfiguration = output.streamingConfiguration
        } else {
            self.streamingConfiguration = nil
        }
    }
}

public struct GetVoiceConnectorStreamingConfigurationOutputResponse: Swift.Equatable {
    /// The streaming configuration details.
    public var streamingConfiguration: ChimeClientTypes.StreamingConfiguration?

    public init (
        streamingConfiguration: ChimeClientTypes.StreamingConfiguration? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
    }
}

struct GetVoiceConnectorStreamingConfigurationOutputResponseBody: Swift.Equatable {
    public let streamingConfiguration: ChimeClientTypes.StreamingConfiguration?
}

extension GetVoiceConnectorStreamingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.StreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

extension GetVoiceConnectorTerminationHealthInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorTerminationHealthInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension GetVoiceConnectorTerminationHealthInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetVoiceConnectorTerminationHealthInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorTerminationHealthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorTerminationHealthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorTerminationHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorTerminationHealthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorTerminationHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorTerminationHealthOutputError>
}

public struct GetVoiceConnectorTerminationHealthInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorTerminationHealthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorTerminationHealthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorTerminationHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorTerminationHealthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorTerminationHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorTerminationHealthOutputError>
}

public struct GetVoiceConnectorTerminationHealthInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorTerminationHealthInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorTerminationHealthInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorTerminationHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorTerminationHealthInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorTerminationHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorTerminationHealthOutputError>
}

public struct GetVoiceConnectorTerminationHealthInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorTerminationHealthInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorTerminationHealthInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorTerminationHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/health"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorTerminationHealthInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorTerminationHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorTerminationHealthOutputError>
}

public struct GetVoiceConnectorTerminationHealthInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorTerminationHealthInputBody: Swift.Equatable {
}

extension GetVoiceConnectorTerminationHealthInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorTerminationHealthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorTerminationHealthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVoiceConnectorTerminationHealthOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorTerminationHealthOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorTerminationHealthOutputResponse(terminationHealth: \(Swift.String(describing: terminationHealth)))"}
}

extension GetVoiceConnectorTerminationHealthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVoiceConnectorTerminationHealthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.terminationHealth = output.terminationHealth
        } else {
            self.terminationHealth = nil
        }
    }
}

public struct GetVoiceConnectorTerminationHealthOutputResponse: Swift.Equatable {
    /// The termination health details.
    public var terminationHealth: ChimeClientTypes.TerminationHealth?

    public init (
        terminationHealth: ChimeClientTypes.TerminationHealth? = nil
    )
    {
        self.terminationHealth = terminationHealth
    }
}

struct GetVoiceConnectorTerminationHealthOutputResponseBody: Swift.Equatable {
    public let terminationHealth: ChimeClientTypes.TerminationHealth?
}

extension GetVoiceConnectorTerminationHealthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case terminationHealth = "TerminationHealth"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationHealthDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TerminationHealth.self, forKey: .terminationHealth)
        terminationHealth = terminationHealthDecoded
    }
}

extension GetVoiceConnectorTerminationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorTerminationInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension GetVoiceConnectorTerminationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetVoiceConnectorTerminationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorTerminationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorTerminationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorTerminationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorTerminationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorTerminationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorTerminationOutputError>
}

public struct GetVoiceConnectorTerminationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorTerminationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVoiceConnectorTerminationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorTerminationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVoiceConnectorTerminationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorTerminationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorTerminationOutputError>
}

public struct GetVoiceConnectorTerminationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorTerminationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorTerminationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorTerminationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorTerminationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorTerminationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorTerminationOutputError>
}

public struct GetVoiceConnectorTerminationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVoiceConnectorTerminationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetVoiceConnectorTerminationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVoiceConnectorTerminationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetVoiceConnectorTerminationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetVoiceConnectorTerminationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVoiceConnectorTerminationOutputError>
}

public struct GetVoiceConnectorTerminationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorTerminationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorTerminationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorTerminationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorTerminationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVoiceConnectorTerminationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorTerminationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVoiceConnectorTerminationOutputResponse(termination: \(Swift.String(describing: termination)))"}
}

extension GetVoiceConnectorTerminationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVoiceConnectorTerminationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.termination = output.termination
        } else {
            self.termination = nil
        }
    }
}

public struct GetVoiceConnectorTerminationOutputResponse: Swift.Equatable {
    /// The termination setting details.
    public var termination: ChimeClientTypes.Termination?

    public init (
        termination: ChimeClientTypes.Termination? = nil
    )
    {
        self.termination = termination
    }
}

struct GetVoiceConnectorTerminationOutputResponseBody: Swift.Equatable {
    public let termination: ChimeClientTypes.Termination?
}

extension GetVoiceConnectorTerminationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Termination.self, forKey: .termination)
        termination = terminationDecoded
    }
}

extension ChimeClientTypes.Identity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ChimeClientTypes.Identity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Identity(arn: \(Swift.String(describing: arn)), name: \(Swift.String(describing: name)))"}
}

extension ChimeClientTypes {
    /// The details of a user.
    public struct Identity: Swift.Equatable {
        /// The ARN in an Identity.
        public var arn: Swift.String?
        /// The name in an Identity.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension ChimeClientTypes.Invite: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailAddress = "EmailAddress"
        case emailStatus = "EmailStatus"
        case inviteId = "InviteId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let emailStatus = emailStatus {
            try encodeContainer.encode(emailStatus.rawValue, forKey: .emailStatus)
        }
        if let inviteId = inviteId {
            try encodeContainer.encode(inviteId, forKey: .inviteId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inviteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inviteId)
        inviteId = inviteIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.InviteStatus.self, forKey: .status)
        status = statusDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let emailStatusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EmailStatus.self, forKey: .emailStatus)
        emailStatus = emailStatusDecoded
    }
}

extension ChimeClientTypes.Invite: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Invite(emailAddress: \(Swift.String(describing: emailAddress)), emailStatus: \(Swift.String(describing: emailStatus)), inviteId: \(Swift.String(describing: inviteId)), status: \(Swift.String(describing: status)))"}
}

extension ChimeClientTypes {
    /// Invitation object returned after emailing users to invite them to join the Amazon Chime
    ///                 Team account.
    public struct Invite: Swift.Equatable {
        /// The email address to which the invite is sent.
        public var emailAddress: Swift.String?
        /// The status of the invite email.
        public var emailStatus: ChimeClientTypes.EmailStatus?
        /// The invite ID.
        public var inviteId: Swift.String?
        /// The status of the invite.
        public var status: ChimeClientTypes.InviteStatus?

        public init (
            emailAddress: Swift.String? = nil,
            emailStatus: ChimeClientTypes.EmailStatus? = nil,
            inviteId: Swift.String? = nil,
            status: ChimeClientTypes.InviteStatus? = nil
        )
        {
            self.emailAddress = emailAddress
            self.emailStatus = emailStatus
            self.inviteId = inviteId
            self.status = status
        }
    }

}

extension ChimeClientTypes {
    public enum InviteStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accepted
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [InviteStatus] {
            return [
                .accepted,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "Accepted"
            case .failed: return "Failed"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InviteStatus(rawValue: rawValue) ?? InviteStatus.sdkUnknown(rawValue)
        }
    }
}

public struct InviteUsersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InviteUsersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InviteUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InviteUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InviteUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InviteUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InviteUsersOutputError>
}

extension InviteUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InviteUsersInput(accountId: \(Swift.String(describing: accountId)), userEmailList: \(Swift.String(describing: userEmailList)), userType: \(Swift.String(describing: userType)))"}
}

extension InviteUsersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userEmailList = "UserEmailList"
        case userType = "UserType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userEmailList = userEmailList {
            var userEmailListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userEmailList)
            for useremaillist0 in userEmailList {
                try userEmailListContainer.encode(useremaillist0)
            }
        }
        if let userType = userType {
            try encodeContainer.encode(userType.rawValue, forKey: .userType)
        }
    }
}

public struct InviteUsersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InviteUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InviteUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InviteUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InviteUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InviteUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InviteUsersOutputError>
}

public struct InviteUsersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InviteUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InviteUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InviteUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "add"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InviteUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InviteUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InviteUsersOutputError>
}

public struct InviteUsersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InviteUsersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: InviteUsersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InviteUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = InviteUsersInput
    public typealias MOutput = ClientRuntime.OperationOutput<InviteUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InviteUsersOutputError>
}

public struct InviteUsersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InviteUsersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: InviteUsersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InviteUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/users"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = InviteUsersInput
    public typealias MOutput = ClientRuntime.OperationOutput<InviteUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InviteUsersOutputError>
}

public struct InviteUsersInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user email addresses to which to send the email invitation.
    /// This member is required.
    public var userEmailList: [Swift.String]?
    /// The user type.
    public var userType: ChimeClientTypes.UserType?

    public init (
        accountId: Swift.String? = nil,
        userEmailList: [Swift.String]? = nil,
        userType: ChimeClientTypes.UserType? = nil
    )
    {
        self.accountId = accountId
        self.userEmailList = userEmailList
        self.userType = userType
    }
}

struct InviteUsersInputBody: Swift.Equatable {
    public let userEmailList: [Swift.String]?
    public let userType: ChimeClientTypes.UserType?
}

extension InviteUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userEmailList = "UserEmailList"
        case userType = "UserType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userEmailListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userEmailList)
        var userEmailListDecoded0:[Swift.String]? = nil
        if let userEmailListContainer = userEmailListContainer {
            userEmailListDecoded0 = [Swift.String]()
            for string0 in userEmailListContainer {
                if let string0 = string0 {
                    userEmailListDecoded0?.append(string0)
                }
            }
        }
        userEmailList = userEmailListDecoded0
        let userTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.UserType.self, forKey: .userType)
        userType = userTypeDecoded
    }
}

extension InviteUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InviteUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InviteUsersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InviteUsersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InviteUsersOutputResponse(invites: \(Swift.String(describing: invites)))"}
}

extension InviteUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InviteUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invites = output.invites
        } else {
            self.invites = nil
        }
    }
}

public struct InviteUsersOutputResponse: Swift.Equatable {
    /// The email invitation details.
    public var invites: [ChimeClientTypes.Invite]?

    public init (
        invites: [ChimeClientTypes.Invite]? = nil
    )
    {
        self.invites = invites
    }
}

struct InviteUsersOutputResponseBody: Swift.Equatable {
    public let invites: [ChimeClientTypes.Invite]?
}

extension InviteUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invites = "Invites"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Invite?].self, forKey: .invites)
        var invitesDecoded0:[ChimeClientTypes.Invite]? = nil
        if let invitesContainer = invitesContainer {
            invitesDecoded0 = [ChimeClientTypes.Invite]()
            for structure0 in invitesContainer {
                if let structure0 = structure0 {
                    invitesDecoded0?.append(structure0)
                }
            }
        }
        invites = invitesDecoded0
    }
}

extension ChimeClientTypes {
    public enum License: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case plus
        case pro
        case protrial
        case sdkUnknown(Swift.String)

        public static var allCases: [License] {
            return [
                .basic,
                .plus,
                .pro,
                .protrial,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "Basic"
            case .plus: return "Plus"
            case .pro: return "Pro"
            case .protrial: return "ProTrial"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = License(rawValue: rawValue) ?? License.sdkUnknown(rawValue)
        }
    }
}

extension ListAccountsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAccountsInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), userEmail: \(Swift.String(describing: userEmail)))"}
}

extension ListAccountsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAccountsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccountsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAccountsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAccountsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccountsOutputError>
}

public struct ListAccountsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccountsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAccountsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let userEmail = input.operationInput.userEmail {
            let userEmailQueryItem = ClientRuntime.URLQueryItem(name: "user-email".urlPercentEncoding(), value: Swift.String(userEmail).urlPercentEncoding())
            input.builder.withQueryItem(userEmailQueryItem)
        }
        if let name = input.operationInput.name {
            let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            input.builder.withQueryItem(nameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAccountsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccountsOutputError>
}

public struct ListAccountsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccountsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAccountsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAccountsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccountsOutputError>
}

public struct ListAccountsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccountsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAccountsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/accounts"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAccountsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccountsOutputError>
}

public struct ListAccountsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// Amazon Chime account name prefix with which to filter results.
    public var name: Swift.String?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// User email address with which to filter results.
    public var userEmail: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        userEmail: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.userEmail = userEmail
    }
}

struct ListAccountsInputBody: Swift.Equatable {
}

extension ListAccountsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccountsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAccountsOutputResponse(accounts: \(Swift.String(describing: accounts)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accounts = output.accounts
            self.nextToken = output.nextToken
        } else {
            self.accounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountsOutputResponse: Swift.Equatable {
    /// List of Amazon Chime accounts and account details.
    public var accounts: [ChimeClientTypes.Account]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        accounts: [ChimeClientTypes.Account]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accounts = accounts
        self.nextToken = nextToken
    }
}

struct ListAccountsOutputResponseBody: Swift.Equatable {
    public let accounts: [ChimeClientTypes.Account]?
    public let nextToken: Swift.String?
}

extension ListAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts = "Accounts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Account?].self, forKey: .accounts)
        var accountsDecoded0:[ChimeClientTypes.Account]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [ChimeClientTypes.Account]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppInstanceAdminsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceAdminsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppInstanceAdminsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAppInstanceAdminsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceAdminsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppInstanceAdminsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppInstanceAdminsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceAdminsOutputError>
}

public struct ListAppInstanceAdminsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceAdminsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppInstanceAdminsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppInstanceAdminsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceAdminsOutputError>
}

public struct ListAppInstanceAdminsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceAdminsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAppInstanceAdminsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppInstanceAdminsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceAdminsOutputError>
}

public struct ListAppInstanceAdminsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceAdminsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAppInstanceAdminsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppInstanceAdminsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceAdminsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceAdminsOutputError>
}

public struct ListAppInstanceAdminsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The maximum number of administrators that you want to return.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of administrators is reached.
    public var nextToken: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstanceAdminsInputBody: Swift.Equatable {
}

extension ListAppInstanceAdminsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstanceAdminsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppInstanceAdminsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppInstanceAdminsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppInstanceAdminsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceAdminsOutputResponse(appInstanceAdmins: \(Swift.String(describing: appInstanceAdmins)), appInstanceArn: \(Swift.String(describing: appInstanceArn)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppInstanceAdminsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppInstanceAdminsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceAdmins = output.appInstanceAdmins
            self.appInstanceArn = output.appInstanceArn
            self.nextToken = output.nextToken
        } else {
            self.appInstanceAdmins = nil
            self.appInstanceArn = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstanceAdminsOutputResponse: Swift.Equatable {
    /// The information for each administrator.
    public var appInstanceAdmins: [ChimeClientTypes.AppInstanceAdminSummary]?
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?
    /// The token returned from previous API requests until the number of administrators is reached.
    public var nextToken: Swift.String?

    public init (
        appInstanceAdmins: [ChimeClientTypes.AppInstanceAdminSummary]? = nil,
        appInstanceArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceAdmins = appInstanceAdmins
        self.appInstanceArn = appInstanceArn
        self.nextToken = nextToken
    }
}

struct ListAppInstanceAdminsOutputResponseBody: Swift.Equatable {
    public let appInstanceArn: Swift.String?
    public let appInstanceAdmins: [ChimeClientTypes.AppInstanceAdminSummary]?
    public let nextToken: Swift.String?
}

extension ListAppInstanceAdminsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdmins = "AppInstanceAdmins"
        case appInstanceArn = "AppInstanceArn"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceAdminsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.AppInstanceAdminSummary?].self, forKey: .appInstanceAdmins)
        var appInstanceAdminsDecoded0:[ChimeClientTypes.AppInstanceAdminSummary]? = nil
        if let appInstanceAdminsContainer = appInstanceAdminsContainer {
            appInstanceAdminsDecoded0 = [ChimeClientTypes.AppInstanceAdminSummary]()
            for structure0 in appInstanceAdminsContainer {
                if let structure0 = structure0 {
                    appInstanceAdminsDecoded0?.append(structure0)
                }
            }
        }
        appInstanceAdmins = appInstanceAdminsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppInstanceUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceUsersInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppInstanceUsersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAppInstanceUsersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppInstanceUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppInstanceUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceUsersOutputError>
}

public struct ListAppInstanceUsersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppInstanceUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let appInstanceArn = input.operationInput.appInstanceArn {
            let appInstanceArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
            input.builder.withQueryItem(appInstanceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppInstanceUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceUsersOutputError>
}

public struct ListAppInstanceUsersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceUsersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAppInstanceUsersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppInstanceUsersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceUsersOutputError>
}

public struct ListAppInstanceUsersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstanceUsersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAppInstanceUsersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/app-instance-users"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppInstanceUsersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstanceUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstanceUsersOutputError>
}

public struct ListAppInstanceUsersInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The maximum number of requests that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUsersInputBody: Swift.Equatable {
}

extension ListAppInstanceUsersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstanceUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppInstanceUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppInstanceUsersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppInstanceUsersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceUsersOutputResponse(appInstanceArn: \(Swift.String(describing: appInstanceArn)), appInstanceUsers: \(Swift.String(describing: appInstanceUsers)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppInstanceUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppInstanceUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
            self.appInstanceUsers = output.appInstanceUsers
            self.nextToken = output.nextToken
        } else {
            self.appInstanceArn = nil
            self.appInstanceUsers = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstanceUsersOutputResponse: Swift.Equatable {
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?
    /// The information for each requested AppInstanceUser.
    public var appInstanceUsers: [ChimeClientTypes.AppInstanceUserSummary]?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil,
        appInstanceUsers: [ChimeClientTypes.AppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceUsers = appInstanceUsers
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUsersOutputResponseBody: Swift.Equatable {
    public let appInstanceArn: Swift.String?
    public let appInstanceUsers: [ChimeClientTypes.AppInstanceUserSummary]?
    public let nextToken: Swift.String?
}

extension ListAppInstanceUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceUsers = "AppInstanceUsers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceUsersContainer = try containerValues.decodeIfPresent([ChimeClientTypes.AppInstanceUserSummary?].self, forKey: .appInstanceUsers)
        var appInstanceUsersDecoded0:[ChimeClientTypes.AppInstanceUserSummary]? = nil
        if let appInstanceUsersContainer = appInstanceUsersContainer {
            appInstanceUsersDecoded0 = [ChimeClientTypes.AppInstanceUserSummary]()
            for structure0 in appInstanceUsersContainer {
                if let structure0 = structure0 {
                    appInstanceUsersDecoded0?.append(structure0)
                }
            }
        }
        appInstanceUsers = appInstanceUsersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstancesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppInstancesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAppInstancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstancesOutputError>
}

public struct ListAppInstancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAppInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAppInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstancesOutputError>
}

public struct ListAppInstancesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstancesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAppInstancesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppInstancesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstancesOutputError>
}

public struct ListAppInstancesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAppInstancesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAppInstancesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/app-instances"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAppInstancesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAppInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAppInstancesOutputError>
}

public struct ListAppInstancesInput: Swift.Equatable {
    /// The maximum number of AppInstances that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API requests until you reach the maximum number of AppInstances.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstancesInputBody: Swift.Equatable {
}

extension ListAppInstancesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppInstancesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppInstancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstancesOutputResponse(appInstances: \(Swift.String(describing: appInstances)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAppInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstances = output.appInstances
            self.nextToken = output.nextToken
        } else {
            self.appInstances = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstancesOutputResponse: Swift.Equatable {
    /// The information for each AppInstance.
    public var appInstances: [ChimeClientTypes.AppInstanceSummary]?
    /// The token passed by previous API requests until the maximum number of AppInstances is reached.
    public var nextToken: Swift.String?

    public init (
        appInstances: [ChimeClientTypes.AppInstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstances = appInstances
        self.nextToken = nextToken
    }
}

struct ListAppInstancesOutputResponseBody: Swift.Equatable {
    public let appInstances: [ChimeClientTypes.AppInstanceSummary]?
    public let nextToken: Swift.String?
}

extension ListAppInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstances = "AppInstances"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstancesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.AppInstanceSummary?].self, forKey: .appInstances)
        var appInstancesDecoded0:[ChimeClientTypes.AppInstanceSummary]? = nil
        if let appInstancesContainer = appInstancesContainer {
            appInstancesDecoded0 = [ChimeClientTypes.AppInstanceSummary]()
            for structure0 in appInstancesContainer {
                if let structure0 = structure0 {
                    appInstancesDecoded0?.append(structure0)
                }
            }
        }
        appInstances = appInstancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAttendeeTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAttendeeTagsInput(attendeeId: \(Swift.String(describing: attendeeId)), meetingId: \(Swift.String(describing: meetingId)))"}
}

extension ListAttendeeTagsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAttendeeTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttendeeTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAttendeeTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttendeeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAttendeeTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttendeeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttendeeTagsOutputError>
}

public struct ListAttendeeTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttendeeTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAttendeeTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttendeeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAttendeeTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttendeeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttendeeTagsOutputError>
}

public struct ListAttendeeTagsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttendeeTagsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAttendeeTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttendeeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAttendeeTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttendeeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttendeeTagsOutputError>
}

public struct ListAttendeeTagsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttendeeTagsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAttendeeTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttendeeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        guard let attendeeId = input.attendeeId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("attendeeId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())/tags"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAttendeeTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttendeeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttendeeTagsOutputError>
}

public struct ListAttendeeTagsInput: Swift.Equatable {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init (
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
    }
}

struct ListAttendeeTagsInputBody: Swift.Equatable {
}

extension ListAttendeeTagsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAttendeeTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAttendeeTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAttendeeTagsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttendeeTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAttendeeTagsOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListAttendeeTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAttendeeTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListAttendeeTagsOutputResponse: Swift.Equatable {
    /// A list of tag key-value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init (
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListAttendeeTagsOutputResponseBody: Swift.Equatable {
    public let tags: [ChimeClientTypes.Tag]?
}

extension ListAttendeeTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListAttendeesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAttendeesInput(maxResults: \(Swift.String(describing: maxResults)), meetingId: \(Swift.String(describing: meetingId)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAttendeesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAttendeesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttendeesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAttendeesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttendeesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAttendeesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttendeesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttendeesOutputError>
}

public struct ListAttendeesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttendeesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAttendeesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttendeesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAttendeesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttendeesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttendeesOutputError>
}

public struct ListAttendeesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttendeesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAttendeesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttendeesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAttendeesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttendeesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttendeesOutputError>
}

public struct ListAttendeesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAttendeesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAttendeesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAttendeesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())/attendees"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAttendeesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAttendeesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAttendeesOutputError>
}

public struct ListAttendeesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        meetingId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.meetingId = meetingId
        self.nextToken = nextToken
    }
}

struct ListAttendeesInputBody: Swift.Equatable {
}

extension ListAttendeesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAttendeesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAttendeesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAttendeesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttendeesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAttendeesOutputResponse(attendees: \(Swift.String(describing: attendees)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAttendeesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAttendeesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attendees = output.attendees
            self.nextToken = output.nextToken
        } else {
            self.attendees = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttendeesOutputResponse: Swift.Equatable {
    /// The Amazon Chime SDK attendee information.
    public var attendees: [ChimeClientTypes.Attendee]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        attendees: [ChimeClientTypes.Attendee]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attendees = attendees
        self.nextToken = nextToken
    }
}

struct ListAttendeesOutputResponseBody: Swift.Equatable {
    public let attendees: [ChimeClientTypes.Attendee]?
    public let nextToken: Swift.String?
}

extension ListAttendeesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Attendee?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeClientTypes.Attendee]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeClientTypes.Attendee]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBotsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBotsInput(accountId: \(Swift.String(describing: accountId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBotsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListBotsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBotsOutputError>
}

public struct ListBotsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBotsOutputError>
}

public struct ListBotsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBotsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListBotsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBotsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBotsOutputError>
}

public struct ListBotsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBotsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListBotsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/bots"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBotsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBotsOutputError>
}

public struct ListBotsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call. The default is 10.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBotsInputBody: Swift.Equatable {
}

extension ListBotsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBotsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBotsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBotsOutputResponse(bots: \(Swift.String(describing: bots)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bots = output.bots
            self.nextToken = output.nextToken
        } else {
            self.bots = nil
            self.nextToken = nil
        }
    }
}

public struct ListBotsOutputResponse: Swift.Equatable {
    /// List of bots and bot details.
    public var bots: [ChimeClientTypes.Bot]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        bots: [ChimeClientTypes.Bot]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bots = bots
        self.nextToken = nextToken
    }
}

struct ListBotsOutputResponseBody: Swift.Equatable {
    public let bots: [ChimeClientTypes.Bot]?
    public let nextToken: Swift.String?
}

extension ListBotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bots = "Bots"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Bot?].self, forKey: .bots)
        var botsDecoded0:[ChimeClientTypes.Bot]? = nil
        if let botsContainer = botsContainer {
            botsDecoded0 = [ChimeClientTypes.Bot]()
            for structure0 in botsContainer {
                if let structure0 = structure0 {
                    botsDecoded0?.append(structure0)
                }
            }
        }
        bots = botsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelBansInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelBansInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelBansInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelBansInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelBansInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelBansInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelBansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelBansInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelBansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelBansOutputError>
}

public struct ListChannelBansInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelBansInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelBansInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelBansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelBansInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelBansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelBansOutputError>
}

public struct ListChannelBansInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelBansInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChannelBansInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelBansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelBansInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelBansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelBansOutputError>
}

public struct ListChannelBansInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelBansInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChannelBansInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelBansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/bans"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelBansInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelBansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelBansOutputError>
}

public struct ListChannelBansInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of bans that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested bans are returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelBansInputBody: Swift.Equatable {
}

extension ListChannelBansInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelBansOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelBansOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelBansOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelBansOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelBansOutputResponse(channelArn: \(Swift.String(describing: channelArn)), channelBans: \(Swift.String(describing: channelBans)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelBansOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelBansOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelBans = output.channelBans
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelBans = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelBansOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information for each requested ban.
    public var channelBans: [ChimeClientTypes.ChannelBanSummary]?
    /// The token passed by previous API calls until all requested bans are returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelBans: [ChimeClientTypes.ChannelBanSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelBans = channelBans
        self.nextToken = nextToken
    }
}

struct ListChannelBansOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let nextToken: Swift.String?
    public let channelBans: [ChimeClientTypes.ChannelBanSummary]?
}

extension ListChannelBansOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelBans = "ChannelBans"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelBansContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ChannelBanSummary?].self, forKey: .channelBans)
        var channelBansDecoded0:[ChimeClientTypes.ChannelBanSummary]? = nil
        if let channelBansContainer = channelBansContainer {
            channelBansDecoded0 = [ChimeClientTypes.ChannelBanSummary]()
            for structure0 in channelBansContainer {
                if let structure0 = structure0 {
                    channelBansDecoded0?.append(structure0)
                }
            }
        }
        channelBans = channelBansDecoded0
    }
}

extension ListChannelMembershipsForAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsForAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelMembershipsForAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelMembershipsForAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsForAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelMembershipsForAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelMembershipsForAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsForAppInstanceUserOutputError>
}

public struct ListChannelMembershipsForAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsForAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelMembershipsForAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-memberships"))
        if let appInstanceUserArn = input.operationInput.appInstanceUserArn {
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            input.builder.withQueryItem(appInstanceUserArnQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelMembershipsForAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsForAppInstanceUserOutputError>
}

public struct ListChannelMembershipsForAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsForAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChannelMembershipsForAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelMembershipsForAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsForAppInstanceUserOutputError>
}

public struct ListChannelMembershipsForAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsForAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChannelMembershipsForAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/channels"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelMembershipsForAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsForAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsForAppInstanceUserOutputError>
}

public struct ListChannelMembershipsForAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUsers
    public var appInstanceUserArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of users that you want returned.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channel memberships is reached.
    public var nextToken: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelMembershipsForAppInstanceUserInputBody: Swift.Equatable {
}

extension ListChannelMembershipsForAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelMembershipsForAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelMembershipsForAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelMembershipsForAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelMembershipsForAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsForAppInstanceUserOutputResponse(channelMemberships: \(Swift.String(describing: channelMemberships)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelMembershipsForAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelMembershipsForAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMemberships = output.channelMemberships
            self.nextToken = output.nextToken
        } else {
            self.channelMemberships = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelMembershipsForAppInstanceUserOutputResponse: Swift.Equatable {
    /// The token passed by previous API calls until all requested users are returned.
    public var channelMemberships: [ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary]?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init (
        channelMemberships: [ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelMemberships = channelMemberships
        self.nextToken = nextToken
    }
}

struct ListChannelMembershipsForAppInstanceUserOutputResponseBody: Swift.Equatable {
    public let channelMemberships: [ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary]?
    public let nextToken: Swift.String?
}

extension ListChannelMembershipsForAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMemberships = "ChannelMemberships"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMembershipsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary?].self, forKey: .channelMemberships)
        var channelMembershipsDecoded0:[ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary]? = nil
        if let channelMembershipsContainer = channelMembershipsContainer {
            channelMembershipsDecoded0 = [ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary]()
            for structure0 in channelMembershipsContainer {
                if let structure0 = structure0 {
                    channelMembershipsDecoded0?.append(structure0)
                }
            }
        }
        channelMemberships = channelMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelMembershipsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), type: \(Swift.String(describing: type)))"}
}

extension ListChannelMembershipsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelMembershipsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelMembershipsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelMembershipsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsOutputError>
}

public struct ListChannelMembershipsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelMembershipsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let type = input.operationInput.type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelMembershipsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsOutputError>
}

public struct ListChannelMembershipsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChannelMembershipsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelMembershipsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsOutputError>
}

public struct ListChannelMembershipsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMembershipsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChannelMembershipsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/memberships"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelMembershipsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMembershipsOutputError>
}

public struct ListChannelMembershipsInput: Swift.Equatable {
    /// The maximum number of channel memberships that you want returned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of channel memberships that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channel memberships are
    ///          returned.
    public var nextToken: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default
    ///          members are always returned as part of ListChannelMemberships. Hidden members
    ///          are only returned if the type filter in ListChannelMemberships equals
    ///             HIDDEN. Otherwise hidden members are not returned.
    public var type: ChimeClientTypes.ChannelMembershipType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: ChimeClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListChannelMembershipsInputBody: Swift.Equatable {
}

extension ListChannelMembershipsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelMembershipsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelMembershipsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelMembershipsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelMembershipsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsOutputResponse(channelArn: \(Swift.String(describing: channelArn)), channelMemberships: \(Swift.String(describing: channelMemberships)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelMembershipsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelMembershipsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelMemberships = output.channelMemberships
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelMemberships = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelMembershipsOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information for the requested channel memberships.
    public var channelMemberships: [ChimeClientTypes.ChannelMembershipSummary]?
    /// The token passed by previous API calls until all requested channel memberships are
    ///          returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelMemberships: [ChimeClientTypes.ChannelMembershipSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelMemberships = channelMemberships
        self.nextToken = nextToken
    }
}

struct ListChannelMembershipsOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let channelMemberships: [ChimeClientTypes.ChannelMembershipSummary]?
    public let nextToken: Swift.String?
}

extension ListChannelMembershipsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelMemberships = "ChannelMemberships"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let channelMembershipsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ChannelMembershipSummary?].self, forKey: .channelMemberships)
        var channelMembershipsDecoded0:[ChimeClientTypes.ChannelMembershipSummary]? = nil
        if let channelMembershipsContainer = channelMembershipsContainer {
            channelMembershipsDecoded0 = [ChimeClientTypes.ChannelMembershipSummary]()
            for structure0 in channelMembershipsContainer {
                if let structure0 = structure0 {
                    channelMembershipsDecoded0?.append(structure0)
                }
            }
        }
        channelMemberships = channelMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelMessagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMessagesInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), notAfter: \(Swift.String(describing: notAfter)), notBefore: \(Swift.String(describing: notBefore)), sortOrder: \(Swift.String(describing: sortOrder)))"}
}

extension ListChannelMessagesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelMessagesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMessagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelMessagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelMessagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMessagesOutputError>
}

public struct ListChannelMessagesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMessagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelMessagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let sortOrder = input.operationInput.sortOrder {
            let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "sort-order".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(sortOrderQueryItem)
        }
        if let notBefore = input.operationInput.notBefore {
            let notBeforeQueryItem = ClientRuntime.URLQueryItem(name: "not-before".urlPercentEncoding(), value: Swift.String(notBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(notBeforeQueryItem)
        }
        if let notAfter = input.operationInput.notAfter {
            let notAfterQueryItem = ClientRuntime.URLQueryItem(name: "not-after".urlPercentEncoding(), value: Swift.String(notAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(notAfterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelMessagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMessagesOutputError>
}

public struct ListChannelMessagesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMessagesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChannelMessagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelMessagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMessagesOutputError>
}

public struct ListChannelMessagesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelMessagesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChannelMessagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/messages"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelMessagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelMessagesOutputError>
}

public struct ListChannelMessagesInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of messages that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested messages are returned.
    public var nextToken: Swift.String?
    /// The final or ending time stamp for your requested messages.
    public var notAfter: ClientRuntime.Date?
    /// The initial or starting time stamp for your requested messages.
    public var notBefore: ClientRuntime.Date?
    /// The order in which you want messages sorted. Default is Descending, based on time
    ///          created.
    public var sortOrder: ChimeClientTypes.SortOrder?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notAfter: ClientRuntime.Date? = nil,
        notBefore: ClientRuntime.Date? = nil,
        sortOrder: ChimeClientTypes.SortOrder? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notAfter = notAfter
        self.notBefore = notBefore
        self.sortOrder = sortOrder
    }
}

struct ListChannelMessagesInputBody: Swift.Equatable {
}

extension ListChannelMessagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelMessagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelMessagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelMessagesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelMessagesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMessagesOutputResponse(channelArn: \(Swift.String(describing: channelArn)), channelMessages: \(Swift.String(describing: channelMessages)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelMessagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelMessagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelMessages = output.channelMessages
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelMessages = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelMessagesOutputResponse: Swift.Equatable {
    /// The ARN of the channel containing the requested messages.
    public var channelArn: Swift.String?
    /// The information about, and content of, each requested message.
    public var channelMessages: [ChimeClientTypes.ChannelMessageSummary]?
    /// The token passed by previous API calls until all requested messages are returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelMessages: [ChimeClientTypes.ChannelMessageSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelMessages = channelMessages
        self.nextToken = nextToken
    }
}

struct ListChannelMessagesOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let nextToken: Swift.String?
    public let channelMessages: [ChimeClientTypes.ChannelMessageSummary]?
}

extension ListChannelMessagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelMessages = "ChannelMessages"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelMessagesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ChannelMessageSummary?].self, forKey: .channelMessages)
        var channelMessagesDecoded0:[ChimeClientTypes.ChannelMessageSummary]? = nil
        if let channelMessagesContainer = channelMessagesContainer {
            channelMessagesDecoded0 = [ChimeClientTypes.ChannelMessageSummary]()
            for structure0 in channelMessagesContainer {
                if let structure0 = structure0 {
                    channelMessagesDecoded0?.append(structure0)
                }
            }
        }
        channelMessages = channelMessagesDecoded0
    }
}

extension ListChannelModeratorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelModeratorsInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelModeratorsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelModeratorsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelModeratorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelModeratorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelModeratorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelModeratorsOutputError>
}

public struct ListChannelModeratorsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelModeratorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelModeratorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelModeratorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelModeratorsOutputError>
}

public struct ListChannelModeratorsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelModeratorsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChannelModeratorsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelModeratorsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelModeratorsOutputError>
}

public struct ListChannelModeratorsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelModeratorsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChannelModeratorsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/moderators"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelModeratorsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelModeratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelModeratorsOutputError>
}

public struct ListChannelModeratorsInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of moderators that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested moderators are
    ///          returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelModeratorsInputBody: Swift.Equatable {
}

extension ListChannelModeratorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelModeratorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelModeratorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelModeratorsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelModeratorsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelModeratorsOutputResponse(channelArn: \(Swift.String(describing: channelArn)), channelModerators: \(Swift.String(describing: channelModerators)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelModeratorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelModeratorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelModerators = output.channelModerators
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelModerators = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelModeratorsOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information about and names of each moderator.
    public var channelModerators: [ChimeClientTypes.ChannelModeratorSummary]?
    /// The token passed by previous API calls until all requested moderators are
    ///          returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModerators: [ChimeClientTypes.ChannelModeratorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModerators = channelModerators
        self.nextToken = nextToken
    }
}

struct ListChannelModeratorsOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let nextToken: Swift.String?
    public let channelModerators: [ChimeClientTypes.ChannelModeratorSummary]?
}

extension ListChannelModeratorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelModerators = "ChannelModerators"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelModeratorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ChannelModeratorSummary?].self, forKey: .channelModerators)
        var channelModeratorsDecoded0:[ChimeClientTypes.ChannelModeratorSummary]? = nil
        if let channelModeratorsContainer = channelModeratorsContainer {
            channelModeratorsDecoded0 = [ChimeClientTypes.ChannelModeratorSummary]()
            for structure0 in channelModeratorsContainer {
                if let structure0 = structure0 {
                    channelModeratorsDecoded0?.append(structure0)
                }
            }
        }
        channelModerators = channelModeratorsDecoded0
    }
}

extension ListChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), privacy: \(Swift.String(describing: privacy)))"}
}

extension ListChannelsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let privacy = input.operationInput.privacy {
            let privacyQueryItem = ClientRuntime.URLQueryItem(name: "privacy".urlPercentEncoding(), value: Swift.String(privacy.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(privacyQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let appInstanceArn = input.operationInput.appInstanceArn {
            let appInstanceArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
            input.builder.withQueryItem(appInstanceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChannelsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChannelsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/channels"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of channels that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channels are returned.
    public var nextToken: Swift.String?
    /// The privacy setting. PUBLIC retrieves all the public channels.
    ///             PRIVATE retrieves private channels. Only an AppInstanceAdmin
    ///          can retrieve private channels.
    public var privacy: ChimeClientTypes.ChannelPrivacy?

    public init (
        appInstanceArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        privacy: ChimeClientTypes.ChannelPrivacy? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.privacy = privacy
    }
}

struct ListChannelsInputBody: Swift.Equatable {
}

extension ListChannelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsModeratedByAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsModeratedByAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelsModeratedByAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelsModeratedByAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsModeratedByAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsModeratedByAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsModeratedByAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsModeratedByAppInstanceUserOutputError>
}

public struct ListChannelsModeratedByAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsModeratedByAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsModeratedByAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-moderated-channels"))
        if let appInstanceUserArn = input.operationInput.appInstanceUserArn {
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            input.builder.withQueryItem(appInstanceUserArnQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsModeratedByAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsModeratedByAppInstanceUserOutputError>
}

public struct ListChannelsModeratedByAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsModeratedByAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChannelsModeratedByAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelsModeratedByAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsModeratedByAppInstanceUserOutputError>
}

public struct ListChannelsModeratedByAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsModeratedByAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChannelsModeratedByAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/channels"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelsModeratedByAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsModeratedByAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsModeratedByAppInstanceUserOutputError>
}

public struct ListChannelsModeratedByAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the user in the moderated channel.
    public var appInstanceUserArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of channels in the request.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channels moderated by
    ///          the user is reached.
    public var nextToken: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsModeratedByAppInstanceUserInputBody: Swift.Equatable {
}

extension ListChannelsModeratedByAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsModeratedByAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsModeratedByAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelsModeratedByAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsModeratedByAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsModeratedByAppInstanceUserOutputResponse(channels: \(Swift.String(describing: channels)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelsModeratedByAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelsModeratedByAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsModeratedByAppInstanceUserOutputResponse: Swift.Equatable {
    /// The moderated channels in the request.
    public var channels: [ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary]?
    /// The token returned from previous API requests until the number of channels moderated by
    ///          the user is reached.
    public var nextToken: Swift.String?

    public init (
        channels: [ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsModeratedByAppInstanceUserOutputResponseBody: Swift.Equatable {
    public let channels: [ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary]?
    public let nextToken: Swift.String?
}

extension ListChannelsModeratedByAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary?].self, forKey: .channels)
        var channelsDecoded0:[ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsOutputResponse(channels: \(Swift.String(describing: channels)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Swift.Equatable {
    /// The information about each channel.
    public var channels: [ChimeClientTypes.ChannelSummary]?
    /// The token returned from previous API requests until the number of channels is
    ///          reached.
    public var nextToken: Swift.String?

    public init (
        channels: [ChimeClientTypes.ChannelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Swift.Equatable {
    public let channels: [ChimeClientTypes.ChannelSummary]?
    public let nextToken: Swift.String?
}

extension ListChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ChannelSummary?].self, forKey: .channels)
        var channelsDecoded0:[ChimeClientTypes.ChannelSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ChimeClientTypes.ChannelSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMediaCapturePipelinesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMediaCapturePipelinesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListMediaCapturePipelinesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListMediaCapturePipelinesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMediaCapturePipelinesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMediaCapturePipelinesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMediaCapturePipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMediaCapturePipelinesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMediaCapturePipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMediaCapturePipelinesOutputError>
}

public struct ListMediaCapturePipelinesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMediaCapturePipelinesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMediaCapturePipelinesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMediaCapturePipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMediaCapturePipelinesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMediaCapturePipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMediaCapturePipelinesOutputError>
}

public struct ListMediaCapturePipelinesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMediaCapturePipelinesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListMediaCapturePipelinesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMediaCapturePipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMediaCapturePipelinesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMediaCapturePipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMediaCapturePipelinesOutputError>
}

public struct ListMediaCapturePipelinesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMediaCapturePipelinesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListMediaCapturePipelinesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMediaCapturePipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/media-capture-pipelines"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMediaCapturePipelinesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMediaCapturePipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMediaCapturePipelinesOutputError>
}

public struct ListMediaCapturePipelinesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. Valid Range: 1 - 99.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMediaCapturePipelinesInputBody: Swift.Equatable {
}

extension ListMediaCapturePipelinesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMediaCapturePipelinesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMediaCapturePipelinesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMediaCapturePipelinesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMediaCapturePipelinesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMediaCapturePipelinesOutputResponse(mediaCapturePipelines: \(Swift.String(describing: mediaCapturePipelines)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListMediaCapturePipelinesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMediaCapturePipelinesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mediaCapturePipelines = output.mediaCapturePipelines
            self.nextToken = output.nextToken
        } else {
            self.mediaCapturePipelines = nil
            self.nextToken = nil
        }
    }
}

public struct ListMediaCapturePipelinesOutputResponse: Swift.Equatable {
    /// The media capture pipeline objects in the list.
    public var mediaCapturePipelines: [ChimeClientTypes.MediaCapturePipeline]?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        mediaCapturePipelines: [ChimeClientTypes.MediaCapturePipeline]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mediaCapturePipelines = mediaCapturePipelines
        self.nextToken = nextToken
    }
}

struct ListMediaCapturePipelinesOutputResponseBody: Swift.Equatable {
    public let mediaCapturePipelines: [ChimeClientTypes.MediaCapturePipeline]?
    public let nextToken: Swift.String?
}

extension ListMediaCapturePipelinesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipelines = "MediaCapturePipelines"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelinesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.MediaCapturePipeline?].self, forKey: .mediaCapturePipelines)
        var mediaCapturePipelinesDecoded0:[ChimeClientTypes.MediaCapturePipeline]? = nil
        if let mediaCapturePipelinesContainer = mediaCapturePipelinesContainer {
            mediaCapturePipelinesDecoded0 = [ChimeClientTypes.MediaCapturePipeline]()
            for structure0 in mediaCapturePipelinesContainer {
                if let structure0 = structure0 {
                    mediaCapturePipelinesDecoded0?.append(structure0)
                }
            }
        }
        mediaCapturePipelines = mediaCapturePipelinesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMeetingTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMeetingTagsInput(meetingId: \(Swift.String(describing: meetingId)))"}
}

extension ListMeetingTagsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListMeetingTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMeetingTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMeetingTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMeetingTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMeetingTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMeetingTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMeetingTagsOutputError>
}

public struct ListMeetingTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMeetingTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMeetingTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMeetingTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMeetingTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMeetingTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMeetingTagsOutputError>
}

public struct ListMeetingTagsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMeetingTagsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListMeetingTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMeetingTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMeetingTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMeetingTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMeetingTagsOutputError>
}

public struct ListMeetingTagsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMeetingTagsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListMeetingTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMeetingTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())/tags"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMeetingTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMeetingTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMeetingTagsOutputError>
}

public struct ListMeetingTagsInput: Swift.Equatable {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init (
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

struct ListMeetingTagsInputBody: Swift.Equatable {
}

extension ListMeetingTagsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMeetingTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMeetingTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMeetingTagsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMeetingTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMeetingTagsOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListMeetingTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMeetingTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListMeetingTagsOutputResponse: Swift.Equatable {
    /// A list of tag key-value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init (
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListMeetingTagsOutputResponseBody: Swift.Equatable {
    public let tags: [ChimeClientTypes.Tag]?
}

extension ListMeetingTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListMeetingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMeetingsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListMeetingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListMeetingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMeetingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMeetingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMeetingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMeetingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMeetingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMeetingsOutputError>
}

public struct ListMeetingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMeetingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMeetingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMeetingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMeetingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMeetingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMeetingsOutputError>
}

public struct ListMeetingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMeetingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListMeetingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMeetingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMeetingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMeetingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMeetingsOutputError>
}

public struct ListMeetingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMeetingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListMeetingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMeetingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/meetings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMeetingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMeetingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMeetingsOutputError>
}

public struct ListMeetingsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMeetingsInputBody: Swift.Equatable {
}

extension ListMeetingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMeetingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMeetingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMeetingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMeetingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMeetingsOutputResponse(meetings: \(Swift.String(describing: meetings)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListMeetingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMeetingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.meetings = output.meetings
            self.nextToken = output.nextToken
        } else {
            self.meetings = nil
            self.nextToken = nil
        }
    }
}

public struct ListMeetingsOutputResponse: Swift.Equatable {
    /// The Amazon Chime SDK meeting information.
    public var meetings: [ChimeClientTypes.Meeting]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        meetings: [ChimeClientTypes.Meeting]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.meetings = meetings
        self.nextToken = nextToken
    }
}

struct ListMeetingsOutputResponseBody: Swift.Equatable {
    public let meetings: [ChimeClientTypes.Meeting]?
    public let nextToken: Swift.String?
}

extension ListMeetingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meetings = "Meetings"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Meeting?].self, forKey: .meetings)
        var meetingsDecoded0:[ChimeClientTypes.Meeting]? = nil
        if let meetingsContainer = meetingsContainer {
            meetingsDecoded0 = [ChimeClientTypes.Meeting]()
            for structure0 in meetingsContainer {
                if let structure0 = structure0 {
                    meetingsDecoded0?.append(structure0)
                }
            }
        }
        meetings = meetingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPhoneNumberOrdersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPhoneNumberOrdersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPhoneNumberOrdersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPhoneNumberOrdersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPhoneNumberOrdersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPhoneNumberOrdersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPhoneNumberOrdersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPhoneNumberOrdersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPhoneNumberOrdersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPhoneNumberOrdersOutputError>
}

public struct ListPhoneNumberOrdersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPhoneNumberOrdersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPhoneNumberOrdersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPhoneNumberOrdersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPhoneNumberOrdersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPhoneNumberOrdersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPhoneNumberOrdersOutputError>
}

public struct ListPhoneNumberOrdersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPhoneNumberOrdersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListPhoneNumberOrdersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPhoneNumberOrdersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPhoneNumberOrdersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPhoneNumberOrdersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPhoneNumberOrdersOutputError>
}

public struct ListPhoneNumberOrdersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPhoneNumberOrdersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListPhoneNumberOrdersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPhoneNumberOrdersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/phone-number-orders"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPhoneNumberOrdersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPhoneNumberOrdersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPhoneNumberOrdersOutputError>
}

public struct ListPhoneNumberOrdersInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPhoneNumberOrdersInputBody: Swift.Equatable {
}

extension ListPhoneNumberOrdersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPhoneNumberOrdersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPhoneNumberOrdersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPhoneNumberOrdersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPhoneNumberOrdersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPhoneNumberOrdersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), phoneNumberOrders: \(Swift.String(describing: phoneNumberOrders)))"}
}

extension ListPhoneNumberOrdersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPhoneNumberOrdersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumberOrders = output.phoneNumberOrders
        } else {
            self.nextToken = nil
            self.phoneNumberOrders = nil
        }
    }
}

public struct ListPhoneNumberOrdersOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The phone number order details.
    public var phoneNumberOrders: [ChimeClientTypes.PhoneNumberOrder]?

    public init (
        nextToken: Swift.String? = nil,
        phoneNumberOrders: [ChimeClientTypes.PhoneNumberOrder]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumberOrders = phoneNumberOrders
    }
}

struct ListPhoneNumberOrdersOutputResponseBody: Swift.Equatable {
    public let phoneNumberOrders: [ChimeClientTypes.PhoneNumberOrder]?
    public let nextToken: Swift.String?
}

extension ListPhoneNumberOrdersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumberOrders = "PhoneNumberOrders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrdersContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberOrder?].self, forKey: .phoneNumberOrders)
        var phoneNumberOrdersDecoded0:[ChimeClientTypes.PhoneNumberOrder]? = nil
        if let phoneNumberOrdersContainer = phoneNumberOrdersContainer {
            phoneNumberOrdersDecoded0 = [ChimeClientTypes.PhoneNumberOrder]()
            for structure0 in phoneNumberOrdersContainer {
                if let structure0 = structure0 {
                    phoneNumberOrdersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberOrders = phoneNumberOrdersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPhoneNumbersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPhoneNumbersInput(filterName: \(Swift.String(describing: filterName)), filterValue: \(Swift.String(describing: filterValue)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), productType: \(Swift.String(describing: productType)), status: \(Swift.String(describing: status)))"}
}

extension ListPhoneNumbersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPhoneNumbersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPhoneNumbersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPhoneNumbersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPhoneNumbersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPhoneNumbersOutputError>
}

public struct ListPhoneNumbersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPhoneNumbersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPhoneNumbersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let status = input.operationInput.status {
            let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(statusQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let productType = input.operationInput.productType {
            let productTypeQueryItem = ClientRuntime.URLQueryItem(name: "product-type".urlPercentEncoding(), value: Swift.String(productType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(productTypeQueryItem)
        }
        if let filterName = input.operationInput.filterName {
            let filterNameQueryItem = ClientRuntime.URLQueryItem(name: "filter-name".urlPercentEncoding(), value: Swift.String(filterName.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(filterNameQueryItem)
        }
        if let filterValue = input.operationInput.filterValue {
            let filterValueQueryItem = ClientRuntime.URLQueryItem(name: "filter-value".urlPercentEncoding(), value: Swift.String(filterValue).urlPercentEncoding())
            input.builder.withQueryItem(filterValueQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPhoneNumbersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPhoneNumbersOutputError>
}

public struct ListPhoneNumbersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPhoneNumbersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListPhoneNumbersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPhoneNumbersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPhoneNumbersOutputError>
}

public struct ListPhoneNumbersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPhoneNumbersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListPhoneNumbersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/phone-numbers"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPhoneNumbersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPhoneNumbersOutputError>
}

public struct ListPhoneNumbersInput: Swift.Equatable {
    /// The filter to use to limit the number of results.
    public var filterName: ChimeClientTypes.PhoneNumberAssociationName?
    /// The value to use for the filter.
    public var filterValue: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The phone number product type.
    public var productType: ChimeClientTypes.PhoneNumberProductType?
    /// The phone number status.
    public var status: ChimeClientTypes.PhoneNumberStatus?

    public init (
        filterName: ChimeClientTypes.PhoneNumberAssociationName? = nil,
        filterValue: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        productType: ChimeClientTypes.PhoneNumberProductType? = nil,
        status: ChimeClientTypes.PhoneNumberStatus? = nil
    )
    {
        self.filterName = filterName
        self.filterValue = filterValue
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.productType = productType
        self.status = status
    }
}

struct ListPhoneNumbersInputBody: Swift.Equatable {
}

extension ListPhoneNumbersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPhoneNumbersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPhoneNumbersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPhoneNumbersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPhoneNumbersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPhoneNumbersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), phoneNumbers: \(Swift.String(describing: phoneNumbers)))"}
}

extension ListPhoneNumbersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPhoneNumbersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

public struct ListPhoneNumbersOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The phone number details.
    public var phoneNumbers: [ChimeClientTypes.PhoneNumber]?

    public init (
        nextToken: Swift.String? = nil,
        phoneNumbers: [ChimeClientTypes.PhoneNumber]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct ListPhoneNumbersOutputResponseBody: Swift.Equatable {
    public let phoneNumbers: [ChimeClientTypes.PhoneNumber]?
    public let nextToken: Swift.String?
}

extension ListPhoneNumbersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumbers = "PhoneNumbers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumbersContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[ChimeClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [ChimeClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProxySessionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProxySessionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), status: \(Swift.String(describing: status)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension ListProxySessionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListProxySessionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProxySessionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProxySessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProxySessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProxySessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProxySessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProxySessionsOutputError>
}

public struct ListProxySessionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProxySessionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProxySessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProxySessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let status = input.operationInput.status {
            let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(statusQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProxySessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProxySessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProxySessionsOutputError>
}

public struct ListProxySessionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProxySessionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListProxySessionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProxySessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProxySessionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProxySessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProxySessionsOutputError>
}

public struct ListProxySessionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProxySessionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListProxySessionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProxySessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProxySessionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProxySessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProxySessionsOutputError>
}

public struct ListProxySessionsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The proxy session status.
    public var status: ChimeClientTypes.ProxySessionStatus?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: ChimeClientTypes.ProxySessionStatus? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.voiceConnectorId = voiceConnectorId
    }
}

struct ListProxySessionsInputBody: Swift.Equatable {
}

extension ListProxySessionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProxySessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProxySessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProxySessionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProxySessionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProxySessionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), proxySessions: \(Swift.String(describing: proxySessions)))"}
}

extension ListProxySessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProxySessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.proxySessions = output.proxySessions
        } else {
            self.nextToken = nil
            self.proxySessions = nil
        }
    }
}

public struct ListProxySessionsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The proxy session details.
    public var proxySessions: [ChimeClientTypes.ProxySession]?

    public init (
        nextToken: Swift.String? = nil,
        proxySessions: [ChimeClientTypes.ProxySession]? = nil
    )
    {
        self.nextToken = nextToken
        self.proxySessions = proxySessions
    }
}

struct ListProxySessionsOutputResponseBody: Swift.Equatable {
    public let proxySessions: [ChimeClientTypes.ProxySession]?
    public let nextToken: Swift.String?
}

extension ListProxySessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case proxySessions = "ProxySessions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ProxySession?].self, forKey: .proxySessions)
        var proxySessionsDecoded0:[ChimeClientTypes.ProxySession]? = nil
        if let proxySessionsContainer = proxySessionsContainer {
            proxySessionsDecoded0 = [ChimeClientTypes.ProxySession]()
            for structure0 in proxySessionsContainer {
                if let structure0 = structure0 {
                    proxySessionsDecoded0?.append(structure0)
                }
            }
        }
        proxySessions = proxySessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRoomMembershipsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRoomMembershipsInput(accountId: \(Swift.String(describing: accountId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), roomId: \(Swift.String(describing: roomId)))"}
}

extension ListRoomMembershipsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRoomMembershipsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRoomMembershipsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRoomMembershipsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRoomMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRoomMembershipsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRoomMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRoomMembershipsOutputError>
}

public struct ListRoomMembershipsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRoomMembershipsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRoomMembershipsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRoomMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRoomMembershipsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRoomMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRoomMembershipsOutputError>
}

public struct ListRoomMembershipsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRoomMembershipsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListRoomMembershipsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRoomMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRoomMembershipsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRoomMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRoomMembershipsOutputError>
}

public struct ListRoomMembershipsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRoomMembershipsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListRoomMembershipsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRoomMembershipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let roomId = input.roomId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("roomId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/memberships"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRoomMembershipsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRoomMembershipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRoomMembershipsOutputError>
}

public struct ListRoomMembershipsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.roomId = roomId
    }
}

struct ListRoomMembershipsInputBody: Swift.Equatable {
}

extension ListRoomMembershipsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRoomMembershipsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRoomMembershipsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRoomMembershipsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRoomMembershipsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRoomMembershipsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), roomMemberships: \(Swift.String(describing: roomMemberships)))"}
}

extension ListRoomMembershipsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRoomMembershipsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.roomMemberships = output.roomMemberships
        } else {
            self.nextToken = nil
            self.roomMemberships = nil
        }
    }
}

public struct ListRoomMembershipsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The room membership details.
    public var roomMemberships: [ChimeClientTypes.RoomMembership]?

    public init (
        nextToken: Swift.String? = nil,
        roomMemberships: [ChimeClientTypes.RoomMembership]? = nil
    )
    {
        self.nextToken = nextToken
        self.roomMemberships = roomMemberships
    }
}

struct ListRoomMembershipsOutputResponseBody: Swift.Equatable {
    public let roomMemberships: [ChimeClientTypes.RoomMembership]?
    public let nextToken: Swift.String?
}

extension ListRoomMembershipsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case roomMemberships = "RoomMemberships"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomMembershipsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.RoomMembership?].self, forKey: .roomMemberships)
        var roomMembershipsDecoded0:[ChimeClientTypes.RoomMembership]? = nil
        if let roomMembershipsContainer = roomMembershipsContainer {
            roomMembershipsDecoded0 = [ChimeClientTypes.RoomMembership]()
            for structure0 in roomMembershipsContainer {
                if let structure0 = structure0 {
                    roomMembershipsDecoded0?.append(structure0)
                }
            }
        }
        roomMemberships = roomMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRoomsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRoomsInput(accountId: \(Swift.String(describing: accountId)), maxResults: \(Swift.String(describing: maxResults)), memberId: \(Swift.String(describing: memberId)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRoomsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRoomsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRoomsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRoomsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRoomsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRoomsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRoomsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRoomsOutputError>
}

public struct ListRoomsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRoomsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRoomsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRoomsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let memberId = input.operationInput.memberId {
            let memberIdQueryItem = ClientRuntime.URLQueryItem(name: "member-id".urlPercentEncoding(), value: Swift.String(memberId).urlPercentEncoding())
            input.builder.withQueryItem(memberIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRoomsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRoomsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRoomsOutputError>
}

public struct ListRoomsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRoomsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListRoomsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRoomsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRoomsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRoomsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRoomsOutputError>
}

public struct ListRoomsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRoomsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListRoomsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRoomsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/rooms"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRoomsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRoomsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRoomsOutputError>
}

public struct ListRoomsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The member ID (user ID or bot ID).
    public var memberId: Swift.String?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        memberId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.memberId = memberId
        self.nextToken = nextToken
    }
}

struct ListRoomsInputBody: Swift.Equatable {
}

extension ListRoomsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRoomsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRoomsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRoomsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRoomsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRoomsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), rooms: \(Swift.String(describing: rooms)))"}
}

extension ListRoomsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRoomsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rooms = output.rooms
        } else {
            self.nextToken = nil
            self.rooms = nil
        }
    }
}

public struct ListRoomsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The room details.
    public var rooms: [ChimeClientTypes.Room]?

    public init (
        nextToken: Swift.String? = nil,
        rooms: [ChimeClientTypes.Room]? = nil
    )
    {
        self.nextToken = nextToken
        self.rooms = rooms
    }
}

struct ListRoomsOutputResponseBody: Swift.Equatable {
    public let rooms: [ChimeClientTypes.Room]?
    public let nextToken: Swift.String?
}

extension ListRoomsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rooms = "Rooms"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Room?].self, forKey: .rooms)
        var roomsDecoded0:[ChimeClientTypes.Room]? = nil
        if let roomsContainer = roomsContainer {
            roomsDecoded0 = [ChimeClientTypes.Room]()
            for structure0 in roomsContainer {
                if let structure0 = structure0 {
                    roomsDecoded0?.append(structure0)
                }
            }
        }
        rooms = roomsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSipMediaApplicationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSipMediaApplicationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSipMediaApplicationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListSipMediaApplicationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSipMediaApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSipMediaApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSipMediaApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSipMediaApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSipMediaApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSipMediaApplicationsOutputError>
}

public struct ListSipMediaApplicationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSipMediaApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSipMediaApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSipMediaApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSipMediaApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSipMediaApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSipMediaApplicationsOutputError>
}

public struct ListSipMediaApplicationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSipMediaApplicationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListSipMediaApplicationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSipMediaApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSipMediaApplicationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSipMediaApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSipMediaApplicationsOutputError>
}

public struct ListSipMediaApplicationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSipMediaApplicationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListSipMediaApplicationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSipMediaApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/sip-media-applications"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSipMediaApplicationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSipMediaApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSipMediaApplicationsOutputError>
}

public struct ListSipMediaApplicationsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSipMediaApplicationsInputBody: Swift.Equatable {
}

extension ListSipMediaApplicationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSipMediaApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSipMediaApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSipMediaApplicationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSipMediaApplicationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSipMediaApplicationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), sipMediaApplications: \(Swift.String(describing: sipMediaApplications)))"}
}

extension ListSipMediaApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSipMediaApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sipMediaApplications = output.sipMediaApplications
        } else {
            self.nextToken = nil
            self.sipMediaApplications = nil
        }
    }
}

public struct ListSipMediaApplicationsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// List of SIP media applications and application details.
    public var sipMediaApplications: [ChimeClientTypes.SipMediaApplication]?

    public init (
        nextToken: Swift.String? = nil,
        sipMediaApplications: [ChimeClientTypes.SipMediaApplication]? = nil
    )
    {
        self.nextToken = nextToken
        self.sipMediaApplications = sipMediaApplications
    }
}

struct ListSipMediaApplicationsOutputResponseBody: Swift.Equatable {
    public let sipMediaApplications: [ChimeClientTypes.SipMediaApplication]?
    public let nextToken: Swift.String?
}

extension ListSipMediaApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sipMediaApplications = "SipMediaApplications"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipMediaApplication?].self, forKey: .sipMediaApplications)
        var sipMediaApplicationsDecoded0:[ChimeClientTypes.SipMediaApplication]? = nil
        if let sipMediaApplicationsContainer = sipMediaApplicationsContainer {
            sipMediaApplicationsDecoded0 = [ChimeClientTypes.SipMediaApplication]()
            for structure0 in sipMediaApplicationsContainer {
                if let structure0 = structure0 {
                    sipMediaApplicationsDecoded0?.append(structure0)
                }
            }
        }
        sipMediaApplications = sipMediaApplicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSipRulesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSipRulesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)))"}
}

extension ListSipRulesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListSipRulesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSipRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSipRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSipRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSipRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSipRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSipRulesOutputError>
}

public struct ListSipRulesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSipRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSipRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSipRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let sipMediaApplicationId = input.operationInput.sipMediaApplicationId {
            let sipMediaApplicationIdQueryItem = ClientRuntime.URLQueryItem(name: "sip-media-application".urlPercentEncoding(), value: Swift.String(sipMediaApplicationId).urlPercentEncoding())
            input.builder.withQueryItem(sipMediaApplicationIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSipRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSipRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSipRulesOutputError>
}

public struct ListSipRulesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSipRulesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListSipRulesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSipRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSipRulesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSipRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSipRulesOutputError>
}

public struct ListSipRulesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSipRulesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListSipRulesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSipRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/sip-rules"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSipRulesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSipRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSipRulesOutputError>
}

public struct ListSipRulesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The SIP media application ID.
    public var sipMediaApplicationId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct ListSipRulesInputBody: Swift.Equatable {
}

extension ListSipRulesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSipRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSipRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSipRulesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSipRulesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSipRulesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), sipRules: \(Swift.String(describing: sipRules)))"}
}

extension ListSipRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSipRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sipRules = output.sipRules
        } else {
            self.nextToken = nil
            self.sipRules = nil
        }
    }
}

public struct ListSipRulesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// List of SIP rules and rule details.
    public var sipRules: [ChimeClientTypes.SipRule]?

    public init (
        nextToken: Swift.String? = nil,
        sipRules: [ChimeClientTypes.SipRule]? = nil
    )
    {
        self.nextToken = nextToken
        self.sipRules = sipRules
    }
}

struct ListSipRulesOutputResponseBody: Swift.Equatable {
    public let sipRules: [ChimeClientTypes.SipRule]?
    public let nextToken: Swift.String?
}

extension ListSipRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sipRules = "SipRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRulesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipRule?].self, forKey: .sipRules)
        var sipRulesDecoded0:[ChimeClientTypes.SipRule]? = nil
        if let sipRulesContainer = sipRulesContainer {
            sipRulesDecoded0 = [ChimeClientTypes.SipRule]()
            for structure0 in sipRulesContainer {
                if let structure0 = structure0 {
                    sipRulesDecoded0?.append(structure0)
                }
            }
        }
        sipRules = sipRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSupportedPhoneNumberCountriesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSupportedPhoneNumberCountriesInput(productType: \(Swift.String(describing: productType)))"}
}

extension ListSupportedPhoneNumberCountriesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListSupportedPhoneNumberCountriesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSupportedPhoneNumberCountriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSupportedPhoneNumberCountriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSupportedPhoneNumberCountriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSupportedPhoneNumberCountriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSupportedPhoneNumberCountriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSupportedPhoneNumberCountriesOutputError>
}

public struct ListSupportedPhoneNumberCountriesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSupportedPhoneNumberCountriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSupportedPhoneNumberCountriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSupportedPhoneNumberCountriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let productType = input.operationInput.productType {
            let productTypeQueryItem = ClientRuntime.URLQueryItem(name: "product-type".urlPercentEncoding(), value: Swift.String(productType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(productTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSupportedPhoneNumberCountriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSupportedPhoneNumberCountriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSupportedPhoneNumberCountriesOutputError>
}

public struct ListSupportedPhoneNumberCountriesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSupportedPhoneNumberCountriesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListSupportedPhoneNumberCountriesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSupportedPhoneNumberCountriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSupportedPhoneNumberCountriesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSupportedPhoneNumberCountriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSupportedPhoneNumberCountriesOutputError>
}

public struct ListSupportedPhoneNumberCountriesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSupportedPhoneNumberCountriesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListSupportedPhoneNumberCountriesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSupportedPhoneNumberCountriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/phone-number-countries"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSupportedPhoneNumberCountriesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSupportedPhoneNumberCountriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSupportedPhoneNumberCountriesOutputError>
}

public struct ListSupportedPhoneNumberCountriesInput: Swift.Equatable {
    /// The phone number product type.
    /// This member is required.
    public var productType: ChimeClientTypes.PhoneNumberProductType?

    public init (
        productType: ChimeClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.productType = productType
    }
}

struct ListSupportedPhoneNumberCountriesInputBody: Swift.Equatable {
}

extension ListSupportedPhoneNumberCountriesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSupportedPhoneNumberCountriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSupportedPhoneNumberCountriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSupportedPhoneNumberCountriesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSupportedPhoneNumberCountriesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSupportedPhoneNumberCountriesOutputResponse(phoneNumberCountries: \(Swift.String(describing: phoneNumberCountries)))"}
}

extension ListSupportedPhoneNumberCountriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSupportedPhoneNumberCountriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberCountries = output.phoneNumberCountries
        } else {
            self.phoneNumberCountries = nil
        }
    }
}

public struct ListSupportedPhoneNumberCountriesOutputResponse: Swift.Equatable {
    /// The supported phone number countries.
    public var phoneNumberCountries: [ChimeClientTypes.PhoneNumberCountry]?

    public init (
        phoneNumberCountries: [ChimeClientTypes.PhoneNumberCountry]? = nil
    )
    {
        self.phoneNumberCountries = phoneNumberCountries
    }
}

struct ListSupportedPhoneNumberCountriesOutputResponseBody: Swift.Equatable {
    public let phoneNumberCountries: [ChimeClientTypes.PhoneNumberCountry]?
}

extension ListSupportedPhoneNumberCountriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberCountries = "PhoneNumberCountries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberCountriesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberCountry?].self, forKey: .phoneNumberCountries)
        var phoneNumberCountriesDecoded0:[ChimeClientTypes.PhoneNumberCountry]? = nil
        if let phoneNumberCountriesContainer = phoneNumberCountriesContainer {
            phoneNumberCountriesDecoded0 = [ChimeClientTypes.PhoneNumberCountry]()
            for structure0 in phoneNumberCountriesContainer {
                if let structure0 = structure0 {
                    phoneNumberCountriesDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberCountries = phoneNumberCountriesDecoded0
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceARN = input.operationInput.resourceARN {
            let resourceARNQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
            input.builder.withQueryItem(resourceARNQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/tags"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of tag-key value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init (
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [ChimeClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsersInput(accountId: \(Swift.String(describing: accountId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), userEmail: \(Swift.String(describing: userEmail)), userType: \(Swift.String(describing: userType)))"}
}

extension ListUsersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListUsersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let userEmail = input.operationInput.userEmail {
            let userEmailQueryItem = ClientRuntime.URLQueryItem(name: "user-email".urlPercentEncoding(), value: Swift.String(userEmail).urlPercentEncoding())
            input.builder.withQueryItem(userEmailQueryItem)
        }
        if let userType = input.operationInput.userType {
            let userTypeQueryItem = ClientRuntime.URLQueryItem(name: "user-type".urlPercentEncoding(), value: Swift.String(userType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(userTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListUsersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUsersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListUsersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/users"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUsersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// Optional. The user email address used to filter results. Maximum 1.
    public var userEmail: Swift.String?
    /// The user type.
    public var userType: ChimeClientTypes.UserType?

    public init (
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userEmail: Swift.String? = nil,
        userType: ChimeClientTypes.UserType? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userEmail = userEmail
        self.userType = userType
    }
}

struct ListUsersInputBody: Swift.Equatable {
}

extension ListUsersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), users: \(Swift.String(describing: users)))"}
}

extension ListUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// List of users and user details.
    public var users: [ChimeClientTypes.User]?

    public init (
        nextToken: Swift.String? = nil,
        users: [ChimeClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Swift.Equatable {
    public let users: [ChimeClientTypes.User]?
    public let nextToken: Swift.String?
}

extension ListUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([ChimeClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[ChimeClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [ChimeClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVoiceConnectorGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVoiceConnectorGroupsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListVoiceConnectorGroupsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListVoiceConnectorGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVoiceConnectorGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVoiceConnectorGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVoiceConnectorGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVoiceConnectorGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVoiceConnectorGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVoiceConnectorGroupsOutputError>
}

public struct ListVoiceConnectorGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVoiceConnectorGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVoiceConnectorGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVoiceConnectorGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVoiceConnectorGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVoiceConnectorGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVoiceConnectorGroupsOutputError>
}

public struct ListVoiceConnectorGroupsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVoiceConnectorGroupsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListVoiceConnectorGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVoiceConnectorGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVoiceConnectorGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVoiceConnectorGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVoiceConnectorGroupsOutputError>
}

public struct ListVoiceConnectorGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVoiceConnectorGroupsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListVoiceConnectorGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVoiceConnectorGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/voice-connector-groups"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVoiceConnectorGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVoiceConnectorGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVoiceConnectorGroupsOutputError>
}

public struct ListVoiceConnectorGroupsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVoiceConnectorGroupsInputBody: Swift.Equatable {
}

extension ListVoiceConnectorGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVoiceConnectorGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVoiceConnectorGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVoiceConnectorGroupsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVoiceConnectorGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVoiceConnectorGroupsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), voiceConnectorGroups: \(Swift.String(describing: voiceConnectorGroups)))"}
}

extension ListVoiceConnectorGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListVoiceConnectorGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voiceConnectorGroups = output.voiceConnectorGroups
        } else {
            self.nextToken = nil
            self.voiceConnectorGroups = nil
        }
    }
}

public struct ListVoiceConnectorGroupsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The details of the Amazon Chime Voice Connector groups.
    public var voiceConnectorGroups: [ChimeClientTypes.VoiceConnectorGroup]?

    public init (
        nextToken: Swift.String? = nil,
        voiceConnectorGroups: [ChimeClientTypes.VoiceConnectorGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceConnectorGroups = voiceConnectorGroups
    }
}

struct ListVoiceConnectorGroupsOutputResponseBody: Swift.Equatable {
    public let voiceConnectorGroups: [ChimeClientTypes.VoiceConnectorGroup]?
    public let nextToken: Swift.String?
}

extension ListVoiceConnectorGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voiceConnectorGroups = "VoiceConnectorGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.VoiceConnectorGroup?].self, forKey: .voiceConnectorGroups)
        var voiceConnectorGroupsDecoded0:[ChimeClientTypes.VoiceConnectorGroup]? = nil
        if let voiceConnectorGroupsContainer = voiceConnectorGroupsContainer {
            voiceConnectorGroupsDecoded0 = [ChimeClientTypes.VoiceConnectorGroup]()
            for structure0 in voiceConnectorGroupsContainer {
                if let structure0 = structure0 {
                    voiceConnectorGroupsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorGroups = voiceConnectorGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVoiceConnectorTerminationCredentialsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVoiceConnectorTerminationCredentialsInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension ListVoiceConnectorTerminationCredentialsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListVoiceConnectorTerminationCredentialsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVoiceConnectorTerminationCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVoiceConnectorTerminationCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVoiceConnectorTerminationCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVoiceConnectorTerminationCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVoiceConnectorTerminationCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVoiceConnectorTerminationCredentialsOutputError>
}

public struct ListVoiceConnectorTerminationCredentialsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVoiceConnectorTerminationCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVoiceConnectorTerminationCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVoiceConnectorTerminationCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVoiceConnectorTerminationCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVoiceConnectorTerminationCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVoiceConnectorTerminationCredentialsOutputError>
}

public struct ListVoiceConnectorTerminationCredentialsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVoiceConnectorTerminationCredentialsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListVoiceConnectorTerminationCredentialsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVoiceConnectorTerminationCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVoiceConnectorTerminationCredentialsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVoiceConnectorTerminationCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVoiceConnectorTerminationCredentialsOutputError>
}

public struct ListVoiceConnectorTerminationCredentialsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVoiceConnectorTerminationCredentialsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListVoiceConnectorTerminationCredentialsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVoiceConnectorTerminationCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVoiceConnectorTerminationCredentialsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVoiceConnectorTerminationCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVoiceConnectorTerminationCredentialsOutputError>
}

public struct ListVoiceConnectorTerminationCredentialsInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct ListVoiceConnectorTerminationCredentialsInputBody: Swift.Equatable {
}

extension ListVoiceConnectorTerminationCredentialsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVoiceConnectorTerminationCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVoiceConnectorTerminationCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVoiceConnectorTerminationCredentialsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVoiceConnectorTerminationCredentialsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVoiceConnectorTerminationCredentialsOutputResponse(usernames: \(Swift.String(describing: usernames)))"}
}

extension ListVoiceConnectorTerminationCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListVoiceConnectorTerminationCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.usernames = output.usernames
        } else {
            self.usernames = nil
        }
    }
}

public struct ListVoiceConnectorTerminationCredentialsOutputResponse: Swift.Equatable {
    /// A list of user names.
    public var usernames: [Swift.String]?

    public init (
        usernames: [Swift.String]? = nil
    )
    {
        self.usernames = usernames
    }
}

struct ListVoiceConnectorTerminationCredentialsOutputResponseBody: Swift.Equatable {
    public let usernames: [Swift.String]?
}

extension ListVoiceConnectorTerminationCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usernames = "Usernames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usernames)
        var usernamesDecoded0:[Swift.String]? = nil
        if let usernamesContainer = usernamesContainer {
            usernamesDecoded0 = [Swift.String]()
            for string0 in usernamesContainer {
                if let string0 = string0 {
                    usernamesDecoded0?.append(string0)
                }
            }
        }
        usernames = usernamesDecoded0
    }
}

extension ListVoiceConnectorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVoiceConnectorsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListVoiceConnectorsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListVoiceConnectorsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVoiceConnectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVoiceConnectorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVoiceConnectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVoiceConnectorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVoiceConnectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVoiceConnectorsOutputError>
}

public struct ListVoiceConnectorsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVoiceConnectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListVoiceConnectorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVoiceConnectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListVoiceConnectorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListVoiceConnectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVoiceConnectorsOutputError>
}

public struct ListVoiceConnectorsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVoiceConnectorsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListVoiceConnectorsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVoiceConnectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVoiceConnectorsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVoiceConnectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVoiceConnectorsOutputError>
}

public struct ListVoiceConnectorsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListVoiceConnectorsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListVoiceConnectorsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListVoiceConnectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/voice-connectors"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListVoiceConnectorsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListVoiceConnectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListVoiceConnectorsOutputError>
}

public struct ListVoiceConnectorsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVoiceConnectorsInputBody: Swift.Equatable {
}

extension ListVoiceConnectorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVoiceConnectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVoiceConnectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVoiceConnectorsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVoiceConnectorsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVoiceConnectorsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), voiceConnectors: \(Swift.String(describing: voiceConnectors)))"}
}

extension ListVoiceConnectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListVoiceConnectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voiceConnectors = output.voiceConnectors
        } else {
            self.nextToken = nil
            self.voiceConnectors = nil
        }
    }
}

public struct ListVoiceConnectorsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The details of the Amazon Chime Voice Connectors.
    public var voiceConnectors: [ChimeClientTypes.VoiceConnector]?

    public init (
        nextToken: Swift.String? = nil,
        voiceConnectors: [ChimeClientTypes.VoiceConnector]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceConnectors = voiceConnectors
    }
}

struct ListVoiceConnectorsOutputResponseBody: Swift.Equatable {
    public let voiceConnectors: [ChimeClientTypes.VoiceConnector]?
    public let nextToken: Swift.String?
}

extension ListVoiceConnectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voiceConnectors = "VoiceConnectors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.VoiceConnector?].self, forKey: .voiceConnectors)
        var voiceConnectorsDecoded0:[ChimeClientTypes.VoiceConnector]? = nil
        if let voiceConnectorsContainer = voiceConnectorsContainer {
            voiceConnectorsDecoded0 = [ChimeClientTypes.VoiceConnector]()
            for structure0 in voiceConnectorsContainer {
                if let structure0 = structure0 {
                    voiceConnectorsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectors = voiceConnectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ChimeClientTypes.LoggingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableSIPLogs = "EnableSIPLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableSIPLogs = enableSIPLogs {
            try encodeContainer.encode(enableSIPLogs, forKey: .enableSIPLogs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableSIPLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSIPLogs)
        enableSIPLogs = enableSIPLogsDecoded
    }
}

extension ChimeClientTypes.LoggingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoggingConfiguration(enableSIPLogs: \(Swift.String(describing: enableSIPLogs)))"}
}

extension ChimeClientTypes {
    /// The logging configuration associated with an Amazon Chime Voice Connector. Specifies whether SIP message logs are enabled for sending to Amazon CloudWatch Logs.
    public struct LoggingConfiguration: Swift.Equatable {
        /// When true, enables SIP message logs for sending to Amazon CloudWatch Logs.
        public var enableSIPLogs: Swift.Bool?

        public init (
            enableSIPLogs: Swift.Bool? = nil
        )
        {
            self.enableSIPLogs = enableSIPLogs
        }
    }

}

extension LogoutUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LogoutUserInput(accountId: \(Swift.String(describing: accountId)), userId: \(Swift.String(describing: userId)))"}
}

extension LogoutUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct LogoutUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LogoutUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<LogoutUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LogoutUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<LogoutUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<LogoutUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LogoutUserOutputError>
}

public struct LogoutUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LogoutUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<LogoutUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LogoutUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "logout"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<LogoutUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<LogoutUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LogoutUserOutputError>
}

public struct LogoutUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LogoutUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: LogoutUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LogoutUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = LogoutUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<LogoutUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LogoutUserOutputError>
}

public struct LogoutUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "LogoutUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: LogoutUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<LogoutUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let userId = input.userId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("userId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = LogoutUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<LogoutUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<LogoutUserOutputError>
}

public struct LogoutUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
    }
}

struct LogoutUserInputBody: Swift.Equatable {
}

extension LogoutUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension LogoutUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension LogoutUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum LogoutUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension LogoutUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LogoutUserOutputResponse()"}
}

extension LogoutUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct LogoutUserOutputResponse: Swift.Equatable {

    public init() {}
}

struct LogoutUserOutputResponseBody: Swift.Equatable {
}

extension LogoutUserOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ChimeClientTypes.MediaCapturePipeline: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case mediaPipelineId = "MediaPipelineId"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let mediaPipelineId = mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
        if let sinkArn = sinkArn {
            try encodeContainer.encode(sinkArn, forKey: .sinkArn)
        }
        if let sinkType = sinkType {
            try encodeContainer.encode(sinkType.rawValue, forKey: .sinkType)
        }
        if let sourceArn = sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = updatedTimestamp {
            try encodeContainer.encode(updatedTimestamp.timeIntervalSince1970, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaPipelineSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaPipelineStatus.self, forKey: .status)
        status = statusDecoded
        let sinkTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaPipelineSinkType.self, forKey: .sinkType)
        sinkType = sinkTypeDecoded
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeClientTypes.MediaCapturePipeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaCapturePipeline(createdTimestamp: \(Swift.String(describing: createdTimestamp)), mediaPipelineId: \(Swift.String(describing: mediaPipelineId)), sinkArn: \(Swift.String(describing: sinkArn)), sinkType: \(Swift.String(describing: sinkType)), sourceArn: \(Swift.String(describing: sourceArn)), sourceType: \(Swift.String(describing: sourceType)), status: \(Swift.String(describing: status)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)))"}
}

extension ChimeClientTypes {
    /// A media capture pipeline object. A string consisting of an ID, source type, a source ARN, a sink type, and a sink ARN.
    public struct MediaCapturePipeline: Swift.Equatable {
        /// The time at which the capture pipeline was created, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ID of a media capture pipeline.
        public var mediaPipelineId: Swift.String?
        /// ARN of the destination to which the media artifacts are saved.
        public var sinkArn: Swift.String?
        /// Destination type to which the media artifacts are saved. You must use an S3 Bucket.
        public var sinkType: ChimeClientTypes.MediaPipelineSinkType?
        /// ARN of the source from which the media artifacts will be saved.
        public var sourceArn: Swift.String?
        /// Source type from which media artifacts are saved. You must use ChimeMeeting.
        public var sourceType: ChimeClientTypes.MediaPipelineSourceType?
        /// The status of the media capture pipeline.
        public var status: ChimeClientTypes.MediaPipelineStatus?
        /// The time at which the capture pipeline was updated, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            createdTimestamp: ClientRuntime.Date? = nil,
            mediaPipelineId: Swift.String? = nil,
            sinkArn: Swift.String? = nil,
            sinkType: ChimeClientTypes.MediaPipelineSinkType? = nil,
            sourceArn: Swift.String? = nil,
            sourceType: ChimeClientTypes.MediaPipelineSourceType? = nil,
            status: ChimeClientTypes.MediaPipelineStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineId = mediaPipelineId
            self.sinkArn = sinkArn
            self.sinkType = sinkType
            self.sourceArn = sourceArn
            self.sourceType = sourceType
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes {
    public enum MediaPipelineSinkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3bucket
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineSinkType] {
            return [
                .s3bucket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3bucket: return "S3Bucket"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineSinkType(rawValue: rawValue) ?? MediaPipelineSinkType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum MediaPipelineSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chimesdkmeeting
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineSourceType] {
            return [
                .chimesdkmeeting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chimesdkmeeting: return "ChimeSdkMeeting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineSourceType(rawValue: rawValue) ?? MediaPipelineSourceType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum MediaPipelineStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case initializing
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineStatus] {
            return [
                .failed,
                .inprogress,
                .initializing,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .initializing: return "Initializing"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineStatus(rawValue: rawValue) ?? MediaPipelineStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.MediaPlacement: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioFallbackUrl = "AudioFallbackUrl"
        case audioHostUrl = "AudioHostUrl"
        case eventIngestionUrl = "EventIngestionUrl"
        case screenDataUrl = "ScreenDataUrl"
        case screenSharingUrl = "ScreenSharingUrl"
        case screenViewingUrl = "ScreenViewingUrl"
        case signalingUrl = "SignalingUrl"
        case turnControlUrl = "TurnControlUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioFallbackUrl = audioFallbackUrl {
            try encodeContainer.encode(audioFallbackUrl, forKey: .audioFallbackUrl)
        }
        if let audioHostUrl = audioHostUrl {
            try encodeContainer.encode(audioHostUrl, forKey: .audioHostUrl)
        }
        if let eventIngestionUrl = eventIngestionUrl {
            try encodeContainer.encode(eventIngestionUrl, forKey: .eventIngestionUrl)
        }
        if let screenDataUrl = screenDataUrl {
            try encodeContainer.encode(screenDataUrl, forKey: .screenDataUrl)
        }
        if let screenSharingUrl = screenSharingUrl {
            try encodeContainer.encode(screenSharingUrl, forKey: .screenSharingUrl)
        }
        if let screenViewingUrl = screenViewingUrl {
            try encodeContainer.encode(screenViewingUrl, forKey: .screenViewingUrl)
        }
        if let signalingUrl = signalingUrl {
            try encodeContainer.encode(signalingUrl, forKey: .signalingUrl)
        }
        if let turnControlUrl = turnControlUrl {
            try encodeContainer.encode(turnControlUrl, forKey: .turnControlUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioHostUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audioHostUrl)
        audioHostUrl = audioHostUrlDecoded
        let audioFallbackUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audioFallbackUrl)
        audioFallbackUrl = audioFallbackUrlDecoded
        let screenDataUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .screenDataUrl)
        screenDataUrl = screenDataUrlDecoded
        let screenSharingUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .screenSharingUrl)
        screenSharingUrl = screenSharingUrlDecoded
        let screenViewingUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .screenViewingUrl)
        screenViewingUrl = screenViewingUrlDecoded
        let signalingUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalingUrl)
        signalingUrl = signalingUrlDecoded
        let turnControlUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .turnControlUrl)
        turnControlUrl = turnControlUrlDecoded
        let eventIngestionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventIngestionUrl)
        eventIngestionUrl = eventIngestionUrlDecoded
    }
}

extension ChimeClientTypes.MediaPlacement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaPlacement(audioFallbackUrl: \(Swift.String(describing: audioFallbackUrl)), audioHostUrl: \(Swift.String(describing: audioHostUrl)), eventIngestionUrl: \(Swift.String(describing: eventIngestionUrl)), screenDataUrl: \(Swift.String(describing: screenDataUrl)), screenSharingUrl: \(Swift.String(describing: screenSharingUrl)), screenViewingUrl: \(Swift.String(describing: screenViewingUrl)), signalingUrl: \(Swift.String(describing: signalingUrl)), turnControlUrl: \(Swift.String(describing: turnControlUrl)))"}
}

extension ChimeClientTypes {
    /// A set of endpoints used by clients to connect to the media service group for an Amazon Chime SDK meeting.
    public struct MediaPlacement: Swift.Equatable {
        /// The audio fallback URL.
        public var audioFallbackUrl: Swift.String?
        /// The audio host URL.
        public var audioHostUrl: Swift.String?
        /// The URL of the S3 bucket used to store the captured media.
        public var eventIngestionUrl: Swift.String?
        /// The screen data URL.
        public var screenDataUrl: Swift.String?
        /// The screen sharing URL.
        public var screenSharingUrl: Swift.String?
        /// The screen viewing URL.
        public var screenViewingUrl: Swift.String?
        /// The signaling URL.
        public var signalingUrl: Swift.String?
        /// The turn control URL.
        public var turnControlUrl: Swift.String?

        public init (
            audioFallbackUrl: Swift.String? = nil,
            audioHostUrl: Swift.String? = nil,
            eventIngestionUrl: Swift.String? = nil,
            screenDataUrl: Swift.String? = nil,
            screenSharingUrl: Swift.String? = nil,
            screenViewingUrl: Swift.String? = nil,
            signalingUrl: Swift.String? = nil,
            turnControlUrl: Swift.String? = nil
        )
        {
            self.audioFallbackUrl = audioFallbackUrl
            self.audioHostUrl = audioHostUrl
            self.eventIngestionUrl = eventIngestionUrl
            self.screenDataUrl = screenDataUrl
            self.screenSharingUrl = screenSharingUrl
            self.screenViewingUrl = screenViewingUrl
            self.signalingUrl = signalingUrl
            self.turnControlUrl = turnControlUrl
        }
    }

}

extension ChimeClientTypes.Meeting: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalMeetingId = "ExternalMeetingId"
        case mediaPlacement = "MediaPlacement"
        case mediaRegion = "MediaRegion"
        case meetingId = "MeetingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalMeetingId = externalMeetingId {
            try encodeContainer.encode(externalMeetingId, forKey: .externalMeetingId)
        }
        if let mediaPlacement = mediaPlacement {
            try encodeContainer.encode(mediaPlacement, forKey: .mediaPlacement)
        }
        if let mediaRegion = mediaRegion {
            try encodeContainer.encode(mediaRegion, forKey: .mediaRegion)
        }
        if let meetingId = meetingId {
            try encodeContainer.encode(meetingId, forKey: .meetingId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingId)
        meetingId = meetingIdDecoded
        let externalMeetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalMeetingId)
        externalMeetingId = externalMeetingIdDecoded
        let mediaPlacementDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaPlacement.self, forKey: .mediaPlacement)
        mediaPlacement = mediaPlacementDecoded
        let mediaRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaRegion)
        mediaRegion = mediaRegionDecoded
    }
}

extension ChimeClientTypes.Meeting: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Meeting(externalMeetingId: \(Swift.String(describing: externalMeetingId)), mediaPlacement: \(Swift.String(describing: mediaPlacement)), mediaRegion: \(Swift.String(describing: mediaRegion)), meetingId: \(Swift.String(describing: meetingId)))"}
}

extension ChimeClientTypes {
    /// A meeting created using the Amazon Chime SDK.
    public struct Meeting: Swift.Equatable {
        /// The external meeting ID.
        public var externalMeetingId: Swift.String?
        /// The media placement for the meeting.
        public var mediaPlacement: ChimeClientTypes.MediaPlacement?
        /// The Region in which you create the meeting. Available values: af-south-1, ap-northeast-1,
        ///     ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, ca-central-1,
        ///     eu-central-1, eu-north-1, eu-south-1,
        ///                 eu-west-1, eu-west-2, eu-west-3,
        ///                 sa-east-1, us-east-1, us-east-2,
        ///                 us-west-1, us-west-2.
        public var mediaRegion: Swift.String?
        /// The Amazon Chime SDK meeting ID.
        public var meetingId: Swift.String?

        public init (
            externalMeetingId: Swift.String? = nil,
            mediaPlacement: ChimeClientTypes.MediaPlacement? = nil,
            mediaRegion: Swift.String? = nil,
            meetingId: Swift.String? = nil
        )
        {
            self.externalMeetingId = externalMeetingId
            self.mediaPlacement = mediaPlacement
            self.mediaRegion = mediaRegion
            self.meetingId = meetingId
        }
    }

}

extension ChimeClientTypes.MeetingNotificationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snsTopicArn = "SnsTopicArn"
        case sqsQueueArn = "SqsQueueArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sqsQueueArn = sqsQueueArn {
            try encodeContainer.encode(sqsQueueArn, forKey: .sqsQueueArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let sqsQueueArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sqsQueueArn)
        sqsQueueArn = sqsQueueArnDecoded
    }
}

extension ChimeClientTypes.MeetingNotificationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MeetingNotificationConfiguration(snsTopicArn: \(Swift.String(describing: snsTopicArn)), sqsQueueArn: \(Swift.String(describing: sqsQueueArn)))"}
}

extension ChimeClientTypes {
    ///  The resource target configurations for receiving Amazon Chime SDK meeting and attendee event
    ///             notifications. The Amazon Chime SDK supports resource targets located in the US East (N.
    ///             Virginia) AWS Region (us-east-1).
    public struct MeetingNotificationConfiguration: Swift.Equatable {
        /// The SNS topic ARN.
        public var snsTopicArn: Swift.String?
        /// The SQS queue ARN.
        public var sqsQueueArn: Swift.String?

        public init (
            snsTopicArn: Swift.String? = nil,
            sqsQueueArn: Swift.String? = nil
        )
        {
            self.snsTopicArn = snsTopicArn
            self.sqsQueueArn = sqsQueueArn
        }
    }

}

extension ChimeClientTypes.Member: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case email = "Email"
        case fullName = "FullName"
        case memberId = "MemberId"
        case memberType = "MemberType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let fullName = fullName {
            try encodeContainer.encode(fullName, forKey: .fullName)
        }
        if let memberId = memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let memberType = memberType {
            try encodeContainer.encode(memberType.rawValue, forKey: .memberType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
        let memberTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MemberType.self, forKey: .memberType)
        memberType = memberTypeDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let fullNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullName)
        fullName = fullNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ChimeClientTypes.Member: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Member(accountId: \(Swift.String(describing: accountId)), email: \(Swift.String(describing: email)), fullName: \(Swift.String(describing: fullName)), memberId: \(Swift.String(describing: memberId)), memberType: \(Swift.String(describing: memberType)))"}
}

extension ChimeClientTypes {
    /// The member details, such as email address, name, member ID, and member type.
    public struct Member: Swift.Equatable {
        /// The Amazon Chime account ID.
        public var accountId: Swift.String?
        /// The member email address.
        public var email: Swift.String?
        /// The member name.
        public var fullName: Swift.String?
        /// The member ID (user ID or bot ID).
        public var memberId: Swift.String?
        /// The member type.
        public var memberType: ChimeClientTypes.MemberType?

        public init (
            accountId: Swift.String? = nil,
            email: Swift.String? = nil,
            fullName: Swift.String? = nil,
            memberId: Swift.String? = nil,
            memberType: ChimeClientTypes.MemberType? = nil
        )
        {
            self.accountId = accountId
            self.email = email
            self.fullName = fullName
            self.memberId = memberId
            self.memberType = memberType
        }
    }

}

extension ChimeClientTypes.MemberError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case memberId = "MemberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let memberId = memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeClientTypes.MemberError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MemberError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), memberId: \(Swift.String(describing: memberId)))"}
}

extension ChimeClientTypes {
    /// The list of errors returned when a member action results in an error.
    public struct MemberError: Swift.Equatable {
        /// The error code.
        public var errorCode: ChimeClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The member ID.
        public var memberId: Swift.String?

        public init (
            errorCode: ChimeClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            memberId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.memberId = memberId
        }
    }

}

extension ChimeClientTypes {
    public enum MemberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bot
        case user
        case webhook
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberType] {
            return [
                .bot,
                .user,
                .webhook,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bot: return "Bot"
            case .user: return "User"
            case .webhook: return "Webhook"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberType(rawValue: rawValue) ?? MemberType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.MembershipItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberId = "MemberId"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberId = memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
        let roleDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RoomMembershipRole.self, forKey: .role)
        role = roleDecoded
    }
}

extension ChimeClientTypes.MembershipItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MembershipItem(memberId: \(Swift.String(describing: memberId)), role: \(Swift.String(describing: role)))"}
}

extension ChimeClientTypes {
    /// Membership details, such as member ID and member role.
    public struct MembershipItem: Swift.Equatable {
        /// The member ID.
        public var memberId: Swift.String?
        /// The member role.
        public var role: ChimeClientTypes.RoomMembershipRole?

        public init (
            memberId: Swift.String? = nil,
            role: ChimeClientTypes.RoomMembershipRole? = nil
        )
        {
            self.memberId = memberId
            self.role = role
        }
    }

}

extension ChimeClientTypes.MessagingSessionEndpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension ChimeClientTypes.MessagingSessionEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MessagingSessionEndpoint(url: \(Swift.String(describing: url)))"}
}

extension ChimeClientTypes {
    /// The websocket endpoint used to connect to Amazon Chime SDK messaging.
    public struct MessagingSessionEndpoint: Swift.Equatable {
        /// The endpoint to which you establish a websocket connection.
        public var url: Swift.String?

        public init (
            url: Swift.String? = nil
        )
        {
            self.url = url
        }
    }

}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let code: ChimeClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeClientTypes {
    public enum NotificationTarget: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eventbridge
        case sns
        case sqs
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationTarget] {
            return [
                .eventbridge,
                .sns,
                .sqs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eventbridge: return "EventBridge"
            case .sns: return "SNS"
            case .sqs: return "SQS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationTarget(rawValue: rawValue) ?? NotificationTarget.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum NumberSelectionBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case avoidsticky
        case prefersticky
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberSelectionBehavior] {
            return [
                .avoidsticky,
                .prefersticky,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .avoidsticky: return "AvoidSticky"
            case .prefersticky: return "PreferSticky"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumberSelectionBehavior(rawValue: rawValue) ?? NumberSelectionBehavior.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.OrderedPhoneNumber: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumber = "E164PhoneNumber"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumber = e164PhoneNumber {
            try encodeContainer.encode(e164PhoneNumber, forKey: .e164PhoneNumber)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .e164PhoneNumber)
        e164PhoneNumber = e164PhoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.OrderedPhoneNumberStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ChimeClientTypes.OrderedPhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrderedPhoneNumber(e164PhoneNumber: \(Swift.String(describing: e164PhoneNumber)), status: \(Swift.String(describing: status)))"}
}

extension ChimeClientTypes {
    /// A phone number for which an order has been placed.
    public struct OrderedPhoneNumber: Swift.Equatable {
        /// The phone number, in E.164 format.
        public var e164PhoneNumber: Swift.String?
        /// The phone number status.
        public var status: ChimeClientTypes.OrderedPhoneNumberStatus?

        public init (
            e164PhoneNumber: Swift.String? = nil,
            status: ChimeClientTypes.OrderedPhoneNumberStatus? = nil
        )
        {
            self.e164PhoneNumber = e164PhoneNumber
            self.status = status
        }
    }

}

extension ChimeClientTypes {
    public enum OrderedPhoneNumberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acquired
        case failed
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderedPhoneNumberStatus] {
            return [
                .acquired,
                .failed,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acquired: return "Acquired"
            case .failed: return "Failed"
            case .processing: return "Processing"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderedPhoneNumberStatus(rawValue: rawValue) ?? OrderedPhoneNumberStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.Origination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case routes = "Routes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let routes = routes {
            var routesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routes)
            for originationroutelist0 in routes {
                try routesContainer.encode(originationroutelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.OriginationRoute?].self, forKey: .routes)
        var routesDecoded0:[ChimeClientTypes.OriginationRoute]? = nil
        if let routesContainer = routesContainer {
            routesDecoded0 = [ChimeClientTypes.OriginationRoute]()
            for structure0 in routesContainer {
                if let structure0 = structure0 {
                    routesDecoded0?.append(structure0)
                }
            }
        }
        routes = routesDecoded0
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension ChimeClientTypes.Origination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Origination(disabled: \(Swift.String(describing: disabled)), routes: \(Swift.String(describing: routes)))"}
}

extension ChimeClientTypes {
    /// Origination settings enable your SIP hosts to receive inbound calls using your Amazon Chime
    ///             Voice Connector.
    ///
    ///             The parameters listed below are not required, but you must use at least one.
    ///
    public struct Origination: Swift.Equatable {
        /// When origination settings are disabled, inbound calls are not enabled for your Amazon Chime
        ///             Voice Connector. This parameter is not required, but you must specify this parameter or Routes.
        public var disabled: Swift.Bool?
        /// The call distribution properties defined for your SIP hosts. Valid range: Minimum value of 1.
        ///     Maximum value of 20. This parameter is not required, but you must specify this parameter or Disabled.
        public var routes: [ChimeClientTypes.OriginationRoute]?

        public init (
            disabled: Swift.Bool? = nil,
            routes: [ChimeClientTypes.OriginationRoute]? = nil
        )
        {
            self.disabled = disabled
            self.routes = routes
        }
    }

}

extension ChimeClientTypes.OriginationRoute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case port = "Port"
        case priority = "Priority"
        case `protocol` = "Protocol"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let weight = weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.OriginationRouteProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
    }
}

extension ChimeClientTypes.OriginationRoute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginationRoute(host: \(Swift.String(describing: host)), port: \(Swift.String(describing: port)), priority: \(Swift.String(describing: priority)), protocol: \(Swift.String(describing: `protocol`)), weight: \(Swift.String(describing: weight)))"}
}

extension ChimeClientTypes {
    /// Origination routes define call distribution properties for your SIP hosts to receive inbound
    ///             calls using your Amazon Chime Voice Connector. Limit: Ten origination routes for each
    ///             Amazon Chime Voice Connector.
    ///
    ///             The parameters listed below are not required, but you must use at least one.
    ///
    public struct OriginationRoute: Swift.Equatable {
        /// The protocol to use for the origination route. Encryption-enabled Amazon Chime Voice Connectors use TCP protocol by default.
        public var `protocol`: ChimeClientTypes.OriginationRouteProtocol?
        /// The FQDN or IP address to contact for origination traffic.
        public var host: Swift.String?
        /// The designated origination route port. Defaults to 5060.
        public var port: Swift.Int?
        /// The priority associated with the host, with 1 being the highest priority. Higher priority
        ///             hosts are attempted first.
        public var priority: Swift.Int?
        /// The weight associated with the host. If hosts are equal in priority, calls are redistributed among
        ///             them based on their relative weight.
        public var weight: Swift.Int?

        public init (
            `protocol`: ChimeClientTypes.OriginationRouteProtocol? = nil,
            host: Swift.String? = nil,
            port: Swift.Int? = nil,
            priority: Swift.Int? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.`protocol` = `protocol`
            self.host = host
            self.port = port
            self.priority = priority
            self.weight = weight
        }
    }

}

extension ChimeClientTypes {
    public enum OriginationRouteProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginationRouteProtocol] {
            return [
                .tcp,
                .udp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginationRouteProtocol(rawValue: rawValue) ?? OriginationRouteProtocol.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.Participant: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
        case proxyPhoneNumber = "ProxyPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let proxyPhoneNumber = proxyPhoneNumber {
            try encodeContainer.encode(proxyPhoneNumber, forKey: .proxyPhoneNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let proxyPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxyPhoneNumber)
        proxyPhoneNumber = proxyPhoneNumberDecoded
    }
}

extension ChimeClientTypes.Participant: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Participant(phoneNumber: \(Swift.String(describing: phoneNumber)), proxyPhoneNumber: \(Swift.String(describing: proxyPhoneNumber)))"}
}

extension ChimeClientTypes {
    /// The phone number and proxy phone number for a participant in an Amazon Chime Voice Connector proxy session.
    public struct Participant: Swift.Equatable {
        /// The participant's phone number.
        public var phoneNumber: Swift.String?
        /// The participant's proxy phone number.
        public var proxyPhoneNumber: Swift.String?

        public init (
            phoneNumber: Swift.String? = nil,
            proxyPhoneNumber: Swift.String? = nil
        )
        {
            self.phoneNumber = phoneNumber
            self.proxyPhoneNumber = proxyPhoneNumber
        }
    }

}

extension ChimeClientTypes.PhoneNumber: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations = "Associations"
        case callingName = "CallingName"
        case callingNameStatus = "CallingNameStatus"
        case capabilities = "Capabilities"
        case country = "Country"
        case createdTimestamp = "CreatedTimestamp"
        case deletionTimestamp = "DeletionTimestamp"
        case e164PhoneNumber = "E164PhoneNumber"
        case phoneNumberId = "PhoneNumberId"
        case productType = "ProductType"
        case status = "Status"
        case type = "Type"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associations = associations {
            var associationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associations)
            for phonenumberassociationlist0 in associations {
                try associationsContainer.encode(phonenumberassociationlist0)
            }
        }
        if let callingName = callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
        if let callingNameStatus = callingNameStatus {
            try encodeContainer.encode(callingNameStatus.rawValue, forKey: .callingNameStatus)
        }
        if let capabilities = capabilities {
            try encodeContainer.encode(capabilities, forKey: .capabilities)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let deletionTimestamp = deletionTimestamp {
            try encodeContainer.encode(deletionTimestamp.timeIntervalSince1970, forKey: .deletionTimestamp)
        }
        if let e164PhoneNumber = e164PhoneNumber {
            try encodeContainer.encode(e164PhoneNumber, forKey: .e164PhoneNumber)
        }
        if let phoneNumberId = phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let productType = productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedTimestamp = updatedTimestamp {
            try encodeContainer.encode(updatedTimestamp.timeIntervalSince1970, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let e164PhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .e164PhoneNumber)
        e164PhoneNumber = e164PhoneNumberDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberType.self, forKey: .type)
        type = typeDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberStatus.self, forKey: .status)
        status = statusDecoded
        let capabilitiesDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberCapabilities.self, forKey: .capabilities)
        capabilities = capabilitiesDecoded
        let associationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberAssociation?].self, forKey: .associations)
        var associationsDecoded0:[ChimeClientTypes.PhoneNumberAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [ChimeClientTypes.PhoneNumberAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
        let callingNameStatusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.CallingNameStatus.self, forKey: .callingNameStatus)
        callingNameStatus = callingNameStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let deletionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletionTimestamp)
        deletionTimestamp = deletionTimestampDecoded
    }
}

extension ChimeClientTypes.PhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumber(associations: \(Swift.String(describing: associations)), callingName: \(Swift.String(describing: callingName)), callingNameStatus: \(Swift.String(describing: callingNameStatus)), capabilities: \(Swift.String(describing: capabilities)), country: \(Swift.String(describing: country)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), deletionTimestamp: \(Swift.String(describing: deletionTimestamp)), e164PhoneNumber: \(Swift.String(describing: e164PhoneNumber)), phoneNumberId: \(Swift.String(describing: phoneNumberId)), productType: \(Swift.String(describing: productType)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)))"}
}

extension ChimeClientTypes {
    /// A phone number used for Amazon Chime Business Calling or an Amazon Chime Voice
    ///             Connector.
    public struct PhoneNumber: Swift.Equatable {
        /// The phone number associations.
        public var associations: [ChimeClientTypes.PhoneNumberAssociation]?
        /// The outbound calling name associated with the phone number.
        public var callingName: Swift.String?
        /// The outbound calling name status.
        public var callingNameStatus: ChimeClientTypes.CallingNameStatus?
        /// The phone number capabilities.
        public var capabilities: ChimeClientTypes.PhoneNumberCapabilities?
        /// The phone number country. Format: ISO 3166-1 alpha-2.
        public var country: Swift.String?
        /// The phone number creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The deleted phone number timestamp, in ISO 8601 format.
        public var deletionTimestamp: ClientRuntime.Date?
        /// The phone number, in E.164 format.
        public var e164PhoneNumber: Swift.String?
        /// The phone number ID.
        public var phoneNumberId: Swift.String?
        /// The phone number product type.
        public var productType: ChimeClientTypes.PhoneNumberProductType?
        /// The phone number status.
        public var status: ChimeClientTypes.PhoneNumberStatus?
        /// The phone number type.
        public var type: ChimeClientTypes.PhoneNumberType?
        /// The updated phone number timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            associations: [ChimeClientTypes.PhoneNumberAssociation]? = nil,
            callingName: Swift.String? = nil,
            callingNameStatus: ChimeClientTypes.CallingNameStatus? = nil,
            capabilities: ChimeClientTypes.PhoneNumberCapabilities? = nil,
            country: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            deletionTimestamp: ClientRuntime.Date? = nil,
            e164PhoneNumber: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            productType: ChimeClientTypes.PhoneNumberProductType? = nil,
            status: ChimeClientTypes.PhoneNumberStatus? = nil,
            type: ChimeClientTypes.PhoneNumberType? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.associations = associations
            self.callingName = callingName
            self.callingNameStatus = callingNameStatus
            self.capabilities = capabilities
            self.country = country
            self.createdTimestamp = createdTimestamp
            self.deletionTimestamp = deletionTimestamp
            self.e164PhoneNumber = e164PhoneNumber
            self.phoneNumberId = phoneNumberId
            self.productType = productType
            self.status = status
            self.type = type
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes.PhoneNumberAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedTimestamp = "AssociatedTimestamp"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedTimestamp = associatedTimestamp {
            try encodeContainer.encode(associatedTimestamp.timeIntervalSince1970, forKey: .associatedTimestamp)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberAssociationName.self, forKey: .name)
        name = nameDecoded
        let associatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .associatedTimestamp)
        associatedTimestamp = associatedTimestampDecoded
    }
}

extension ChimeClientTypes.PhoneNumberAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumberAssociation(associatedTimestamp: \(Swift.String(describing: associatedTimestamp)), name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension ChimeClientTypes {
    /// The phone number associations, such as Amazon Chime account ID, Amazon Chime user ID, Amazon
    ///             Chime Voice Connector ID, or Amazon Chime Voice Connector group ID.
    public struct PhoneNumberAssociation: Swift.Equatable {
        /// The timestamp of the phone number association, in ISO 8601 format.
        public var associatedTimestamp: ClientRuntime.Date?
        /// Defines the association with an Amazon Chime account ID, user ID, Amazon Chime Voice Connector
        ///             ID, or Amazon Chime Voice Connector group ID.
        public var name: ChimeClientTypes.PhoneNumberAssociationName?
        /// Contains the ID for the entity specified in Name.
        public var value: Swift.String?

        public init (
            associatedTimestamp: ClientRuntime.Date? = nil,
            name: ChimeClientTypes.PhoneNumberAssociationName? = nil,
            value: Swift.String? = nil
        )
        {
            self.associatedTimestamp = associatedTimestamp
            self.name = name
            self.value = value
        }
    }

}

extension ChimeClientTypes {
    public enum PhoneNumberAssociationName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountid
        case sipruleid
        case userid
        case voiceconnectorgroupid
        case voiceconnectorid
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberAssociationName] {
            return [
                .accountid,
                .sipruleid,
                .userid,
                .voiceconnectorgroupid,
                .voiceconnectorid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountid: return "AccountId"
            case .sipruleid: return "SipRuleId"
            case .userid: return "UserId"
            case .voiceconnectorgroupid: return "VoiceConnectorGroupId"
            case .voiceconnectorid: return "VoiceConnectorId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberAssociationName(rawValue: rawValue) ?? PhoneNumberAssociationName.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.PhoneNumberCapabilities: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inboundCall = "InboundCall"
        case inboundMMS = "InboundMMS"
        case inboundSMS = "InboundSMS"
        case outboundCall = "OutboundCall"
        case outboundMMS = "OutboundMMS"
        case outboundSMS = "OutboundSMS"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboundCall = inboundCall {
            try encodeContainer.encode(inboundCall, forKey: .inboundCall)
        }
        if let inboundMMS = inboundMMS {
            try encodeContainer.encode(inboundMMS, forKey: .inboundMMS)
        }
        if let inboundSMS = inboundSMS {
            try encodeContainer.encode(inboundSMS, forKey: .inboundSMS)
        }
        if let outboundCall = outboundCall {
            try encodeContainer.encode(outboundCall, forKey: .outboundCall)
        }
        if let outboundMMS = outboundMMS {
            try encodeContainer.encode(outboundMMS, forKey: .outboundMMS)
        }
        if let outboundSMS = outboundSMS {
            try encodeContainer.encode(outboundSMS, forKey: .outboundSMS)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inboundCallDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundCall)
        inboundCall = inboundCallDecoded
        let outboundCallDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundCall)
        outboundCall = outboundCallDecoded
        let inboundSMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundSMS)
        inboundSMS = inboundSMSDecoded
        let outboundSMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundSMS)
        outboundSMS = outboundSMSDecoded
        let inboundMMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundMMS)
        inboundMMS = inboundMMSDecoded
        let outboundMMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundMMS)
        outboundMMS = outboundMMSDecoded
    }
}

extension ChimeClientTypes.PhoneNumberCapabilities: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumberCapabilities(inboundCall: \(Swift.String(describing: inboundCall)), inboundMMS: \(Swift.String(describing: inboundMMS)), inboundSMS: \(Swift.String(describing: inboundSMS)), outboundCall: \(Swift.String(describing: outboundCall)), outboundMMS: \(Swift.String(describing: outboundMMS)), outboundSMS: \(Swift.String(describing: outboundSMS)))"}
}

extension ChimeClientTypes {
    /// The phone number capabilities for Amazon Chime Business Calling phone numbers, such as enabled
    ///             inbound and outbound calling and text messaging.
    public struct PhoneNumberCapabilities: Swift.Equatable {
        /// Allows or denies inbound calling for the specified phone number.
        public var inboundCall: Swift.Bool?
        /// Allows or denies inbound MMS messaging for the specified phone number.
        public var inboundMMS: Swift.Bool?
        /// Allows or denies inbound SMS messaging for the specified phone number.
        public var inboundSMS: Swift.Bool?
        /// Allows or denies outbound calling for the specified phone number.
        public var outboundCall: Swift.Bool?
        /// Allows or denies outbound MMS messaging for the specified phone number.
        public var outboundMMS: Swift.Bool?
        /// Allows or denies outbound SMS messaging for the specified phone number.
        public var outboundSMS: Swift.Bool?

        public init (
            inboundCall: Swift.Bool? = nil,
            inboundMMS: Swift.Bool? = nil,
            inboundSMS: Swift.Bool? = nil,
            outboundCall: Swift.Bool? = nil,
            outboundMMS: Swift.Bool? = nil,
            outboundSMS: Swift.Bool? = nil
        )
        {
            self.inboundCall = inboundCall
            self.inboundMMS = inboundMMS
            self.inboundSMS = inboundSMS
            self.outboundCall = outboundCall
            self.outboundMMS = outboundMMS
            self.outboundSMS = outboundSMS
        }
    }

}

extension ChimeClientTypes.PhoneNumberCountry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countryCode = "CountryCode"
        case supportedPhoneNumberTypes = "SupportedPhoneNumberTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let supportedPhoneNumberTypes = supportedPhoneNumberTypes {
            var supportedPhoneNumberTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedPhoneNumberTypes)
            for phonenumbertypelist0 in supportedPhoneNumberTypes {
                try supportedPhoneNumberTypesContainer.encode(phonenumbertypelist0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let supportedPhoneNumberTypesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberType?].self, forKey: .supportedPhoneNumberTypes)
        var supportedPhoneNumberTypesDecoded0:[ChimeClientTypes.PhoneNumberType]? = nil
        if let supportedPhoneNumberTypesContainer = supportedPhoneNumberTypesContainer {
            supportedPhoneNumberTypesDecoded0 = [ChimeClientTypes.PhoneNumberType]()
            for string0 in supportedPhoneNumberTypesContainer {
                if let string0 = string0 {
                    supportedPhoneNumberTypesDecoded0?.append(string0)
                }
            }
        }
        supportedPhoneNumberTypes = supportedPhoneNumberTypesDecoded0
    }
}

extension ChimeClientTypes.PhoneNumberCountry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumberCountry(countryCode: \(Swift.String(describing: countryCode)), supportedPhoneNumberTypes: \(Swift.String(describing: supportedPhoneNumberTypes)))"}
}

extension ChimeClientTypes {
    /// The phone number country.
    public struct PhoneNumberCountry: Swift.Equatable {
        /// The phone number country code. Format: ISO 3166-1 alpha-2.
        public var countryCode: Swift.String?
        /// The supported phone number types.
        public var supportedPhoneNumberTypes: [ChimeClientTypes.PhoneNumberType]?

        public init (
            countryCode: Swift.String? = nil,
            supportedPhoneNumberTypes: [ChimeClientTypes.PhoneNumberType]? = nil
        )
        {
            self.countryCode = countryCode
            self.supportedPhoneNumberTypes = supportedPhoneNumberTypes
        }
    }

}

extension ChimeClientTypes.PhoneNumberError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case phoneNumberId = "PhoneNumberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let phoneNumberId = phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeClientTypes.PhoneNumberError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumberError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), phoneNumberId: \(Swift.String(describing: phoneNumberId)))"}
}

extension ChimeClientTypes {
    /// If the phone number action fails for one or more of the phone numbers in the request, a list of
    ///             the phone numbers is returned, along with error codes and error messages.
    public struct PhoneNumberError: Swift.Equatable {
        /// The error code.
        public var errorCode: ChimeClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The phone number ID for which the action failed.
        public var phoneNumberId: Swift.String?

        public init (
            errorCode: ChimeClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.phoneNumberId = phoneNumberId
        }
    }

}

extension ChimeClientTypes.PhoneNumberOrder: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case orderedPhoneNumbers = "OrderedPhoneNumbers"
        case phoneNumberOrderId = "PhoneNumberOrderId"
        case productType = "ProductType"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let orderedPhoneNumbers = orderedPhoneNumbers {
            var orderedPhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderedPhoneNumbers)
            for orderedphonenumberlist0 in orderedPhoneNumbers {
                try orderedPhoneNumbersContainer.encode(orderedphonenumberlist0)
            }
        }
        if let phoneNumberOrderId = phoneNumberOrderId {
            try encodeContainer.encode(phoneNumberOrderId, forKey: .phoneNumberOrderId)
        }
        if let productType = productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = updatedTimestamp {
            try encodeContainer.encode(updatedTimestamp.timeIntervalSince1970, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberOrderId)
        phoneNumberOrderId = phoneNumberOrderIdDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberOrderStatus.self, forKey: .status)
        status = statusDecoded
        let orderedPhoneNumbersContainer = try containerValues.decodeIfPresent([ChimeClientTypes.OrderedPhoneNumber?].self, forKey: .orderedPhoneNumbers)
        var orderedPhoneNumbersDecoded0:[ChimeClientTypes.OrderedPhoneNumber]? = nil
        if let orderedPhoneNumbersContainer = orderedPhoneNumbersContainer {
            orderedPhoneNumbersDecoded0 = [ChimeClientTypes.OrderedPhoneNumber]()
            for structure0 in orderedPhoneNumbersContainer {
                if let structure0 = structure0 {
                    orderedPhoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        orderedPhoneNumbers = orderedPhoneNumbersDecoded0
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeClientTypes.PhoneNumberOrder: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumberOrder(createdTimestamp: \(Swift.String(describing: createdTimestamp)), orderedPhoneNumbers: \(Swift.String(describing: orderedPhoneNumbers)), phoneNumberOrderId: \(Swift.String(describing: phoneNumberOrderId)), productType: \(Swift.String(describing: productType)), status: \(Swift.String(describing: status)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)))"}
}

extension ChimeClientTypes {
    /// The details of a phone number order created for Amazon Chime.
    public struct PhoneNumberOrder: Swift.Equatable {
        /// The phone number order creation time stamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ordered phone number details, such as the phone number in E.164 format and the phone
        ///             number status.
        public var orderedPhoneNumbers: [ChimeClientTypes.OrderedPhoneNumber]?
        /// The phone number order ID.
        public var phoneNumberOrderId: Swift.String?
        /// The phone number order product type.
        public var productType: ChimeClientTypes.PhoneNumberProductType?
        /// The status of the phone number order.
        public var status: ChimeClientTypes.PhoneNumberOrderStatus?
        /// The updated phone number order time stamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            createdTimestamp: ClientRuntime.Date? = nil,
            orderedPhoneNumbers: [ChimeClientTypes.OrderedPhoneNumber]? = nil,
            phoneNumberOrderId: Swift.String? = nil,
            productType: ChimeClientTypes.PhoneNumberProductType? = nil,
            status: ChimeClientTypes.PhoneNumberOrderStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.orderedPhoneNumbers = orderedPhoneNumbers
            self.phoneNumberOrderId = phoneNumberOrderId
            self.productType = productType
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes {
    public enum PhoneNumberOrderStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case partial
        case processing
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberOrderStatus] {
            return [
                .failed,
                .partial,
                .processing,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .partial: return "Partial"
            case .processing: return "Processing"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberOrderStatus(rawValue: rawValue) ?? PhoneNumberOrderStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum PhoneNumberProductType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case businesscalling
        case sipmediaapplicationdialin
        case voiceconnector
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberProductType] {
            return [
                .businesscalling,
                .sipmediaapplicationdialin,
                .voiceconnector,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .businesscalling: return "BusinessCalling"
            case .sipmediaapplicationdialin: return "SipMediaApplicationDialIn"
            case .voiceconnector: return "VoiceConnector"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberProductType(rawValue: rawValue) ?? PhoneNumberProductType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum PhoneNumberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acquirefailed
        case acquireinprogress
        case assigned
        case deletefailed
        case deleteinprogress
        case releasefailed
        case releaseinprogress
        case unassigned
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberStatus] {
            return [
                .acquirefailed,
                .acquireinprogress,
                .assigned,
                .deletefailed,
                .deleteinprogress,
                .releasefailed,
                .releaseinprogress,
                .unassigned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acquirefailed: return "AcquireFailed"
            case .acquireinprogress: return "AcquireInProgress"
            case .assigned: return "Assigned"
            case .deletefailed: return "DeleteFailed"
            case .deleteinprogress: return "DeleteInProgress"
            case .releasefailed: return "ReleaseFailed"
            case .releaseinprogress: return "ReleaseInProgress"
            case .unassigned: return "Unassigned"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberStatus(rawValue: rawValue) ?? PhoneNumberStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum PhoneNumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case local
        case tollfree
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberType] {
            return [
                .local,
                .tollfree,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .local: return "Local"
            case .tollfree: return "TollFree"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberType(rawValue: rawValue) ?? PhoneNumberType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.Proxy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultSessionExpiryMinutes = "DefaultSessionExpiryMinutes"
        case disabled = "Disabled"
        case fallBackPhoneNumber = "FallBackPhoneNumber"
        case phoneNumberCountries = "PhoneNumberCountries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultSessionExpiryMinutes = defaultSessionExpiryMinutes {
            try encodeContainer.encode(defaultSessionExpiryMinutes, forKey: .defaultSessionExpiryMinutes)
        }
        if let disabled = disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let fallBackPhoneNumber = fallBackPhoneNumber {
            try encodeContainer.encode(fallBackPhoneNumber, forKey: .fallBackPhoneNumber)
        }
        if let phoneNumberCountries = phoneNumberCountries {
            var phoneNumberCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberCountries)
            for stringlist0 in phoneNumberCountries {
                try phoneNumberCountriesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultSessionExpiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultSessionExpiryMinutes)
        defaultSessionExpiryMinutes = defaultSessionExpiryMinutesDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let fallBackPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fallBackPhoneNumber)
        fallBackPhoneNumber = fallBackPhoneNumberDecoded
        let phoneNumberCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberCountries)
        var phoneNumberCountriesDecoded0:[Swift.String]? = nil
        if let phoneNumberCountriesContainer = phoneNumberCountriesContainer {
            phoneNumberCountriesDecoded0 = [Swift.String]()
            for string0 in phoneNumberCountriesContainer {
                if let string0 = string0 {
                    phoneNumberCountriesDecoded0?.append(string0)
                }
            }
        }
        phoneNumberCountries = phoneNumberCountriesDecoded0
    }
}

extension ChimeClientTypes.Proxy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Proxy(defaultSessionExpiryMinutes: \(Swift.String(describing: defaultSessionExpiryMinutes)), disabled: \(Swift.String(describing: disabled)), fallBackPhoneNumber: \(Swift.String(describing: fallBackPhoneNumber)), phoneNumberCountries: \(Swift.String(describing: phoneNumberCountries)))"}
}

extension ChimeClientTypes {
    /// The proxy configuration for an Amazon Chime Voice Connector.
    public struct Proxy: Swift.Equatable {
        /// The default number of minutes allowed for proxy sessions.
        public var defaultSessionExpiryMinutes: Swift.Int?
        /// When true, stops proxy sessions from being created on the specified Amazon Chime Voice Connector.
        public var disabled: Swift.Bool?
        /// The phone number to route calls to after a proxy session expires.
        public var fallBackPhoneNumber: Swift.String?
        /// The countries for proxy phone numbers to be selected from.
        public var phoneNumberCountries: [Swift.String]?

        public init (
            defaultSessionExpiryMinutes: Swift.Int? = nil,
            disabled: Swift.Bool? = nil,
            fallBackPhoneNumber: Swift.String? = nil,
            phoneNumberCountries: [Swift.String]? = nil
        )
        {
            self.defaultSessionExpiryMinutes = defaultSessionExpiryMinutes
            self.disabled = disabled
            self.fallBackPhoneNumber = fallBackPhoneNumber
            self.phoneNumberCountries = phoneNumberCountries
        }
    }

}

extension ChimeClientTypes.ProxySession: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case createdTimestamp = "CreatedTimestamp"
        case endedTimestamp = "EndedTimestamp"
        case expiryMinutes = "ExpiryMinutes"
        case geoMatchLevel = "GeoMatchLevel"
        case geoMatchParams = "GeoMatchParams"
        case name = "Name"
        case numberSelectionBehavior = "NumberSelectionBehavior"
        case participants = "Participants"
        case proxySessionId = "ProxySessionId"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capabilitylist0 in capabilities {
                try capabilitiesContainer.encode(capabilitylist0.rawValue)
            }
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let endedTimestamp = endedTimestamp {
            try encodeContainer.encode(endedTimestamp.timeIntervalSince1970, forKey: .endedTimestamp)
        }
        if let expiryMinutes = expiryMinutes {
            try encodeContainer.encode(expiryMinutes, forKey: .expiryMinutes)
        }
        if let geoMatchLevel = geoMatchLevel {
            try encodeContainer.encode(geoMatchLevel.rawValue, forKey: .geoMatchLevel)
        }
        if let geoMatchParams = geoMatchParams {
            try encodeContainer.encode(geoMatchParams, forKey: .geoMatchParams)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberSelectionBehavior = numberSelectionBehavior {
            try encodeContainer.encode(numberSelectionBehavior.rawValue, forKey: .numberSelectionBehavior)
        }
        if let participants = participants {
            var participantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participants)
            for participants0 in participants {
                try participantsContainer.encode(participants0)
            }
        }
        if let proxySessionId = proxySessionId {
            try encodeContainer.encode(proxySessionId, forKey: .proxySessionId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = updatedTimestamp {
            try encodeContainer.encode(updatedTimestamp.timeIntervalSince1970, forKey: .updatedTimestamp)
        }
        if let voiceConnectorId = voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let proxySessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxySessionId)
        proxySessionId = proxySessionIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ProxySessionStatus.self, forKey: .status)
        status = statusDecoded
        let expiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiryMinutes)
        expiryMinutes = expiryMinutesDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Capability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[ChimeClientTypes.Capability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [ChimeClientTypes.Capability]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let endedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endedTimestamp)
        endedTimestamp = endedTimestampDecoded
        let participantsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Participant?].self, forKey: .participants)
        var participantsDecoded0:[ChimeClientTypes.Participant]? = nil
        if let participantsContainer = participantsContainer {
            participantsDecoded0 = [ChimeClientTypes.Participant]()
            for structure0 in participantsContainer {
                if let structure0 = structure0 {
                    participantsDecoded0?.append(structure0)
                }
            }
        }
        participants = participantsDecoded0
        let numberSelectionBehaviorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.NumberSelectionBehavior.self, forKey: .numberSelectionBehavior)
        numberSelectionBehavior = numberSelectionBehaviorDecoded
        let geoMatchLevelDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.GeoMatchLevel.self, forKey: .geoMatchLevel)
        geoMatchLevel = geoMatchLevelDecoded
        let geoMatchParamsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.GeoMatchParams.self, forKey: .geoMatchParams)
        geoMatchParams = geoMatchParamsDecoded
    }
}

extension ChimeClientTypes.ProxySession: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProxySession(capabilities: \(Swift.String(describing: capabilities)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), endedTimestamp: \(Swift.String(describing: endedTimestamp)), expiryMinutes: \(Swift.String(describing: expiryMinutes)), geoMatchLevel: \(Swift.String(describing: geoMatchLevel)), geoMatchParams: \(Swift.String(describing: geoMatchParams)), name: \(Swift.String(describing: name)), numberSelectionBehavior: \(Swift.String(describing: numberSelectionBehavior)), participants: \(Swift.String(describing: participants)), proxySessionId: \(Swift.String(describing: proxySessionId)), status: \(Swift.String(describing: status)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension ChimeClientTypes {
    /// The proxy session for an Amazon Chime Voice Connector.
    public struct ProxySession: Swift.Equatable {
        /// The proxy session capabilities.
        public var capabilities: [ChimeClientTypes.Capability]?
        /// The created time stamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ended time stamp, in ISO 8601 format.
        public var endedTimestamp: ClientRuntime.Date?
        /// The number of minutes allowed for the proxy session.
        public var expiryMinutes: Swift.Int?
        /// The preference for matching the country or area code of the proxy phone number with that of the first participant.
        public var geoMatchLevel: ChimeClientTypes.GeoMatchLevel?
        /// The country and area code for the proxy phone number.
        public var geoMatchParams: ChimeClientTypes.GeoMatchParams?
        /// The name of the proxy session.
        public var name: Swift.String?
        /// The preference for proxy phone number reuse, or stickiness, between the same participants across sessions.
        public var numberSelectionBehavior: ChimeClientTypes.NumberSelectionBehavior?
        /// The proxy session participants.
        public var participants: [ChimeClientTypes.Participant]?
        /// The proxy session ID.
        public var proxySessionId: Swift.String?
        /// The status of the proxy session.
        public var status: ChimeClientTypes.ProxySessionStatus?
        /// The updated time stamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The Amazon Chime voice connector ID.
        public var voiceConnectorId: Swift.String?

        public init (
            capabilities: [ChimeClientTypes.Capability]? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            endedTimestamp: ClientRuntime.Date? = nil,
            expiryMinutes: Swift.Int? = nil,
            geoMatchLevel: ChimeClientTypes.GeoMatchLevel? = nil,
            geoMatchParams: ChimeClientTypes.GeoMatchParams? = nil,
            name: Swift.String? = nil,
            numberSelectionBehavior: ChimeClientTypes.NumberSelectionBehavior? = nil,
            participants: [ChimeClientTypes.Participant]? = nil,
            proxySessionId: Swift.String? = nil,
            status: ChimeClientTypes.ProxySessionStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.capabilities = capabilities
            self.createdTimestamp = createdTimestamp
            self.endedTimestamp = endedTimestamp
            self.expiryMinutes = expiryMinutes
            self.geoMatchLevel = geoMatchLevel
            self.geoMatchParams = geoMatchParams
            self.name = name
            self.numberSelectionBehavior = numberSelectionBehavior
            self.participants = participants
            self.proxySessionId = proxySessionId
            self.status = status
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeClientTypes {
    public enum ProxySessionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case inprogress
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [ProxySessionStatus] {
            return [
                .closed,
                .inprogress,
                .open,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "Closed"
            case .inprogress: return "InProgress"
            case .open: return "Open"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProxySessionStatus(rawValue: rawValue) ?? ProxySessionStatus.sdkUnknown(rawValue)
        }
    }
}

public struct PutAppInstanceRetentionSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAppInstanceRetentionSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAppInstanceRetentionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAppInstanceRetentionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAppInstanceRetentionSettingsOutputError>
}

extension PutAppInstanceRetentionSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAppInstanceRetentionSettingsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), appInstanceRetentionSettings: \(Swift.String(describing: appInstanceRetentionSettings)))"}
}

extension PutAppInstanceRetentionSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceRetentionSettings = appInstanceRetentionSettings {
            try encodeContainer.encode(appInstanceRetentionSettings, forKey: .appInstanceRetentionSettings)
        }
    }
}

public struct PutAppInstanceRetentionSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAppInstanceRetentionSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAppInstanceRetentionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAppInstanceRetentionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAppInstanceRetentionSettingsOutputError>
}

public struct PutAppInstanceRetentionSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAppInstanceRetentionSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAppInstanceRetentionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAppInstanceRetentionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAppInstanceRetentionSettingsOutputError>
}

public struct PutAppInstanceRetentionSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAppInstanceRetentionSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutAppInstanceRetentionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutAppInstanceRetentionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAppInstanceRetentionSettingsOutputError>
}

public struct PutAppInstanceRetentionSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAppInstanceRetentionSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutAppInstanceRetentionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())/retention-settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutAppInstanceRetentionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutAppInstanceRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAppInstanceRetentionSettingsOutputError>
}

public struct PutAppInstanceRetentionSettingsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The time in days to retain data. Data type: number.
    /// This member is required.
    public var appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings?

    public init (
        appInstanceArn: Swift.String? = nil,
        appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
    }
}

struct PutAppInstanceRetentionSettingsInputBody: Swift.Equatable {
    public let appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings?
}

extension PutAppInstanceRetentionSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstanceRetentionSettings.self, forKey: .appInstanceRetentionSettings)
        appInstanceRetentionSettings = appInstanceRetentionSettingsDecoded
    }
}

extension PutAppInstanceRetentionSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAppInstanceRetentionSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAppInstanceRetentionSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAppInstanceRetentionSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAppInstanceRetentionSettingsOutputResponse(appInstanceRetentionSettings: \(Swift.String(describing: appInstanceRetentionSettings)), initiateDeletionTimestamp: \(Swift.String(describing: initiateDeletionTimestamp)))"}
}

extension PutAppInstanceRetentionSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutAppInstanceRetentionSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceRetentionSettings = output.appInstanceRetentionSettings
            self.initiateDeletionTimestamp = output.initiateDeletionTimestamp
        } else {
            self.appInstanceRetentionSettings = nil
            self.initiateDeletionTimestamp = nil
        }
    }
}

public struct PutAppInstanceRetentionSettingsOutputResponse: Swift.Equatable {
    /// The time in days to retain data. Data type: number.
    public var appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings?
    /// The time at which the API deletes data.
    public var initiateDeletionTimestamp: ClientRuntime.Date?

    public init (
        appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings? = nil,
        initiateDeletionTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
    }
}

struct PutAppInstanceRetentionSettingsOutputResponseBody: Swift.Equatable {
    public let appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings?
    public let initiateDeletionTimestamp: ClientRuntime.Date?
}

extension PutAppInstanceRetentionSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
        case initiateDeletionTimestamp = "InitiateDeletionTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstanceRetentionSettings.self, forKey: .appInstanceRetentionSettings)
        appInstanceRetentionSettings = appInstanceRetentionSettingsDecoded
        let initiateDeletionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .initiateDeletionTimestamp)
        initiateDeletionTimestamp = initiateDeletionTimestampDecoded
    }
}

public struct PutAppInstanceStreamingConfigurationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAppInstanceStreamingConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAppInstanceStreamingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAppInstanceStreamingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAppInstanceStreamingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAppInstanceStreamingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAppInstanceStreamingConfigurationsOutputError>
}

extension PutAppInstanceStreamingConfigurationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAppInstanceStreamingConfigurationsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), appInstanceStreamingConfigurations: \(Swift.String(describing: appInstanceStreamingConfigurations)))"}
}

extension PutAppInstanceStreamingConfigurationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceStreamingConfigurations = "AppInstanceStreamingConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceStreamingConfigurations = appInstanceStreamingConfigurations {
            var appInstanceStreamingConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appInstanceStreamingConfigurations)
            for appinstancestreamingconfigurationlist0 in appInstanceStreamingConfigurations {
                try appInstanceStreamingConfigurationsContainer.encode(appinstancestreamingconfigurationlist0)
            }
        }
    }
}

public struct PutAppInstanceStreamingConfigurationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAppInstanceStreamingConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAppInstanceStreamingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAppInstanceStreamingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAppInstanceStreamingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAppInstanceStreamingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAppInstanceStreamingConfigurationsOutputError>
}

public struct PutAppInstanceStreamingConfigurationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAppInstanceStreamingConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAppInstanceStreamingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAppInstanceStreamingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAppInstanceStreamingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAppInstanceStreamingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAppInstanceStreamingConfigurationsOutputError>
}

public struct PutAppInstanceStreamingConfigurationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAppInstanceStreamingConfigurationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutAppInstanceStreamingConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAppInstanceStreamingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutAppInstanceStreamingConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutAppInstanceStreamingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAppInstanceStreamingConfigurationsOutputError>
}

public struct PutAppInstanceStreamingConfigurationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAppInstanceStreamingConfigurationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutAppInstanceStreamingConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAppInstanceStreamingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())/streaming-configurations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutAppInstanceStreamingConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutAppInstanceStreamingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAppInstanceStreamingConfigurationsOutputError>
}

public struct PutAppInstanceStreamingConfigurationsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The streaming configurations set for an AppInstance.
    /// This member is required.
    public var appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]?

    public init (
        appInstanceArn: Swift.String? = nil,
        appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceStreamingConfigurations = appInstanceStreamingConfigurations
    }
}

struct PutAppInstanceStreamingConfigurationsInputBody: Swift.Equatable {
    public let appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]?
}

extension PutAppInstanceStreamingConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceStreamingConfigurations = "AppInstanceStreamingConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceStreamingConfigurationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.AppInstanceStreamingConfiguration?].self, forKey: .appInstanceStreamingConfigurations)
        var appInstanceStreamingConfigurationsDecoded0:[ChimeClientTypes.AppInstanceStreamingConfiguration]? = nil
        if let appInstanceStreamingConfigurationsContainer = appInstanceStreamingConfigurationsContainer {
            appInstanceStreamingConfigurationsDecoded0 = [ChimeClientTypes.AppInstanceStreamingConfiguration]()
            for structure0 in appInstanceStreamingConfigurationsContainer {
                if let structure0 = structure0 {
                    appInstanceStreamingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        appInstanceStreamingConfigurations = appInstanceStreamingConfigurationsDecoded0
    }
}

extension PutAppInstanceStreamingConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAppInstanceStreamingConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAppInstanceStreamingConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAppInstanceStreamingConfigurationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAppInstanceStreamingConfigurationsOutputResponse(appInstanceStreamingConfigurations: \(Swift.String(describing: appInstanceStreamingConfigurations)))"}
}

extension PutAppInstanceStreamingConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutAppInstanceStreamingConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceStreamingConfigurations = output.appInstanceStreamingConfigurations
        } else {
            self.appInstanceStreamingConfigurations = nil
        }
    }
}

public struct PutAppInstanceStreamingConfigurationsOutputResponse: Swift.Equatable {
    /// The streaming configurations of an AppInstance.
    public var appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]?

    public init (
        appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]? = nil
    )
    {
        self.appInstanceStreamingConfigurations = appInstanceStreamingConfigurations
    }
}

struct PutAppInstanceStreamingConfigurationsOutputResponseBody: Swift.Equatable {
    public let appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]?
}

extension PutAppInstanceStreamingConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceStreamingConfigurations = "AppInstanceStreamingConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceStreamingConfigurationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.AppInstanceStreamingConfiguration?].self, forKey: .appInstanceStreamingConfigurations)
        var appInstanceStreamingConfigurationsDecoded0:[ChimeClientTypes.AppInstanceStreamingConfiguration]? = nil
        if let appInstanceStreamingConfigurationsContainer = appInstanceStreamingConfigurationsContainer {
            appInstanceStreamingConfigurationsDecoded0 = [ChimeClientTypes.AppInstanceStreamingConfiguration]()
            for structure0 in appInstanceStreamingConfigurationsContainer {
                if let structure0 = structure0 {
                    appInstanceStreamingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        appInstanceStreamingConfigurations = appInstanceStreamingConfigurationsDecoded0
    }
}

public struct PutEventsConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEventsConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEventsConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEventsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEventsConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEventsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEventsConfigurationOutputError>
}

extension PutEventsConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEventsConfigurationInput(accountId: \(Swift.String(describing: accountId)), botId: \(Swift.String(describing: botId)), lambdaFunctionArn: \(Swift.String(describing: lambdaFunctionArn)), outboundEventsHTTPSEndpoint: \(Swift.String(describing: outboundEventsHTTPSEndpoint)))"}
}

extension PutEventsConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaFunctionArn = "LambdaFunctionArn"
        case outboundEventsHTTPSEndpoint = "OutboundEventsHTTPSEndpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaFunctionArn = lambdaFunctionArn {
            try encodeContainer.encode(lambdaFunctionArn, forKey: .lambdaFunctionArn)
        }
        if let outboundEventsHTTPSEndpoint = outboundEventsHTTPSEndpoint {
            try encodeContainer.encode(outboundEventsHTTPSEndpoint, forKey: .outboundEventsHTTPSEndpoint)
        }
    }
}

public struct PutEventsConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEventsConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEventsConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEventsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEventsConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEventsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEventsConfigurationOutputError>
}

public struct PutEventsConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEventsConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEventsConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEventsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEventsConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEventsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEventsConfigurationOutputError>
}

public struct PutEventsConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEventsConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutEventsConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEventsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutEventsConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutEventsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEventsConfigurationOutputError>
}

public struct PutEventsConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEventsConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutEventsConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEventsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let botId = input.botId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("botId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())/events-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutEventsConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutEventsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEventsConfigurationOutputError>
}

public struct PutEventsConfigurationInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?
    /// Lambda function ARN that allows the bot to receive outgoing events.
    public var lambdaFunctionArn: Swift.String?
    /// HTTPS endpoint that allows the bot to receive outgoing events.
    public var outboundEventsHTTPSEndpoint: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil,
        lambdaFunctionArn: Swift.String? = nil,
        outboundEventsHTTPSEndpoint: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
        self.lambdaFunctionArn = lambdaFunctionArn
        self.outboundEventsHTTPSEndpoint = outboundEventsHTTPSEndpoint
    }
}

struct PutEventsConfigurationInputBody: Swift.Equatable {
    public let outboundEventsHTTPSEndpoint: Swift.String?
    public let lambdaFunctionArn: Swift.String?
}

extension PutEventsConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaFunctionArn = "LambdaFunctionArn"
        case outboundEventsHTTPSEndpoint = "OutboundEventsHTTPSEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outboundEventsHTTPSEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundEventsHTTPSEndpoint)
        outboundEventsHTTPSEndpoint = outboundEventsHTTPSEndpointDecoded
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
    }
}

extension PutEventsConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEventsConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEventsConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEventsConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEventsConfigurationOutputResponse(eventsConfiguration: \(Swift.String(describing: eventsConfiguration)))"}
}

extension PutEventsConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutEventsConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventsConfiguration = output.eventsConfiguration
        } else {
            self.eventsConfiguration = nil
        }
    }
}

public struct PutEventsConfigurationOutputResponse: Swift.Equatable {
    /// The configuration that allows a bot to receive outgoing events. Can be either an HTTPS endpoint or a Lambda function ARN.
    public var eventsConfiguration: ChimeClientTypes.EventsConfiguration?

    public init (
        eventsConfiguration: ChimeClientTypes.EventsConfiguration? = nil
    )
    {
        self.eventsConfiguration = eventsConfiguration
    }
}

struct PutEventsConfigurationOutputResponseBody: Swift.Equatable {
    public let eventsConfiguration: ChimeClientTypes.EventsConfiguration?
}

extension PutEventsConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventsConfiguration = "EventsConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EventsConfiguration.self, forKey: .eventsConfiguration)
        eventsConfiguration = eventsConfigurationDecoded
    }
}

public struct PutRetentionSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRetentionSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRetentionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRetentionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRetentionSettingsOutputError>
}

extension PutRetentionSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRetentionSettingsInput(accountId: \(Swift.String(describing: accountId)), retentionSettings: \(Swift.String(describing: retentionSettings)))"}
}

extension PutRetentionSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionSettings = "RetentionSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionSettings = retentionSettings {
            try encodeContainer.encode(retentionSettings, forKey: .retentionSettings)
        }
    }
}

public struct PutRetentionSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRetentionSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRetentionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRetentionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRetentionSettingsOutputError>
}

public struct PutRetentionSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRetentionSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRetentionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRetentionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRetentionSettingsOutputError>
}

public struct PutRetentionSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRetentionSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutRetentionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutRetentionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRetentionSettingsOutputError>
}

public struct PutRetentionSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRetentionSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutRetentionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRetentionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/retention-settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutRetentionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutRetentionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRetentionSettingsOutputError>
}

public struct PutRetentionSettingsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The retention settings.
    /// This member is required.
    public var retentionSettings: ChimeClientTypes.RetentionSettings?

    public init (
        accountId: Swift.String? = nil,
        retentionSettings: ChimeClientTypes.RetentionSettings? = nil
    )
    {
        self.accountId = accountId
        self.retentionSettings = retentionSettings
    }
}

struct PutRetentionSettingsInputBody: Swift.Equatable {
    public let retentionSettings: ChimeClientTypes.RetentionSettings?
}

extension PutRetentionSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionSettings = "RetentionSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RetentionSettings.self, forKey: .retentionSettings)
        retentionSettings = retentionSettingsDecoded
    }
}

extension PutRetentionSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRetentionSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRetentionSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRetentionSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRetentionSettingsOutputResponse(initiateDeletionTimestamp: \(Swift.String(describing: initiateDeletionTimestamp)), retentionSettings: \(Swift.String(describing: retentionSettings)))"}
}

extension PutRetentionSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutRetentionSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.initiateDeletionTimestamp = output.initiateDeletionTimestamp
            self.retentionSettings = output.retentionSettings
        } else {
            self.initiateDeletionTimestamp = nil
            self.retentionSettings = nil
        }
    }
}

public struct PutRetentionSettingsOutputResponse: Swift.Equatable {
    /// The timestamp representing the time at which the specified items are permanently deleted, in ISO 8601 format.
    public var initiateDeletionTimestamp: ClientRuntime.Date?
    /// The retention settings.
    public var retentionSettings: ChimeClientTypes.RetentionSettings?

    public init (
        initiateDeletionTimestamp: ClientRuntime.Date? = nil,
        retentionSettings: ChimeClientTypes.RetentionSettings? = nil
    )
    {
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
        self.retentionSettings = retentionSettings
    }
}

struct PutRetentionSettingsOutputResponseBody: Swift.Equatable {
    public let retentionSettings: ChimeClientTypes.RetentionSettings?
    public let initiateDeletionTimestamp: ClientRuntime.Date?
}

extension PutRetentionSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiateDeletionTimestamp = "InitiateDeletionTimestamp"
        case retentionSettings = "RetentionSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RetentionSettings.self, forKey: .retentionSettings)
        retentionSettings = retentionSettingsDecoded
        let initiateDeletionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .initiateDeletionTimestamp)
        initiateDeletionTimestamp = initiateDeletionTimestampDecoded
    }
}

public struct PutSipMediaApplicationLoggingConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSipMediaApplicationLoggingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSipMediaApplicationLoggingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSipMediaApplicationLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSipMediaApplicationLoggingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSipMediaApplicationLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSipMediaApplicationLoggingConfigurationOutputError>
}

extension PutSipMediaApplicationLoggingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSipMediaApplicationLoggingConfigurationInput(sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)), sipMediaApplicationLoggingConfiguration: \(Swift.String(describing: sipMediaApplicationLoggingConfiguration)))"}
}

extension PutSipMediaApplicationLoggingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration {
            try encodeContainer.encode(sipMediaApplicationLoggingConfiguration, forKey: .sipMediaApplicationLoggingConfiguration)
        }
    }
}

public struct PutSipMediaApplicationLoggingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSipMediaApplicationLoggingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSipMediaApplicationLoggingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSipMediaApplicationLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSipMediaApplicationLoggingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSipMediaApplicationLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSipMediaApplicationLoggingConfigurationOutputError>
}

public struct PutSipMediaApplicationLoggingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSipMediaApplicationLoggingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSipMediaApplicationLoggingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSipMediaApplicationLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSipMediaApplicationLoggingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSipMediaApplicationLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSipMediaApplicationLoggingConfigurationOutputError>
}

public struct PutSipMediaApplicationLoggingConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSipMediaApplicationLoggingConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutSipMediaApplicationLoggingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSipMediaApplicationLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutSipMediaApplicationLoggingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutSipMediaApplicationLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSipMediaApplicationLoggingConfigurationOutputError>
}

public struct PutSipMediaApplicationLoggingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSipMediaApplicationLoggingConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutSipMediaApplicationLoggingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSipMediaApplicationLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sipMediaApplicationId = input.sipMediaApplicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sipMediaApplicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/logging-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutSipMediaApplicationLoggingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutSipMediaApplicationLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSipMediaApplicationLoggingConfigurationOutputError>
}

public struct PutSipMediaApplicationLoggingConfigurationInput: Swift.Equatable {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// The actual logging configuration.
    public var sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?

    public init (
        sipMediaApplicationId: Swift.String? = nil,
        sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

struct PutSipMediaApplicationLoggingConfigurationInputBody: Swift.Equatable {
    public let sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?
}

extension PutSipMediaApplicationLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationLoggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplicationLoggingConfiguration.self, forKey: .sipMediaApplicationLoggingConfiguration)
        sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfigurationDecoded
    }
}

extension PutSipMediaApplicationLoggingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSipMediaApplicationLoggingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSipMediaApplicationLoggingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSipMediaApplicationLoggingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSipMediaApplicationLoggingConfigurationOutputResponse(sipMediaApplicationLoggingConfiguration: \(Swift.String(describing: sipMediaApplicationLoggingConfiguration)))"}
}

extension PutSipMediaApplicationLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutSipMediaApplicationLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationLoggingConfiguration = output.sipMediaApplicationLoggingConfiguration
        } else {
            self.sipMediaApplicationLoggingConfiguration = nil
        }
    }
}

public struct PutSipMediaApplicationLoggingConfigurationOutputResponse: Swift.Equatable {
    /// Logging configuration of the SIP media application.
    public var sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?

    public init (
        sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

struct PutSipMediaApplicationLoggingConfigurationOutputResponseBody: Swift.Equatable {
    public let sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?
}

extension PutSipMediaApplicationLoggingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationLoggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplicationLoggingConfiguration.self, forKey: .sipMediaApplicationLoggingConfiguration)
        sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfigurationDecoded
    }
}

public struct PutVoiceConnectorEmergencyCallingConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorEmergencyCallingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorEmergencyCallingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorEmergencyCallingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorEmergencyCallingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorEmergencyCallingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorEmergencyCallingConfigurationOutputError>
}

extension PutVoiceConnectorEmergencyCallingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorEmergencyCallingConfigurationInput(emergencyCallingConfiguration: \(Swift.String(describing: emergencyCallingConfiguration)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension PutVoiceConnectorEmergencyCallingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emergencyCallingConfiguration = emergencyCallingConfiguration {
            try encodeContainer.encode(emergencyCallingConfiguration, forKey: .emergencyCallingConfiguration)
        }
    }
}

public struct PutVoiceConnectorEmergencyCallingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorEmergencyCallingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorEmergencyCallingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorEmergencyCallingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorEmergencyCallingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorEmergencyCallingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorEmergencyCallingConfigurationOutputError>
}

public struct PutVoiceConnectorEmergencyCallingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorEmergencyCallingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorEmergencyCallingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorEmergencyCallingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorEmergencyCallingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorEmergencyCallingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorEmergencyCallingConfigurationOutputError>
}

public struct PutVoiceConnectorEmergencyCallingConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorEmergencyCallingConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutVoiceConnectorEmergencyCallingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorEmergencyCallingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutVoiceConnectorEmergencyCallingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorEmergencyCallingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorEmergencyCallingConfigurationOutputError>
}

public struct PutVoiceConnectorEmergencyCallingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorEmergencyCallingConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutVoiceConnectorEmergencyCallingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorEmergencyCallingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutVoiceConnectorEmergencyCallingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorEmergencyCallingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorEmergencyCallingConfigurationOutputError>
}

public struct PutVoiceConnectorEmergencyCallingConfigurationInput: Swift.Equatable {
    /// The emergency calling configuration details.
    /// This member is required.
    public var emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Equatable {
    public let emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration?
}

extension PutVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyCallingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EmergencyCallingConfiguration.self, forKey: .emergencyCallingConfiguration)
        emergencyCallingConfiguration = emergencyCallingConfigurationDecoded
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutVoiceConnectorEmergencyCallingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorEmergencyCallingConfigurationOutputResponse(emergencyCallingConfiguration: \(Swift.String(describing: emergencyCallingConfiguration)))"}
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutVoiceConnectorEmergencyCallingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.emergencyCallingConfiguration = output.emergencyCallingConfiguration
        } else {
            self.emergencyCallingConfiguration = nil
        }
    }
}

public struct PutVoiceConnectorEmergencyCallingConfigurationOutputResponse: Swift.Equatable {
    /// The emergency calling configuration details.
    public var emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration?

    public init (
        emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
    }
}

struct PutVoiceConnectorEmergencyCallingConfigurationOutputResponseBody: Swift.Equatable {
    public let emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration?
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyCallingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EmergencyCallingConfiguration.self, forKey: .emergencyCallingConfiguration)
        emergencyCallingConfiguration = emergencyCallingConfigurationDecoded
    }
}

public struct PutVoiceConnectorLoggingConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorLoggingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorLoggingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorLoggingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorLoggingConfigurationOutputError>
}

extension PutVoiceConnectorLoggingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorLoggingConfigurationInput(loggingConfiguration: \(Swift.String(describing: loggingConfiguration)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension PutVoiceConnectorLoggingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingConfiguration = loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
    }
}

public struct PutVoiceConnectorLoggingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorLoggingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorLoggingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorLoggingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorLoggingConfigurationOutputError>
}

public struct PutVoiceConnectorLoggingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorLoggingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorLoggingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorLoggingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorLoggingConfigurationOutputError>
}

public struct PutVoiceConnectorLoggingConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorLoggingConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutVoiceConnectorLoggingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutVoiceConnectorLoggingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorLoggingConfigurationOutputError>
}

public struct PutVoiceConnectorLoggingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorLoggingConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutVoiceConnectorLoggingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/logging-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutVoiceConnectorLoggingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorLoggingConfigurationOutputError>
}

public struct PutVoiceConnectorLoggingConfigurationInput: Swift.Equatable {
    /// The logging configuration details to add.
    /// This member is required.
    public var loggingConfiguration: ChimeClientTypes.LoggingConfiguration?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        loggingConfiguration: ChimeClientTypes.LoggingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorLoggingConfigurationInputBody: Swift.Equatable {
    public let loggingConfiguration: ChimeClientTypes.LoggingConfiguration?
}

extension PutVoiceConnectorLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

extension PutVoiceConnectorLoggingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutVoiceConnectorLoggingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutVoiceConnectorLoggingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutVoiceConnectorLoggingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorLoggingConfigurationOutputResponse(loggingConfiguration: \(Swift.String(describing: loggingConfiguration)))"}
}

extension PutVoiceConnectorLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutVoiceConnectorLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.loggingConfiguration = nil
        }
    }
}

public struct PutVoiceConnectorLoggingConfigurationOutputResponse: Swift.Equatable {
    /// The updated logging configuration details.
    public var loggingConfiguration: ChimeClientTypes.LoggingConfiguration?

    public init (
        loggingConfiguration: ChimeClientTypes.LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct PutVoiceConnectorLoggingConfigurationOutputResponseBody: Swift.Equatable {
    public let loggingConfiguration: ChimeClientTypes.LoggingConfiguration?
}

extension PutVoiceConnectorLoggingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

public struct PutVoiceConnectorOriginationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorOriginationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorOriginationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorOriginationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorOriginationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorOriginationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorOriginationOutputError>
}

extension PutVoiceConnectorOriginationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorOriginationInput(origination: \(Swift.String(describing: origination)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension PutVoiceConnectorOriginationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let origination = origination {
            try encodeContainer.encode(origination, forKey: .origination)
        }
    }
}

public struct PutVoiceConnectorOriginationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorOriginationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorOriginationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorOriginationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorOriginationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorOriginationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorOriginationOutputError>
}

public struct PutVoiceConnectorOriginationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorOriginationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorOriginationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorOriginationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorOriginationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorOriginationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorOriginationOutputError>
}

public struct PutVoiceConnectorOriginationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorOriginationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutVoiceConnectorOriginationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorOriginationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutVoiceConnectorOriginationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorOriginationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorOriginationOutputError>
}

public struct PutVoiceConnectorOriginationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorOriginationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutVoiceConnectorOriginationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorOriginationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutVoiceConnectorOriginationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorOriginationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorOriginationOutputError>
}

public struct PutVoiceConnectorOriginationInput: Swift.Equatable {
    /// The origination setting details to add.
    /// This member is required.
    public var origination: ChimeClientTypes.Origination?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        origination: ChimeClientTypes.Origination? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.origination = origination
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorOriginationInputBody: Swift.Equatable {
    public let origination: ChimeClientTypes.Origination?
}

extension PutVoiceConnectorOriginationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
    }
}

extension PutVoiceConnectorOriginationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutVoiceConnectorOriginationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutVoiceConnectorOriginationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutVoiceConnectorOriginationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorOriginationOutputResponse(origination: \(Swift.String(describing: origination)))"}
}

extension PutVoiceConnectorOriginationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutVoiceConnectorOriginationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.origination = output.origination
        } else {
            self.origination = nil
        }
    }
}

public struct PutVoiceConnectorOriginationOutputResponse: Swift.Equatable {
    /// The updated origination setting details.
    public var origination: ChimeClientTypes.Origination?

    public init (
        origination: ChimeClientTypes.Origination? = nil
    )
    {
        self.origination = origination
    }
}

struct PutVoiceConnectorOriginationOutputResponseBody: Swift.Equatable {
    public let origination: ChimeClientTypes.Origination?
}

extension PutVoiceConnectorOriginationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
    }
}

public struct PutVoiceConnectorProxyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorProxyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorProxyOutputError>
}

extension PutVoiceConnectorProxyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorProxyInput(defaultSessionExpiryMinutes: \(Swift.String(describing: defaultSessionExpiryMinutes)), disabled: \(Swift.String(describing: disabled)), fallBackPhoneNumber: \(Swift.String(describing: fallBackPhoneNumber)), phoneNumberPoolCountries: \(Swift.String(describing: phoneNumberPoolCountries)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension PutVoiceConnectorProxyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultSessionExpiryMinutes = "DefaultSessionExpiryMinutes"
        case disabled = "Disabled"
        case fallBackPhoneNumber = "FallBackPhoneNumber"
        case phoneNumberPoolCountries = "PhoneNumberPoolCountries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultSessionExpiryMinutes = defaultSessionExpiryMinutes {
            try encodeContainer.encode(defaultSessionExpiryMinutes, forKey: .defaultSessionExpiryMinutes)
        }
        if let disabled = disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let fallBackPhoneNumber = fallBackPhoneNumber {
            try encodeContainer.encode(fallBackPhoneNumber, forKey: .fallBackPhoneNumber)
        }
        if let phoneNumberPoolCountries = phoneNumberPoolCountries {
            var phoneNumberPoolCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberPoolCountries)
            for countrylist0 in phoneNumberPoolCountries {
                try phoneNumberPoolCountriesContainer.encode(countrylist0)
            }
        }
    }
}

public struct PutVoiceConnectorProxyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorProxyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorProxyOutputError>
}

public struct PutVoiceConnectorProxyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorProxyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorProxyOutputError>
}

public struct PutVoiceConnectorProxyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorProxyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutVoiceConnectorProxyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutVoiceConnectorProxyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorProxyOutputError>
}

public struct PutVoiceConnectorProxyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorProxyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutVoiceConnectorProxyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutVoiceConnectorProxyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorProxyOutputError>
}

public struct PutVoiceConnectorProxyInput: Swift.Equatable {
    /// The default number of minutes allowed for proxy sessions.
    /// This member is required.
    public var defaultSessionExpiryMinutes: Swift.Int?
    /// When true, stops proxy sessions from being created on the specified Amazon Chime Voice Connector.
    public var disabled: Swift.Bool?
    /// The phone number to route calls to after a proxy session expires.
    public var fallBackPhoneNumber: Swift.String?
    /// The countries for proxy phone numbers to be selected from.
    /// This member is required.
    public var phoneNumberPoolCountries: [Swift.String]?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        defaultSessionExpiryMinutes: Swift.Int? = nil,
        disabled: Swift.Bool? = nil,
        fallBackPhoneNumber: Swift.String? = nil,
        phoneNumberPoolCountries: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.defaultSessionExpiryMinutes = defaultSessionExpiryMinutes
        self.disabled = disabled
        self.fallBackPhoneNumber = fallBackPhoneNumber
        self.phoneNumberPoolCountries = phoneNumberPoolCountries
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorProxyInputBody: Swift.Equatable {
    public let defaultSessionExpiryMinutes: Swift.Int?
    public let phoneNumberPoolCountries: [Swift.String]?
    public let fallBackPhoneNumber: Swift.String?
    public let disabled: Swift.Bool?
}

extension PutVoiceConnectorProxyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultSessionExpiryMinutes = "DefaultSessionExpiryMinutes"
        case disabled = "Disabled"
        case fallBackPhoneNumber = "FallBackPhoneNumber"
        case phoneNumberPoolCountries = "PhoneNumberPoolCountries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultSessionExpiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultSessionExpiryMinutes)
        defaultSessionExpiryMinutes = defaultSessionExpiryMinutesDecoded
        let phoneNumberPoolCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberPoolCountries)
        var phoneNumberPoolCountriesDecoded0:[Swift.String]? = nil
        if let phoneNumberPoolCountriesContainer = phoneNumberPoolCountriesContainer {
            phoneNumberPoolCountriesDecoded0 = [Swift.String]()
            for string0 in phoneNumberPoolCountriesContainer {
                if let string0 = string0 {
                    phoneNumberPoolCountriesDecoded0?.append(string0)
                }
            }
        }
        phoneNumberPoolCountries = phoneNumberPoolCountriesDecoded0
        let fallBackPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fallBackPhoneNumber)
        fallBackPhoneNumber = fallBackPhoneNumberDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension PutVoiceConnectorProxyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutVoiceConnectorProxyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutVoiceConnectorProxyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutVoiceConnectorProxyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorProxyOutputResponse(proxy: \(Swift.String(describing: proxy)))"}
}

extension PutVoiceConnectorProxyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutVoiceConnectorProxyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proxy = output.proxy
        } else {
            self.proxy = nil
        }
    }
}

public struct PutVoiceConnectorProxyOutputResponse: Swift.Equatable {
    /// The proxy configuration details.
    public var proxy: ChimeClientTypes.Proxy?

    public init (
        proxy: ChimeClientTypes.Proxy? = nil
    )
    {
        self.proxy = proxy
    }
}

struct PutVoiceConnectorProxyOutputResponseBody: Swift.Equatable {
    public let proxy: ChimeClientTypes.Proxy?
}

extension PutVoiceConnectorProxyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxy = "Proxy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxyDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Proxy.self, forKey: .proxy)
        proxy = proxyDecoded
    }
}

public struct PutVoiceConnectorStreamingConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorStreamingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorStreamingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorStreamingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorStreamingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorStreamingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorStreamingConfigurationOutputError>
}

extension PutVoiceConnectorStreamingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorStreamingConfigurationInput(streamingConfiguration: \(Swift.String(describing: streamingConfiguration)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension PutVoiceConnectorStreamingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamingConfiguration = streamingConfiguration {
            try encodeContainer.encode(streamingConfiguration, forKey: .streamingConfiguration)
        }
    }
}

public struct PutVoiceConnectorStreamingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorStreamingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorStreamingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorStreamingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorStreamingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorStreamingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorStreamingConfigurationOutputError>
}

public struct PutVoiceConnectorStreamingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorStreamingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorStreamingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorStreamingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorStreamingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorStreamingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorStreamingConfigurationOutputError>
}

public struct PutVoiceConnectorStreamingConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorStreamingConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutVoiceConnectorStreamingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorStreamingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutVoiceConnectorStreamingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorStreamingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorStreamingConfigurationOutputError>
}

public struct PutVoiceConnectorStreamingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorStreamingConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutVoiceConnectorStreamingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorStreamingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutVoiceConnectorStreamingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorStreamingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorStreamingConfigurationOutputError>
}

public struct PutVoiceConnectorStreamingConfigurationInput: Swift.Equatable {
    /// The streaming configuration details to add.
    /// This member is required.
    public var streamingConfiguration: ChimeClientTypes.StreamingConfiguration?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        streamingConfiguration: ChimeClientTypes.StreamingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorStreamingConfigurationInputBody: Swift.Equatable {
    public let streamingConfiguration: ChimeClientTypes.StreamingConfiguration?
}

extension PutVoiceConnectorStreamingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.StreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

extension PutVoiceConnectorStreamingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutVoiceConnectorStreamingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutVoiceConnectorStreamingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutVoiceConnectorStreamingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorStreamingConfigurationOutputResponse(streamingConfiguration: \(Swift.String(describing: streamingConfiguration)))"}
}

extension PutVoiceConnectorStreamingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutVoiceConnectorStreamingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingConfiguration = output.streamingConfiguration
        } else {
            self.streamingConfiguration = nil
        }
    }
}

public struct PutVoiceConnectorStreamingConfigurationOutputResponse: Swift.Equatable {
    /// The updated streaming configuration details.
    public var streamingConfiguration: ChimeClientTypes.StreamingConfiguration?

    public init (
        streamingConfiguration: ChimeClientTypes.StreamingConfiguration? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
    }
}

struct PutVoiceConnectorStreamingConfigurationOutputResponseBody: Swift.Equatable {
    public let streamingConfiguration: ChimeClientTypes.StreamingConfiguration?
}

extension PutVoiceConnectorStreamingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.StreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

public struct PutVoiceConnectorTerminationCredentialsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorTerminationCredentialsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorTerminationCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorTerminationCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorTerminationCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorTerminationCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorTerminationCredentialsOutputError>
}

extension PutVoiceConnectorTerminationCredentialsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorTerminationCredentialsInput(credentials: \(Swift.String(describing: credentials)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension PutVoiceConnectorTerminationCredentialsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentials = credentials {
            var credentialsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .credentials)
            for credentiallist0 in credentials {
                try credentialsContainer.encode(credentiallist0)
            }
        }
    }
}

public struct PutVoiceConnectorTerminationCredentialsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorTerminationCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorTerminationCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorTerminationCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorTerminationCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorTerminationCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorTerminationCredentialsOutputError>
}

public struct PutVoiceConnectorTerminationCredentialsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorTerminationCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorTerminationCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorTerminationCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "put"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorTerminationCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorTerminationCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorTerminationCredentialsOutputError>
}

public struct PutVoiceConnectorTerminationCredentialsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorTerminationCredentialsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutVoiceConnectorTerminationCredentialsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorTerminationCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutVoiceConnectorTerminationCredentialsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorTerminationCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorTerminationCredentialsOutputError>
}

public struct PutVoiceConnectorTerminationCredentialsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorTerminationCredentialsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutVoiceConnectorTerminationCredentialsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorTerminationCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutVoiceConnectorTerminationCredentialsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorTerminationCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorTerminationCredentialsOutputError>
}

public struct PutVoiceConnectorTerminationCredentialsInput: Swift.Equatable {
    /// The termination SIP credentials.
    public var credentials: [ChimeClientTypes.Credential]?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        credentials: [ChimeClientTypes.Credential]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.credentials = credentials
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorTerminationCredentialsInputBody: Swift.Equatable {
    public let credentials: [ChimeClientTypes.Credential]?
}

extension PutVoiceConnectorTerminationCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Credential?].self, forKey: .credentials)
        var credentialsDecoded0:[ChimeClientTypes.Credential]? = nil
        if let credentialsContainer = credentialsContainer {
            credentialsDecoded0 = [ChimeClientTypes.Credential]()
            for structure0 in credentialsContainer {
                if let structure0 = structure0 {
                    credentialsDecoded0?.append(structure0)
                }
            }
        }
        credentials = credentialsDecoded0
    }
}

extension PutVoiceConnectorTerminationCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutVoiceConnectorTerminationCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutVoiceConnectorTerminationCredentialsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutVoiceConnectorTerminationCredentialsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorTerminationCredentialsOutputResponse()"}
}

extension PutVoiceConnectorTerminationCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutVoiceConnectorTerminationCredentialsOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutVoiceConnectorTerminationCredentialsOutputResponseBody: Swift.Equatable {
}

extension PutVoiceConnectorTerminationCredentialsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutVoiceConnectorTerminationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorTerminationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorTerminationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorTerminationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorTerminationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorTerminationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorTerminationOutputError>
}

extension PutVoiceConnectorTerminationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorTerminationInput(termination: \(Swift.String(describing: termination)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension PutVoiceConnectorTerminationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let termination = termination {
            try encodeContainer.encode(termination, forKey: .termination)
        }
    }
}

public struct PutVoiceConnectorTerminationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorTerminationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorTerminationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorTerminationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorTerminationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorTerminationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorTerminationOutputError>
}

public struct PutVoiceConnectorTerminationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorTerminationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutVoiceConnectorTerminationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorTerminationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutVoiceConnectorTerminationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorTerminationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorTerminationOutputError>
}

public struct PutVoiceConnectorTerminationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorTerminationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutVoiceConnectorTerminationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorTerminationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutVoiceConnectorTerminationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorTerminationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorTerminationOutputError>
}

public struct PutVoiceConnectorTerminationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutVoiceConnectorTerminationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutVoiceConnectorTerminationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutVoiceConnectorTerminationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutVoiceConnectorTerminationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutVoiceConnectorTerminationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutVoiceConnectorTerminationOutputError>
}

public struct PutVoiceConnectorTerminationInput: Swift.Equatable {
    /// The termination setting details to add.
    /// This member is required.
    public var termination: ChimeClientTypes.Termination?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        termination: ChimeClientTypes.Termination? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.termination = termination
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorTerminationInputBody: Swift.Equatable {
    public let termination: ChimeClientTypes.Termination?
}

extension PutVoiceConnectorTerminationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Termination.self, forKey: .termination)
        termination = terminationDecoded
    }
}

extension PutVoiceConnectorTerminationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutVoiceConnectorTerminationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutVoiceConnectorTerminationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutVoiceConnectorTerminationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorTerminationOutputResponse(termination: \(Swift.String(describing: termination)))"}
}

extension PutVoiceConnectorTerminationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutVoiceConnectorTerminationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.termination = output.termination
        } else {
            self.termination = nil
        }
    }
}

public struct PutVoiceConnectorTerminationOutputResponse: Swift.Equatable {
    /// The updated termination setting details.
    public var termination: ChimeClientTypes.Termination?

    public init (
        termination: ChimeClientTypes.Termination? = nil
    )
    {
        self.termination = termination
    }
}

struct PutVoiceConnectorTerminationOutputResponseBody: Swift.Equatable {
    public let termination: ChimeClientTypes.Termination?
}

extension PutVoiceConnectorTerminationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Termination.self, forKey: .termination)
        termination = terminationDecoded
    }
}

extension RedactChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedactChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), messageId: \(Swift.String(describing: messageId)))"}
}

extension RedactChannelMessageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RedactChannelMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactChannelMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RedactChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RedactChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactChannelMessageOutputError>
}

public struct RedactChannelMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactChannelMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RedactChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "redact"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RedactChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactChannelMessageOutputError>
}

public struct RedactChannelMessageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactChannelMessageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RedactChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RedactChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactChannelMessageOutputError>
}

public struct RedactChannelMessageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactChannelMessageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RedactChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let messageId = input.messageId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("messageId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RedactChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<RedactChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactChannelMessageOutputError>
}

public struct RedactChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel containing the messages that you want to redact.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ID of the message being redacted.
    /// This member is required.
    public var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

struct RedactChannelMessageInputBody: Swift.Equatable {
}

extension RedactChannelMessageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RedactChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RedactChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RedactChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RedactChannelMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedactChannelMessageOutputResponse(channelArn: \(Swift.String(describing: channelArn)), messageId: \(Swift.String(describing: messageId)))"}
}

extension RedactChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RedactChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.messageId = output.messageId
        } else {
            self.channelArn = nil
            self.messageId = nil
        }
    }
}

public struct RedactChannelMessageOutputResponse: Swift.Equatable {
    /// The ARN of the channel containing the messages that you want to redact.
    public var channelArn: Swift.String?
    /// The ID of the message being redacted.
    public var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
    }
}

struct RedactChannelMessageOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let messageId: Swift.String?
}

extension RedactChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case messageId = "MessageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension RedactConversationMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedactConversationMessageInput(accountId: \(Swift.String(describing: accountId)), conversationId: \(Swift.String(describing: conversationId)), messageId: \(Swift.String(describing: messageId)))"}
}

extension RedactConversationMessageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RedactConversationMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactConversationMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RedactConversationMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactConversationMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RedactConversationMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RedactConversationMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactConversationMessageOutputError>
}

public struct RedactConversationMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactConversationMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RedactConversationMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactConversationMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "redact"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RedactConversationMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RedactConversationMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactConversationMessageOutputError>
}

public struct RedactConversationMessageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactConversationMessageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RedactConversationMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactConversationMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RedactConversationMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<RedactConversationMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactConversationMessageOutputError>
}

public struct RedactConversationMessageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactConversationMessageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RedactConversationMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactConversationMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let conversationId = input.conversationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("conversationId is nil and needs a value for the path of this operation"))))
        }
        guard let messageId = input.messageId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("messageId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/conversations/\(conversationId.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RedactConversationMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<RedactConversationMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactConversationMessageOutputError>
}

public struct RedactConversationMessageInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The conversation ID.
    /// This member is required.
    public var conversationId: Swift.String?
    /// The message ID.
    /// This member is required.
    public var messageId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        conversationId: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.conversationId = conversationId
        self.messageId = messageId
    }
}

struct RedactConversationMessageInputBody: Swift.Equatable {
}

extension RedactConversationMessageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RedactConversationMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RedactConversationMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RedactConversationMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RedactConversationMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedactConversationMessageOutputResponse()"}
}

extension RedactConversationMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RedactConversationMessageOutputResponse: Swift.Equatable {

    public init() {}
}

struct RedactConversationMessageOutputResponseBody: Swift.Equatable {
}

extension RedactConversationMessageOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RedactRoomMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedactRoomMessageInput(accountId: \(Swift.String(describing: accountId)), messageId: \(Swift.String(describing: messageId)), roomId: \(Swift.String(describing: roomId)))"}
}

extension RedactRoomMessageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RedactRoomMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactRoomMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RedactRoomMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactRoomMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RedactRoomMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RedactRoomMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactRoomMessageOutputError>
}

public struct RedactRoomMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactRoomMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RedactRoomMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactRoomMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "redact"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RedactRoomMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RedactRoomMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactRoomMessageOutputError>
}

public struct RedactRoomMessageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactRoomMessageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RedactRoomMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactRoomMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RedactRoomMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<RedactRoomMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactRoomMessageOutputError>
}

public struct RedactRoomMessageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RedactRoomMessageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RedactRoomMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RedactRoomMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let roomId = input.roomId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("roomId is nil and needs a value for the path of this operation"))))
        }
        guard let messageId = input.messageId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("messageId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RedactRoomMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<RedactRoomMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RedactRoomMessageOutputError>
}

public struct RedactRoomMessageInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The message ID.
    /// This member is required.
    public var messageId: Swift.String?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        messageId: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.messageId = messageId
        self.roomId = roomId
    }
}

struct RedactRoomMessageInputBody: Swift.Equatable {
}

extension RedactRoomMessageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RedactRoomMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RedactRoomMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RedactRoomMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RedactRoomMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedactRoomMessageOutputResponse()"}
}

extension RedactRoomMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RedactRoomMessageOutputResponse: Swift.Equatable {

    public init() {}
}

struct RedactRoomMessageOutputResponseBody: Swift.Equatable {
}

extension RedactRoomMessageOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RegenerateSecurityTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegenerateSecurityTokenInput(accountId: \(Swift.String(describing: accountId)), botId: \(Swift.String(describing: botId)))"}
}

extension RegenerateSecurityTokenInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RegenerateSecurityTokenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegenerateSecurityTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegenerateSecurityTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegenerateSecurityTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegenerateSecurityTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegenerateSecurityTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegenerateSecurityTokenOutputError>
}

public struct RegenerateSecurityTokenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegenerateSecurityTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegenerateSecurityTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegenerateSecurityTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "regenerate-security-token"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegenerateSecurityTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegenerateSecurityTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegenerateSecurityTokenOutputError>
}

public struct RegenerateSecurityTokenInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegenerateSecurityTokenInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RegenerateSecurityTokenInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegenerateSecurityTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegenerateSecurityTokenInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegenerateSecurityTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegenerateSecurityTokenOutputError>
}

public struct RegenerateSecurityTokenInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegenerateSecurityTokenInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RegenerateSecurityTokenInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegenerateSecurityTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let botId = input.botId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("botId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegenerateSecurityTokenInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegenerateSecurityTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegenerateSecurityTokenOutputError>
}

public struct RegenerateSecurityTokenInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
    }
}

struct RegenerateSecurityTokenInputBody: Swift.Equatable {
}

extension RegenerateSecurityTokenInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RegenerateSecurityTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegenerateSecurityTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegenerateSecurityTokenOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegenerateSecurityTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegenerateSecurityTokenOutputResponse(bot: \(Swift.String(describing: bot)))"}
}

extension RegenerateSecurityTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegenerateSecurityTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bot = output.bot
        } else {
            self.bot = nil
        }
    }
}

public struct RegenerateSecurityTokenOutputResponse: Swift.Equatable {
    /// A resource that allows Enterprise account administrators to configure an interface to receive events from Amazon Chime.
    public var bot: ChimeClientTypes.Bot?

    public init (
        bot: ChimeClientTypes.Bot? = nil
    )
    {
        self.bot = bot
    }
}

struct RegenerateSecurityTokenOutputResponseBody: Swift.Equatable {
    public let bot: ChimeClientTypes.Bot?
}

extension RegenerateSecurityTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bot = "Bot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Bot.self, forKey: .bot)
        bot = botDecoded
    }
}

extension ChimeClientTypes {
    public enum RegistrationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case registered
        case suspended
        case unregistered
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationStatus] {
            return [
                .registered,
                .suspended,
                .unregistered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .registered: return "Registered"
            case .suspended: return "Suspended"
            case .unregistered: return "Unregistered"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegistrationStatus(rawValue: rawValue) ?? RegistrationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResetPersonalPINInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetPersonalPINInput(accountId: \(Swift.String(describing: accountId)), userId: \(Swift.String(describing: userId)))"}
}

extension ResetPersonalPINInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ResetPersonalPINInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetPersonalPINInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetPersonalPINInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetPersonalPINOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetPersonalPINInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetPersonalPINOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetPersonalPINOutputError>
}

public struct ResetPersonalPINInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetPersonalPINInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetPersonalPINInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetPersonalPINOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "reset-personal-pin"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetPersonalPINInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetPersonalPINOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetPersonalPINOutputError>
}

public struct ResetPersonalPINInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetPersonalPINInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ResetPersonalPINInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetPersonalPINOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResetPersonalPINInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResetPersonalPINOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetPersonalPINOutputError>
}

public struct ResetPersonalPINInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetPersonalPINInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ResetPersonalPINInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetPersonalPINOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let userId = input.userId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("userId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResetPersonalPINInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResetPersonalPINOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetPersonalPINOutputError>
}

public struct ResetPersonalPINInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
    }
}

struct ResetPersonalPINInputBody: Swift.Equatable {
}

extension ResetPersonalPINInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResetPersonalPINOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetPersonalPINOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetPersonalPINOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetPersonalPINOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetPersonalPINOutputResponse(user: \(Swift.String(describing: user)))"}
}

extension ResetPersonalPINOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResetPersonalPINOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct ResetPersonalPINOutputResponse: Swift.Equatable {
    /// The user details and new personal meeting PIN.
    public var user: ChimeClientTypes.User?

    public init (
        user: ChimeClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct ResetPersonalPINOutputResponseBody: Swift.Equatable {
    public let user: ChimeClientTypes.User?
}

extension ResetPersonalPINOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

extension ResourceLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceLimitExceededException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    public let code: ChimeClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestorePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestorePhoneNumberInput(phoneNumberId: \(Swift.String(describing: phoneNumberId)))"}
}

extension RestorePhoneNumberInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RestorePhoneNumberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestorePhoneNumberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestorePhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestorePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestorePhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestorePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestorePhoneNumberOutputError>
}

public struct RestorePhoneNumberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestorePhoneNumberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestorePhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestorePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "restore"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestorePhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestorePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestorePhoneNumberOutputError>
}

public struct RestorePhoneNumberInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestorePhoneNumberInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RestorePhoneNumberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestorePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RestorePhoneNumberInput
    public typealias MOutput = ClientRuntime.OperationOutput<RestorePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestorePhoneNumberOutputError>
}

public struct RestorePhoneNumberInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestorePhoneNumberInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RestorePhoneNumberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestorePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let phoneNumberId = input.phoneNumberId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("phoneNumberId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RestorePhoneNumberInput
    public typealias MOutput = ClientRuntime.OperationOutput<RestorePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestorePhoneNumberOutputError>
}

public struct RestorePhoneNumberInput: Swift.Equatable {
    /// The phone number.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init (
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct RestorePhoneNumberInputBody: Swift.Equatable {
}

extension RestorePhoneNumberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RestorePhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestorePhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestorePhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestorePhoneNumberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestorePhoneNumberOutputResponse(phoneNumber: \(Swift.String(describing: phoneNumber)))"}
}

extension RestorePhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestorePhoneNumberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumber = output.phoneNumber
        } else {
            self.phoneNumber = nil
        }
    }
}

public struct RestorePhoneNumberOutputResponse: Swift.Equatable {
    /// The phone number details.
    public var phoneNumber: ChimeClientTypes.PhoneNumber?

    public init (
        phoneNumber: ChimeClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct RestorePhoneNumberOutputResponseBody: Swift.Equatable {
    public let phoneNumber: ChimeClientTypes.PhoneNumber?
}

extension RestorePhoneNumberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumber.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension ChimeClientTypes.RetentionSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversationRetentionSettings = "ConversationRetentionSettings"
        case roomRetentionSettings = "RoomRetentionSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversationRetentionSettings = conversationRetentionSettings {
            try encodeContainer.encode(conversationRetentionSettings, forKey: .conversationRetentionSettings)
        }
        if let roomRetentionSettings = roomRetentionSettings {
            try encodeContainer.encode(roomRetentionSettings, forKey: .roomRetentionSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RoomRetentionSettings.self, forKey: .roomRetentionSettings)
        roomRetentionSettings = roomRetentionSettingsDecoded
        let conversationRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ConversationRetentionSettings.self, forKey: .conversationRetentionSettings)
        conversationRetentionSettings = conversationRetentionSettingsDecoded
    }
}

extension ChimeClientTypes.RetentionSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetentionSettings(conversationRetentionSettings: \(Swift.String(describing: conversationRetentionSettings)), roomRetentionSettings: \(Swift.String(describing: roomRetentionSettings)))"}
}

extension ChimeClientTypes {
    /// The retention settings for an Amazon Chime Enterprise account that determine how long to retain items such as chat-room messages and chat-conversation messages.
    public struct RetentionSettings: Swift.Equatable {
        /// The chat conversation retention settings.
        public var conversationRetentionSettings: ChimeClientTypes.ConversationRetentionSettings?
        /// The chat room retention settings.
        public var roomRetentionSettings: ChimeClientTypes.RoomRetentionSettings?

        public init (
            conversationRetentionSettings: ChimeClientTypes.ConversationRetentionSettings? = nil,
            roomRetentionSettings: ChimeClientTypes.RoomRetentionSettings? = nil
        )
        {
            self.conversationRetentionSettings = conversationRetentionSettings
            self.roomRetentionSettings = roomRetentionSettings
        }
    }

}

extension ChimeClientTypes.Room: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case name = "Name"
        case roomId = "RoomId"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roomId = roomId {
            try encodeContainer.encode(roomId, forKey: .roomId)
        }
        if let updatedTimestamp = updatedTimestamp {
            try encodeContainer.encode(updatedTimestamp.timeIntervalSince1970, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomId)
        roomId = roomIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeClientTypes.Room: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Room(accountId: \(Swift.String(describing: accountId)), createdBy: \(Swift.String(describing: createdBy)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), name: \(Swift.String(describing: name)), roomId: \(Swift.String(describing: roomId)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)))"}
}

extension ChimeClientTypes {
    /// The Amazon Chime chat room details.
    public struct Room: Swift.Equatable {
        /// The Amazon Chime account ID.
        public var accountId: Swift.String?
        /// The identifier of the room creator.
        public var createdBy: Swift.String?
        /// The room creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The room name.
        public var name: Swift.String?
        /// The room ID.
        public var roomId: Swift.String?
        /// The room update timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            accountId: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roomId: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.accountId = accountId
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.name = name
            self.roomId = roomId
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes.RoomMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitedBy = "InvitedBy"
        case member = "Member"
        case role = "Role"
        case roomId = "RoomId"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invitedBy = invitedBy {
            try encodeContainer.encode(invitedBy, forKey: .invitedBy)
        }
        if let member = member {
            try encodeContainer.encode(member, forKey: .member)
        }
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let roomId = roomId {
            try encodeContainer.encode(roomId, forKey: .roomId)
        }
        if let updatedTimestamp = updatedTimestamp {
            try encodeContainer.encode(updatedTimestamp.timeIntervalSince1970, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomId)
        roomId = roomIdDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Member.self, forKey: .member)
        member = memberDecoded
        let roleDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RoomMembershipRole.self, forKey: .role)
        role = roleDecoded
        let invitedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitedBy)
        invitedBy = invitedByDecoded
        let updatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeClientTypes.RoomMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoomMembership(invitedBy: \(Swift.String(describing: invitedBy)), member: \(Swift.String(describing: member)), role: \(Swift.String(describing: role)), roomId: \(Swift.String(describing: roomId)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)))"}
}

extension ChimeClientTypes {
    /// The room membership details.
    public struct RoomMembership: Swift.Equatable {
        /// The identifier of the user that invited the room member.
        public var invitedBy: Swift.String?
        /// The member details, such as email address, name, member ID, and member type.
        public var member: ChimeClientTypes.Member?
        /// The membership role.
        public var role: ChimeClientTypes.RoomMembershipRole?
        /// The room ID.
        public var roomId: Swift.String?
        /// The room membership update timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            invitedBy: Swift.String? = nil,
            member: ChimeClientTypes.Member? = nil,
            role: ChimeClientTypes.RoomMembershipRole? = nil,
            roomId: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.invitedBy = invitedBy
            self.member = member
            self.role = role
            self.roomId = roomId
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes {
    public enum RoomMembershipRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case administrator
        case member
        case sdkUnknown(Swift.String)

        public static var allCases: [RoomMembershipRole] {
            return [
                .administrator,
                .member,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .administrator: return "Administrator"
            case .member: return "Member"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RoomMembershipRole(rawValue: rawValue) ?? RoomMembershipRole.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.RoomRetentionSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionDays = "RetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionDays = retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
    }
}

extension ChimeClientTypes.RoomRetentionSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoomRetentionSettings(retentionDays: \(Swift.String(describing: retentionDays)))"}
}

extension ChimeClientTypes {
    /// The retention settings that determine how long to retain chat-room messages for an Amazon Chime Enterprise account.
    public struct RoomRetentionSettings: Swift.Equatable {
        /// The number of days for which to retain chat-room messages.
        public var retentionDays: Swift.Int?

        public init (
            retentionDays: Swift.Int? = nil
        )
        {
            self.retentionDays = retentionDays
        }
    }

}

extension SearchAvailablePhoneNumbersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchAvailablePhoneNumbersInput(areaCode: \(Swift.String(describing: areaCode)), city: \(Swift.String(describing: city)), country: \(Swift.String(describing: country)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), phoneNumberType: \(Swift.String(describing: phoneNumberType)), state: \(Swift.String(describing: state)), tollFreePrefix: \(Swift.String(describing: tollFreePrefix)))"}
}

extension SearchAvailablePhoneNumbersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct SearchAvailablePhoneNumbersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchAvailablePhoneNumbersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchAvailablePhoneNumbersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchAvailablePhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchAvailablePhoneNumbersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchAvailablePhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchAvailablePhoneNumbersOutputError>
}

public struct SearchAvailablePhoneNumbersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchAvailablePhoneNumbersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchAvailablePhoneNumbersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchAvailablePhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "type", value: "phone-numbers"))
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let state = input.operationInput.state {
            let stateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state).urlPercentEncoding())
            input.builder.withQueryItem(stateQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let areaCode = input.operationInput.areaCode {
            let areaCodeQueryItem = ClientRuntime.URLQueryItem(name: "area-code".urlPercentEncoding(), value: Swift.String(areaCode).urlPercentEncoding())
            input.builder.withQueryItem(areaCodeQueryItem)
        }
        if let country = input.operationInput.country {
            let countryQueryItem = ClientRuntime.URLQueryItem(name: "country".urlPercentEncoding(), value: Swift.String(country).urlPercentEncoding())
            input.builder.withQueryItem(countryQueryItem)
        }
        if let city = input.operationInput.city {
            let cityQueryItem = ClientRuntime.URLQueryItem(name: "city".urlPercentEncoding(), value: Swift.String(city).urlPercentEncoding())
            input.builder.withQueryItem(cityQueryItem)
        }
        if let phoneNumberType = input.operationInput.phoneNumberType {
            let phoneNumberTypeQueryItem = ClientRuntime.URLQueryItem(name: "phone-number-type".urlPercentEncoding(), value: Swift.String(phoneNumberType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(phoneNumberTypeQueryItem)
        }
        if let tollFreePrefix = input.operationInput.tollFreePrefix {
            let tollFreePrefixQueryItem = ClientRuntime.URLQueryItem(name: "toll-free-prefix".urlPercentEncoding(), value: Swift.String(tollFreePrefix).urlPercentEncoding())
            input.builder.withQueryItem(tollFreePrefixQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchAvailablePhoneNumbersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchAvailablePhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchAvailablePhoneNumbersOutputError>
}

public struct SearchAvailablePhoneNumbersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchAvailablePhoneNumbersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: SearchAvailablePhoneNumbersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchAvailablePhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SearchAvailablePhoneNumbersInput
    public typealias MOutput = ClientRuntime.OperationOutput<SearchAvailablePhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchAvailablePhoneNumbersOutputError>
}

public struct SearchAvailablePhoneNumbersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchAvailablePhoneNumbersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: SearchAvailablePhoneNumbersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchAvailablePhoneNumbersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/search"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SearchAvailablePhoneNumbersInput
    public typealias MOutput = ClientRuntime.OperationOutput<SearchAvailablePhoneNumbersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchAvailablePhoneNumbersOutputError>
}

public struct SearchAvailablePhoneNumbersInput: Swift.Equatable {
    /// The area code used to filter results. Only applies to the US.
    public var areaCode: Swift.String?
    /// The city used to filter results. Only applies to the US.
    public var city: Swift.String?
    /// The country used to filter results. Defaults to the US Format: ISO 3166-1 alpha-2.
    public var country: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The phone number type used to filter results. Required for non-US numbers.
    public var phoneNumberType: ChimeClientTypes.PhoneNumberType?
    /// The state used to filter results. Required only if you provide City. Only applies to the US.
    public var state: Swift.String?
    /// The toll-free prefix that you use to filter results. Only applies to the US.
    public var tollFreePrefix: Swift.String?

    public init (
        areaCode: Swift.String? = nil,
        city: Swift.String? = nil,
        country: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        phoneNumberType: ChimeClientTypes.PhoneNumberType? = nil,
        state: Swift.String? = nil,
        tollFreePrefix: Swift.String? = nil
    )
    {
        self.areaCode = areaCode
        self.city = city
        self.country = country
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberType = phoneNumberType
        self.state = state
        self.tollFreePrefix = tollFreePrefix
    }
}

struct SearchAvailablePhoneNumbersInputBody: Swift.Equatable {
}

extension SearchAvailablePhoneNumbersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SearchAvailablePhoneNumbersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchAvailablePhoneNumbersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchAvailablePhoneNumbersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchAvailablePhoneNumbersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchAvailablePhoneNumbersOutputResponse(e164PhoneNumbers: \(Swift.String(describing: e164PhoneNumbers)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension SearchAvailablePhoneNumbersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchAvailablePhoneNumbersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.e164PhoneNumbers = output.e164PhoneNumbers
            self.nextToken = output.nextToken
        } else {
            self.e164PhoneNumbers = nil
            self.nextToken = nil
        }
    }
}

public struct SearchAvailablePhoneNumbersOutputResponse: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    public var e164PhoneNumbers: [Swift.String]?
    /// The token used to retrieve the next page of search results.
    public var nextToken: Swift.String?

    public init (
        e164PhoneNumbers: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.nextToken = nextToken
    }
}

struct SearchAvailablePhoneNumbersOutputResponseBody: Swift.Equatable {
    public let e164PhoneNumbers: [Swift.String]?
    public let nextToken: Swift.String?
}

extension SearchAvailablePhoneNumbersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct SendChannelMessageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendChannelMessageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendChannelMessageOutputError>
}

extension SendChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), content: \(Swift.String(describing: content)), metadata: \(Swift.String(describing: metadata)), persistence: \(Swift.String(describing: persistence)), type: \(Swift.String(describing: type)))"}
}

extension SendChannelMessageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case metadata = "Metadata"
        case persistence = "Persistence"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let persistence = persistence {
            try encodeContainer.encode(persistence.rawValue, forKey: .persistence)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct SendChannelMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendChannelMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendChannelMessageOutputError>
}

public struct SendChannelMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendChannelMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendChannelMessageOutputError>
}

public struct SendChannelMessageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendChannelMessageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: SendChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendChannelMessageOutputError>
}

public struct SendChannelMessageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendChannelMessageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: SendChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/messages"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendChannelMessageOutputError>
}

public struct SendChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The Idempotency token for each client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The content of the message.
    /// This member is required.
    public var content: Swift.String?
    /// The optional metadata for each message.
    public var metadata: Swift.String?
    /// Boolean that controls whether the message is persisted on the back end. Required.
    /// This member is required.
    public var persistence: ChimeClientTypes.ChannelMessagePersistenceType?
    /// The type of message, STANDARD or CONTROL.
    /// This member is required.
    public var type: ChimeClientTypes.ChannelMessageType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        metadata: Swift.String? = nil,
        persistence: ChimeClientTypes.ChannelMessagePersistenceType? = nil,
        type: ChimeClientTypes.ChannelMessageType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.metadata = metadata
        self.persistence = persistence
        self.type = type
    }
}

struct SendChannelMessageInputBody: Swift.Equatable {
    public let content: Swift.String?
    public let type: ChimeClientTypes.ChannelMessageType?
    public let persistence: ChimeClientTypes.ChannelMessagePersistenceType?
    public let metadata: Swift.String?
    public let clientRequestToken: Swift.String?
}

extension SendChannelMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case metadata = "Metadata"
        case persistence = "Persistence"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMessageType.self, forKey: .type)
        type = typeDecoded
        let persistenceDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMessagePersistenceType.self, forKey: .persistence)
        persistence = persistenceDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension SendChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendChannelMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendChannelMessageOutputResponse(channelArn: \(Swift.String(describing: channelArn)), messageId: \(Swift.String(describing: messageId)))"}
}

extension SendChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.messageId = output.messageId
        } else {
            self.channelArn = nil
            self.messageId = nil
        }
    }
}

public struct SendChannelMessageOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ID string assigned to each message.
    public var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
    }
}

struct SendChannelMessageOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let messageId: Swift.String?
}

extension SendChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case messageId = "MessageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension ServiceFailureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceFailureException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ServiceFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    public let code: ChimeClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let code: ChimeClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeClientTypes.SigninDelegateGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension ChimeClientTypes.SigninDelegateGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SigninDelegateGroup(groupName: \(Swift.String(describing: groupName)))"}
}

extension ChimeClientTypes {
    /// An Active Directory (AD) group whose members are granted permission to act as delegates.
    public struct SigninDelegateGroup: Swift.Equatable {
        /// The group name.
        public var groupName: Swift.String?

        public init (
            groupName: Swift.String? = nil
        )
        {
            self.groupName = groupName
        }
    }

}

extension ChimeClientTypes.SipMediaApplication: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case createdTimestamp = "CreatedTimestamp"
        case endpoints = "Endpoints"
        case name = "Name"
        case sipMediaApplicationId = "SipMediaApplicationId"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for sipmediaapplicationendpointlist0 in endpoints {
                try endpointsContainer.encode(sipmediaapplicationendpointlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sipMediaApplicationId = sipMediaApplicationId {
            try encodeContainer.encode(sipMediaApplicationId, forKey: .sipMediaApplicationId)
        }
        if let updatedTimestamp = updatedTimestamp {
            try encodeContainer.encode(updatedTimestamp.timeIntervalSince1970, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipMediaApplicationId)
        sipMediaApplicationId = sipMediaApplicationIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipMediaApplicationEndpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[ChimeClientTypes.SipMediaApplicationEndpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [ChimeClientTypes.SipMediaApplicationEndpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeClientTypes.SipMediaApplication: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SipMediaApplication(awsRegion: \(Swift.String(describing: awsRegion)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), endpoints: \(Swift.String(describing: endpoints)), name: \(Swift.String(describing: name)), sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)))"}
}

extension ChimeClientTypes {
    /// The details of the SIP media application, including name and endpoints. An AWS account can have multiple SIP media applications.
    public struct SipMediaApplication: Swift.Equatable {
        /// The AWS Region in which the SIP media application is created.
        public var awsRegion: Swift.String?
        /// The SIP media application creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// List of endpoints for SIP media application. Currently, only one endpoint per SIP media application is permitted.
        public var endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]?
        /// The name of the SIP media application.
        public var name: Swift.String?
        /// The SIP media application ID.
        public var sipMediaApplicationId: Swift.String?
        /// The SIP media application updated timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            awsRegion: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]? = nil,
            name: Swift.String? = nil,
            sipMediaApplicationId: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.awsRegion = awsRegion
            self.createdTimestamp = createdTimestamp
            self.endpoints = endpoints
            self.name = name
            self.sipMediaApplicationId = sipMediaApplicationId
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes.SipMediaApplicationCall: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension ChimeClientTypes.SipMediaApplicationCall: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SipMediaApplicationCall(transactionId: \(Swift.String(describing: transactionId)))"}
}

extension ChimeClientTypes {
    /// A Call instance for a SIP media application.
    public struct SipMediaApplicationCall: Swift.Equatable {
        /// The transaction ID of a call.
        public var transactionId: Swift.String?

        public init (
            transactionId: Swift.String? = nil
        )
        {
            self.transactionId = transactionId
        }
    }

}

extension ChimeClientTypes.SipMediaApplicationEndpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaArn = "LambdaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaArn = lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
    }
}

extension ChimeClientTypes.SipMediaApplicationEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SipMediaApplicationEndpoint(lambdaArn: \(Swift.String(describing: lambdaArn)))"}
}

extension ChimeClientTypes {
    /// The endpoint assigned to the SIP media application.
    public struct SipMediaApplicationEndpoint: Swift.Equatable {
        /// Valid Amazon Resource Name (ARN) of the Lambda function. The function must be created in the same AWS Region as the SIP media application.
        public var lambdaArn: Swift.String?

        public init (
            lambdaArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
        }
    }

}

extension ChimeClientTypes.SipMediaApplicationLoggingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableSipMediaApplicationMessageLogs = "EnableSipMediaApplicationMessageLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableSipMediaApplicationMessageLogs = enableSipMediaApplicationMessageLogs {
            try encodeContainer.encode(enableSipMediaApplicationMessageLogs, forKey: .enableSipMediaApplicationMessageLogs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableSipMediaApplicationMessageLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSipMediaApplicationMessageLogs)
        enableSipMediaApplicationMessageLogs = enableSipMediaApplicationMessageLogsDecoded
    }
}

extension ChimeClientTypes.SipMediaApplicationLoggingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SipMediaApplicationLoggingConfiguration(enableSipMediaApplicationMessageLogs: \(Swift.String(describing: enableSipMediaApplicationMessageLogs)))"}
}

extension ChimeClientTypes {
    /// Logging configuration of the SIP media application.
    public struct SipMediaApplicationLoggingConfiguration: Swift.Equatable {
        /// Enables application message logs for the SIP media application.
        public var enableSipMediaApplicationMessageLogs: Swift.Bool?

        public init (
            enableSipMediaApplicationMessageLogs: Swift.Bool? = nil
        )
        {
            self.enableSipMediaApplicationMessageLogs = enableSipMediaApplicationMessageLogs
        }
    }

}

extension ChimeClientTypes.SipRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case disabled = "Disabled"
        case name = "Name"
        case sipRuleId = "SipRuleId"
        case targetApplications = "TargetApplications"
        case triggerType = "TriggerType"
        case triggerValue = "TriggerValue"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let disabled = disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sipRuleId = sipRuleId {
            try encodeContainer.encode(sipRuleId, forKey: .sipRuleId)
        }
        if let targetApplications = targetApplications {
            var targetApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetApplications)
            for sipruletargetapplicationlist0 in targetApplications {
                try targetApplicationsContainer.encode(sipruletargetapplicationlist0)
            }
        }
        if let triggerType = triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
        if let triggerValue = triggerValue {
            try encodeContainer.encode(triggerValue, forKey: .triggerValue)
        }
        if let updatedTimestamp = updatedTimestamp {
            try encodeContainer.encode(updatedTimestamp.timeIntervalSince1970, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipRuleId)
        sipRuleId = sipRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let triggerTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipRuleTriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .triggerValue)
        triggerValue = triggerValueDecoded
        let targetApplicationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipRuleTargetApplication?].self, forKey: .targetApplications)
        var targetApplicationsDecoded0:[ChimeClientTypes.SipRuleTargetApplication]? = nil
        if let targetApplicationsContainer = targetApplicationsContainer {
            targetApplicationsDecoded0 = [ChimeClientTypes.SipRuleTargetApplication]()
            for structure0 in targetApplicationsContainer {
                if let structure0 = structure0 {
                    targetApplicationsDecoded0?.append(structure0)
                }
            }
        }
        targetApplications = targetApplicationsDecoded0
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeClientTypes.SipRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SipRule(createdTimestamp: \(Swift.String(describing: createdTimestamp)), disabled: \(Swift.String(describing: disabled)), name: \(Swift.String(describing: name)), sipRuleId: \(Swift.String(describing: sipRuleId)), targetApplications: \(Swift.String(describing: targetApplications)), triggerType: \(Swift.String(describing: triggerType)), triggerValue: \(Swift.String(describing: triggerValue)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)))"}
}

extension ChimeClientTypes {
    /// The SIP rule details, including name, triggers, and target applications. An AWS account can have multiple SIP rules.
    public struct SipRule: Swift.Equatable {
        /// The time at which the SIP rule was created, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// Indicates whether the SIP rule is enabled or disabled. You must disable a rule before you can delete it.
        public var disabled: Swift.Bool?
        /// The name of the SIP rule.
        public var name: Swift.String?
        /// The SIP rule ID.
        public var sipRuleId: Swift.String?
        /// Target SIP media application and other details, such as priority and AWS Region, to be
        ///             specified in the SIP rule. Only one SIP rule per AWS Region can be provided.
        public var targetApplications: [ChimeClientTypes.SipRuleTargetApplication]?
        /// The type of trigger assigned to the SIP rule in TriggerValue, currently RequestUriHostname or
        ///         ToPhoneNumber.
        public var triggerType: ChimeClientTypes.SipRuleTriggerType?
        /// If TriggerType is RequestUriHostname, then the value can be the
        ///             outbound host name of the Amazon Chime Voice Connector. If TriggerType is
        ///                 ToPhoneNumber, then the value can be a customer-owned phone number in
        ///             E164 format. SipRule is triggered when a SIP rule requests host name or
        ///                 ToPhoneNumber matches in the incoming SIP request.
        public var triggerValue: Swift.String?
        /// The time at which the SIP rule was last updated, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            createdTimestamp: ClientRuntime.Date? = nil,
            disabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            sipRuleId: Swift.String? = nil,
            targetApplications: [ChimeClientTypes.SipRuleTargetApplication]? = nil,
            triggerType: ChimeClientTypes.SipRuleTriggerType? = nil,
            triggerValue: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.disabled = disabled
            self.name = name
            self.sipRuleId = sipRuleId
            self.targetApplications = targetApplications
            self.triggerType = triggerType
            self.triggerValue = triggerValue
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes.SipRuleTargetApplication: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case priority = "Priority"
        case sipMediaApplicationId = "SipMediaApplicationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let sipMediaApplicationId = sipMediaApplicationId {
            try encodeContainer.encode(sipMediaApplicationId, forKey: .sipMediaApplicationId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipMediaApplicationId)
        sipMediaApplicationId = sipMediaApplicationIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension ChimeClientTypes.SipRuleTargetApplication: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SipRuleTargetApplication(awsRegion: \(Swift.String(describing: awsRegion)), priority: \(Swift.String(describing: priority)), sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)))"}
}

extension ChimeClientTypes {
    /// Target SIP media application and other details, such as priority and AWS Region, to be
    ///             specified in the SIP rule. Only one SIP rule per AWS Region can be provided.
    public struct SipRuleTargetApplication: Swift.Equatable {
        /// The AWS Region of the target application.
        public var awsRegion: Swift.String?
        /// Priority of the SIP media application in the target list.
        public var priority: Swift.Int?
        /// The SIP media application ID.
        public var sipMediaApplicationId: Swift.String?

        public init (
            awsRegion: Swift.String? = nil,
            priority: Swift.Int? = nil,
            sipMediaApplicationId: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.priority = priority
            self.sipMediaApplicationId = sipMediaApplicationId
        }
    }

}

extension ChimeClientTypes {
    public enum SipRuleTriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case requesturihostname
        case tophonenumber
        case sdkUnknown(Swift.String)

        public static var allCases: [SipRuleTriggerType] {
            return [
                .requesturihostname,
                .tophonenumber,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .requesturihostname: return "RequestUriHostname"
            case .tophonenumber: return "ToPhoneNumber"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SipRuleTriggerType(rawValue: rawValue) ?? SipRuleTriggerType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

public struct StartMeetingTranscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMeetingTranscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartMeetingTranscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMeetingTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartMeetingTranscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartMeetingTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMeetingTranscriptionOutputError>
}

extension StartMeetingTranscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartMeetingTranscriptionInput(meetingId: \(Swift.String(describing: meetingId)), transcriptionConfiguration: \(Swift.String(describing: transcriptionConfiguration)))"}
}

extension StartMeetingTranscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcriptionConfiguration = "TranscriptionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transcriptionConfiguration = transcriptionConfiguration {
            try encodeContainer.encode(transcriptionConfiguration, forKey: .transcriptionConfiguration)
        }
    }
}

public struct StartMeetingTranscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMeetingTranscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartMeetingTranscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMeetingTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartMeetingTranscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartMeetingTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMeetingTranscriptionOutputError>
}

public struct StartMeetingTranscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMeetingTranscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartMeetingTranscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMeetingTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "start"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartMeetingTranscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartMeetingTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMeetingTranscriptionOutputError>
}

public struct StartMeetingTranscriptionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMeetingTranscriptionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartMeetingTranscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMeetingTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartMeetingTranscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartMeetingTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMeetingTranscriptionOutputError>
}

public struct StartMeetingTranscriptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMeetingTranscriptionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartMeetingTranscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMeetingTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())/transcription"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartMeetingTranscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartMeetingTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMeetingTranscriptionOutputError>
}

public struct StartMeetingTranscriptionInput: Swift.Equatable {
    /// The unique ID of the meeting being transcribed.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The configuration for the current transcription operation. Must contain EngineTranscribeSettings or EngineTranscribeMedicalSettings.
    /// This member is required.
    public var transcriptionConfiguration: ChimeClientTypes.TranscriptionConfiguration?

    public init (
        meetingId: Swift.String? = nil,
        transcriptionConfiguration: ChimeClientTypes.TranscriptionConfiguration? = nil
    )
    {
        self.meetingId = meetingId
        self.transcriptionConfiguration = transcriptionConfiguration
    }
}

struct StartMeetingTranscriptionInputBody: Swift.Equatable {
    public let transcriptionConfiguration: ChimeClientTypes.TranscriptionConfiguration?
}

extension StartMeetingTranscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcriptionConfiguration = "TranscriptionConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptionConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscriptionConfiguration.self, forKey: .transcriptionConfiguration)
        transcriptionConfiguration = transcriptionConfigurationDecoded
    }
}

extension StartMeetingTranscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMeetingTranscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartMeetingTranscriptionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMeetingTranscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartMeetingTranscriptionOutputResponse()"}
}

extension StartMeetingTranscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartMeetingTranscriptionOutputResponse: Swift.Equatable {

    public init() {}
}

struct StartMeetingTranscriptionOutputResponseBody: Swift.Equatable {
}

extension StartMeetingTranscriptionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopMeetingTranscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopMeetingTranscriptionInput(meetingId: \(Swift.String(describing: meetingId)))"}
}

extension StopMeetingTranscriptionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct StopMeetingTranscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopMeetingTranscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopMeetingTranscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopMeetingTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopMeetingTranscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopMeetingTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopMeetingTranscriptionOutputError>
}

public struct StopMeetingTranscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopMeetingTranscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopMeetingTranscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopMeetingTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "stop"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopMeetingTranscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopMeetingTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopMeetingTranscriptionOutputError>
}

public struct StopMeetingTranscriptionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopMeetingTranscriptionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopMeetingTranscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopMeetingTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopMeetingTranscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopMeetingTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopMeetingTranscriptionOutputError>
}

public struct StopMeetingTranscriptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopMeetingTranscriptionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopMeetingTranscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopMeetingTranscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())/transcription"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopMeetingTranscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopMeetingTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopMeetingTranscriptionOutputError>
}

public struct StopMeetingTranscriptionInput: Swift.Equatable {
    /// The unique ID of the meeting for which you stop transcription.
    /// This member is required.
    public var meetingId: Swift.String?

    public init (
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

struct StopMeetingTranscriptionInputBody: Swift.Equatable {
}

extension StopMeetingTranscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopMeetingTranscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopMeetingTranscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopMeetingTranscriptionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopMeetingTranscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopMeetingTranscriptionOutputResponse()"}
}

extension StopMeetingTranscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopMeetingTranscriptionOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopMeetingTranscriptionOutputResponseBody: Swift.Equatable {
}

extension StopMeetingTranscriptionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ChimeClientTypes.StreamingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRetentionInHours = "DataRetentionInHours"
        case disabled = "Disabled"
        case streamingNotificationTargets = "StreamingNotificationTargets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRetentionInHours = dataRetentionInHours {
            try encodeContainer.encode(dataRetentionInHours, forKey: .dataRetentionInHours)
        }
        if let disabled = disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let streamingNotificationTargets = streamingNotificationTargets {
            var streamingNotificationTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .streamingNotificationTargets)
            for streamingnotificationtargetlist0 in streamingNotificationTargets {
                try streamingNotificationTargetsContainer.encode(streamingnotificationtargetlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataRetentionInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionInHours)
        dataRetentionInHours = dataRetentionInHoursDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let streamingNotificationTargetsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.StreamingNotificationTarget?].self, forKey: .streamingNotificationTargets)
        var streamingNotificationTargetsDecoded0:[ChimeClientTypes.StreamingNotificationTarget]? = nil
        if let streamingNotificationTargetsContainer = streamingNotificationTargetsContainer {
            streamingNotificationTargetsDecoded0 = [ChimeClientTypes.StreamingNotificationTarget]()
            for structure0 in streamingNotificationTargetsContainer {
                if let structure0 = structure0 {
                    streamingNotificationTargetsDecoded0?.append(structure0)
                }
            }
        }
        streamingNotificationTargets = streamingNotificationTargetsDecoded0
    }
}

extension ChimeClientTypes.StreamingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingConfiguration(dataRetentionInHours: \(Swift.String(describing: dataRetentionInHours)), disabled: \(Swift.String(describing: disabled)), streamingNotificationTargets: \(Swift.String(describing: streamingNotificationTargets)))"}
}

extension ChimeClientTypes {
    /// The streaming configuration associated with an Amazon Chime Voice Connector. Specifies whether
    ///             media streaming is enabled for sending to Amazon Kinesis, and shows the retention period
    ///             for the Amazon Kinesis data, in hours.
    public struct StreamingConfiguration: Swift.Equatable {
        /// The retention period, in hours, for the Amazon Kinesis data.
        /// This member is required.
        public var dataRetentionInHours: Swift.Int?
        /// When true, media streaming to Amazon Kinesis is turned off.
        public var disabled: Swift.Bool?
        /// The streaming notification targets.
        public var streamingNotificationTargets: [ChimeClientTypes.StreamingNotificationTarget]?

        public init (
            dataRetentionInHours: Swift.Int? = nil,
            disabled: Swift.Bool? = nil,
            streamingNotificationTargets: [ChimeClientTypes.StreamingNotificationTarget]? = nil
        )
        {
            self.dataRetentionInHours = dataRetentionInHours
            self.disabled = disabled
            self.streamingNotificationTargets = streamingNotificationTargets
        }
    }

}

extension ChimeClientTypes.StreamingNotificationTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationTarget = "NotificationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationTarget = notificationTarget {
            try encodeContainer.encode(notificationTarget.rawValue, forKey: .notificationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationTargetDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.NotificationTarget.self, forKey: .notificationTarget)
        notificationTarget = notificationTargetDecoded
    }
}

extension ChimeClientTypes.StreamingNotificationTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingNotificationTarget(notificationTarget: \(Swift.String(describing: notificationTarget)))"}
}

extension ChimeClientTypes {
    /// The targeted recipient for a streaming configuration notification.
    public struct StreamingNotificationTarget: Swift.Equatable {
        /// The streaming notification target.
        /// This member is required.
        public var notificationTarget: ChimeClientTypes.NotificationTarget?

        public init (
            notificationTarget: ChimeClientTypes.NotificationTarget? = nil
        )
        {
            self.notificationTarget = notificationTarget
        }
    }

}

extension ChimeClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ChimeClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ChimeClientTypes {
    /// Describes a tag applied to a resource.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagAttendeeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagAttendeeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagAttendeeOutputError>
}

extension TagAttendeeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagAttendeeInput(attendeeId: \(Swift.String(describing: attendeeId)), meetingId: \(Swift.String(describing: meetingId)), tags: \(Swift.String(describing: tags)))"}
}

extension TagAttendeeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for attendeetaglist0 in tags {
                try tagsContainer.encode(attendeetaglist0)
            }
        }
    }
}

public struct TagAttendeeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagAttendeeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagAttendeeOutputError>
}

public struct TagAttendeeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagAttendeeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "add"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagAttendeeOutputError>
}

public struct TagAttendeeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagAttendeeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagAttendeeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagAttendeeInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagAttendeeOutputError>
}

public struct TagAttendeeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagAttendeeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagAttendeeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        guard let attendeeId = input.attendeeId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("attendeeId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())/tags"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagAttendeeInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagAttendeeOutputError>
}

public struct TagAttendeeInput: Swift.Equatable {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [ChimeClientTypes.Tag]?

    public init (
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
        self.tags = tags
    }
}

struct TagAttendeeInputBody: Swift.Equatable {
    public let tags: [ChimeClientTypes.Tag]?
}

extension TagAttendeeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagAttendeeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagAttendeeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagAttendeeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagAttendeeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagAttendeeOutputResponse()"}
}

extension TagAttendeeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagAttendeeOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagAttendeeOutputResponseBody: Swift.Equatable {
}

extension TagAttendeeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct TagMeetingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagMeetingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagMeetingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagMeetingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagMeetingOutputError>
}

extension TagMeetingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagMeetingInput(meetingId: \(Swift.String(describing: meetingId)), tags: \(Swift.String(describing: tags)))"}
}

extension TagMeetingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for meetingtaglist0 in tags {
                try tagsContainer.encode(meetingtaglist0)
            }
        }
    }
}

public struct TagMeetingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagMeetingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagMeetingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagMeetingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagMeetingOutputError>
}

public struct TagMeetingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagMeetingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagMeetingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "add"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagMeetingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagMeetingOutputError>
}

public struct TagMeetingInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagMeetingInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagMeetingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagMeetingInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagMeetingOutputError>
}

public struct TagMeetingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagMeetingInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagMeetingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())/tags"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagMeetingInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagMeetingOutputError>
}

public struct TagMeetingInput: Swift.Equatable {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [ChimeClientTypes.Tag]?

    public init (
        meetingId: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.meetingId = meetingId
        self.tags = tags
    }
}

struct TagMeetingInputBody: Swift.Equatable {
    public let tags: [ChimeClientTypes.Tag]?
}

extension TagMeetingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagMeetingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagMeetingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagMeetingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagMeetingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagMeetingOutputResponse()"}
}

extension TagMeetingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagMeetingOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagMeetingOutputResponseBody: Swift.Equatable {
}

extension TagMeetingOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "tag-resource"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/tags"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [ChimeClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tags: [ChimeClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ChimeClientTypes.TelephonySettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inboundCalling = "InboundCalling"
        case outboundCalling = "OutboundCalling"
        case sMS = "SMS"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboundCalling = inboundCalling {
            try encodeContainer.encode(inboundCalling, forKey: .inboundCalling)
        }
        if let outboundCalling = outboundCalling {
            try encodeContainer.encode(outboundCalling, forKey: .outboundCalling)
        }
        if let sMS = sMS {
            try encodeContainer.encode(sMS, forKey: .sMS)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inboundCallingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundCalling)
        inboundCalling = inboundCallingDecoded
        let outboundCallingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundCalling)
        outboundCalling = outboundCallingDecoded
        let sMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sMS)
        sMS = sMSDecoded
    }
}

extension ChimeClientTypes.TelephonySettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TelephonySettings(inboundCalling: \(Swift.String(describing: inboundCalling)), outboundCalling: \(Swift.String(describing: outboundCalling)), sMS: \(Swift.String(describing: sMS)))"}
}

extension ChimeClientTypes {
    /// Settings that allow management of telephony permissions for an Amazon Chime user, such as
    ///             inbound and outbound calling and text messaging.
    public struct TelephonySettings: Swift.Equatable {
        /// Allows or denies inbound calling.
        /// This member is required.
        public var inboundCalling: Swift.Bool?
        /// Allows or denies outbound calling.
        /// This member is required.
        public var outboundCalling: Swift.Bool?
        /// Allows or denies SMS messaging.
        /// This member is required.
        public var sMS: Swift.Bool?

        public init (
            inboundCalling: Swift.Bool? = nil,
            outboundCalling: Swift.Bool? = nil,
            sMS: Swift.Bool? = nil
        )
        {
            self.inboundCalling = inboundCalling
            self.outboundCalling = outboundCalling
            self.sMS = sMS
        }
    }

}

extension ChimeClientTypes.Termination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingRegions = "CallingRegions"
        case cidrAllowedList = "CidrAllowedList"
        case cpsLimit = "CpsLimit"
        case defaultPhoneNumber = "DefaultPhoneNumber"
        case disabled = "Disabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingRegions = callingRegions {
            var callingRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .callingRegions)
            for callingregionlist0 in callingRegions {
                try callingRegionsContainer.encode(callingregionlist0)
            }
        }
        if let cidrAllowedList = cidrAllowedList {
            var cidrAllowedListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrAllowedList)
            for stringlist0 in cidrAllowedList {
                try cidrAllowedListContainer.encode(stringlist0)
            }
        }
        if let cpsLimit = cpsLimit {
            try encodeContainer.encode(cpsLimit, forKey: .cpsLimit)
        }
        if let defaultPhoneNumber = defaultPhoneNumber {
            try encodeContainer.encode(defaultPhoneNumber, forKey: .defaultPhoneNumber)
        }
        if let disabled = disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpsLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cpsLimit)
        cpsLimit = cpsLimitDecoded
        let defaultPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultPhoneNumber)
        defaultPhoneNumber = defaultPhoneNumberDecoded
        let callingRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .callingRegions)
        var callingRegionsDecoded0:[Swift.String]? = nil
        if let callingRegionsContainer = callingRegionsContainer {
            callingRegionsDecoded0 = [Swift.String]()
            for string0 in callingRegionsContainer {
                if let string0 = string0 {
                    callingRegionsDecoded0?.append(string0)
                }
            }
        }
        callingRegions = callingRegionsDecoded0
        let cidrAllowedListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cidrAllowedList)
        var cidrAllowedListDecoded0:[Swift.String]? = nil
        if let cidrAllowedListContainer = cidrAllowedListContainer {
            cidrAllowedListDecoded0 = [Swift.String]()
            for string0 in cidrAllowedListContainer {
                if let string0 = string0 {
                    cidrAllowedListDecoded0?.append(string0)
                }
            }
        }
        cidrAllowedList = cidrAllowedListDecoded0
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension ChimeClientTypes.Termination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Termination(callingRegions: \(Swift.String(describing: callingRegions)), cidrAllowedList: \(Swift.String(describing: cidrAllowedList)), cpsLimit: \(Swift.String(describing: cpsLimit)), defaultPhoneNumber: \(Swift.String(describing: defaultPhoneNumber)), disabled: \(Swift.String(describing: disabled)))"}
}

extension ChimeClientTypes {
    /// Termination settings enable your SIP hosts to make outbound calls using your Amazon Chime
    ///             Voice Connector.
    public struct Termination: Swift.Equatable {
        /// The countries to which calls are allowed, in ISO 3166-1 alpha-2 format. Required.
        public var callingRegions: [Swift.String]?
        /// The IP addresses allowed to make calls, in CIDR format. Required.
        public var cidrAllowedList: [Swift.String]?
        /// The limit on calls per second. Max value based on account service quota. Default value of
        ///             1.
        public var cpsLimit: Swift.Int?
        /// The default caller ID phone number.
        public var defaultPhoneNumber: Swift.String?
        /// When termination settings are disabled, outbound calls can not be made.
        public var disabled: Swift.Bool?

        public init (
            callingRegions: [Swift.String]? = nil,
            cidrAllowedList: [Swift.String]? = nil,
            cpsLimit: Swift.Int? = nil,
            defaultPhoneNumber: Swift.String? = nil,
            disabled: Swift.Bool? = nil
        )
        {
            self.callingRegions = callingRegions
            self.cidrAllowedList = cidrAllowedList
            self.cpsLimit = cpsLimit
            self.defaultPhoneNumber = defaultPhoneNumber
            self.disabled = disabled
        }
    }

}

extension ChimeClientTypes.TerminationHealth: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source = "Source"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension ChimeClientTypes.TerminationHealth: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TerminationHealth(source: \(Swift.String(describing: source)), timestamp: \(Swift.String(describing: timestamp)))"}
}

extension ChimeClientTypes {
    /// The termination health details, including the source IP address and timestamp of the last
    ///             successful SIP OPTIONS message from your SIP infrastructure.
    public struct TerminationHealth: Swift.Equatable {
        /// The source IP address.
        public var source: Swift.String?
        /// The timestamp, in ISO 8601 format.
        public var timestamp: ClientRuntime.Date?

        public init (
            source: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.source = source
            self.timestamp = timestamp
        }
    }

}

extension ThrottledClientException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottledClientException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ThrottledClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottledClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client exceeded its request rate limit.
public struct ThrottledClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ThrottledClientExceptionBody: Swift.Equatable {
    public let code: ChimeClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension ThrottledClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeClientTypes {
    public enum TranscribeLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deDe
        case enAu
        case enGb
        case enUs
        case esUs
        case frCa
        case frFr
        case itIt
        case jaJp
        case koKr
        case ptBr
        case zhCn
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeLanguageCode] {
            return [
                .deDe,
                .enAu,
                .enGb,
                .enUs,
                .esUs,
                .frCa,
                .frFr,
                .itIt,
                .jaJp,
                .koKr,
                .ptBr,
                .zhCn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .esUs: return "es-US"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .itIt: return "it-IT"
            case .jaJp: return "ja-JP"
            case .koKr: return "ko-KR"
            case .ptBr: return "pt-BR"
            case .zhCn: return "zh-CN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeLanguageCode(rawValue: rawValue) ?? TranscribeLanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribeMedicalLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalLanguageCode] {
            return [
                .enUs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "en-US"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalLanguageCode(rawValue: rawValue) ?? TranscribeMedicalLanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribeMedicalRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apSoutheast2
        case auto
        case caCentral1
        case euWest1
        case usEast1
        case usEast2
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalRegion] {
            return [
                .apSoutheast2,
                .auto,
                .caCentral1,
                .euWest1,
                .usEast1,
                .usEast2,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apSoutheast2: return "ap-southeast-2"
            case .auto: return "auto"
            case .caCentral1: return "ca-central-1"
            case .euWest1: return "eu-west-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalRegion(rawValue: rawValue) ?? TranscribeMedicalRegion.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribeMedicalSpecialty: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cardiology
        case neurology
        case oncology
        case primarycare
        case radiology
        case urology
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalSpecialty] {
            return [
                .cardiology,
                .neurology,
                .oncology,
                .primarycare,
                .radiology,
                .urology,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cardiology: return "CARDIOLOGY"
            case .neurology: return "NEUROLOGY"
            case .oncology: return "ONCOLOGY"
            case .primarycare: return "PRIMARYCARE"
            case .radiology: return "RADIOLOGY"
            case .urology: return "UROLOGY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalSpecialty(rawValue: rawValue) ?? TranscribeMedicalSpecialty.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribeMedicalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conversation
        case dictation
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalType] {
            return [
                .conversation,
                .dictation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conversation: return "CONVERSATION"
            case .dictation: return "DICTATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalType(rawValue: rawValue) ?? TranscribeMedicalType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribeRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apNortheast1
        case apNortheast2
        case apSoutheast2
        case auto
        case caCentral1
        case euCentral1
        case euWest1
        case euWest2
        case saEast1
        case usEast1
        case usEast2
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeRegion] {
            return [
                .apNortheast1,
                .apNortheast2,
                .apSoutheast2,
                .auto,
                .caCentral1,
                .euCentral1,
                .euWest1,
                .euWest2,
                .saEast1,
                .usEast1,
                .usEast2,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apNortheast1: return "ap-northeast-1"
            case .apNortheast2: return "ap-northeast-2"
            case .apSoutheast2: return "ap-southeast-2"
            case .auto: return "auto"
            case .caCentral1: return "ca-central-1"
            case .euCentral1: return "eu-central-1"
            case .euWest1: return "eu-west-1"
            case .euWest2: return "eu-west-2"
            case .saEast1: return "sa-east-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeRegion(rawValue: rawValue) ?? TranscribeRegion.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribeVocabularyFilterMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mask
        case remove
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeVocabularyFilterMethod] {
            return [
                .mask,
                .remove,
                .tag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mask: return "mask"
            case .remove: return "remove"
            case .tag: return "tag"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeVocabularyFilterMethod(rawValue: rawValue) ?? TranscribeVocabularyFilterMethod.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.TranscriptionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineTranscribeMedicalSettings = "EngineTranscribeMedicalSettings"
        case engineTranscribeSettings = "EngineTranscribeSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineTranscribeMedicalSettings = engineTranscribeMedicalSettings {
            try encodeContainer.encode(engineTranscribeMedicalSettings, forKey: .engineTranscribeMedicalSettings)
        }
        if let engineTranscribeSettings = engineTranscribeSettings {
            try encodeContainer.encode(engineTranscribeSettings, forKey: .engineTranscribeSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineTranscribeSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EngineTranscribeSettings.self, forKey: .engineTranscribeSettings)
        engineTranscribeSettings = engineTranscribeSettingsDecoded
        let engineTranscribeMedicalSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EngineTranscribeMedicalSettings.self, forKey: .engineTranscribeMedicalSettings)
        engineTranscribeMedicalSettings = engineTranscribeMedicalSettingsDecoded
    }
}

extension ChimeClientTypes.TranscriptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TranscriptionConfiguration(engineTranscribeMedicalSettings: \(Swift.String(describing: engineTranscribeMedicalSettings)), engineTranscribeSettings: \(Swift.String(describing: engineTranscribeSettings)))"}
}

extension ChimeClientTypes {
    /// The configuration for the current transcription operation. Must contain EngineTranscribeSettings or EngineTranscribeMedicalSettings.
    public struct TranscriptionConfiguration: Swift.Equatable {
        /// The transcription configuration settings passed to Amazon Transcribe Medical.
        public var engineTranscribeMedicalSettings: ChimeClientTypes.EngineTranscribeMedicalSettings?
        /// The transcription configuration settings passed to Amazon Transcribe.
        public var engineTranscribeSettings: ChimeClientTypes.EngineTranscribeSettings?

        public init (
            engineTranscribeMedicalSettings: ChimeClientTypes.EngineTranscribeMedicalSettings? = nil,
            engineTranscribeSettings: ChimeClientTypes.EngineTranscribeSettings? = nil
        )
        {
            self.engineTranscribeMedicalSettings = engineTranscribeMedicalSettings
            self.engineTranscribeSettings = engineTranscribeSettings
        }
    }

}

extension UnauthorizedClientException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnauthorizedClientException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension UnauthorizedClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is not currently authorized to make the request.
public struct UnauthorizedClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    public let code: ChimeClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnprocessableEntityException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnprocessableEntityException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension UnprocessableEntityException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnprocessableEntityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was well-formed but was unable to be followed due to semantic errors.
public struct UnprocessableEntityException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UnprocessableEntityExceptionBody: Swift.Equatable {
    public let code: ChimeClientTypes.ErrorCode?
    public let message: Swift.String?
}

extension UnprocessableEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagAttendeeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagAttendeeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagAttendeeOutputError>
}

extension UntagAttendeeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagAttendeeInput(attendeeId: \(Swift.String(describing: attendeeId)), meetingId: \(Swift.String(describing: meetingId)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagAttendeeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for attendeetagkeylist0 in tagKeys {
                try tagKeysContainer.encode(attendeetagkeylist0)
            }
        }
    }
}

public struct UntagAttendeeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagAttendeeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagAttendeeOutputError>
}

public struct UntagAttendeeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagAttendeeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagAttendeeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "delete"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagAttendeeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagAttendeeOutputError>
}

public struct UntagAttendeeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagAttendeeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagAttendeeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagAttendeeInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagAttendeeOutputError>
}

public struct UntagAttendeeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagAttendeeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagAttendeeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagAttendeeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        guard let attendeeId = input.attendeeId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("attendeeId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())/tags"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagAttendeeInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagAttendeeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagAttendeeOutputError>
}

public struct UntagAttendeeInput: Swift.Equatable {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
        self.tagKeys = tagKeys
    }
}

struct UntagAttendeeInputBody: Swift.Equatable {
    public let tagKeys: [Swift.String]?
}

extension UntagAttendeeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagAttendeeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagAttendeeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagAttendeeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagAttendeeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagAttendeeOutputResponse()"}
}

extension UntagAttendeeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagAttendeeOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagAttendeeOutputResponseBody: Swift.Equatable {
}

extension UntagAttendeeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UntagMeetingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagMeetingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagMeetingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagMeetingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagMeetingOutputError>
}

extension UntagMeetingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagMeetingInput(meetingId: \(Swift.String(describing: meetingId)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagMeetingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for meetingtagkeylist0 in tagKeys {
                try tagKeysContainer.encode(meetingtagkeylist0)
            }
        }
    }
}

public struct UntagMeetingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagMeetingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagMeetingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagMeetingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagMeetingOutputError>
}

public struct UntagMeetingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagMeetingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagMeetingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "delete"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagMeetingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagMeetingOutputError>
}

public struct UntagMeetingInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagMeetingInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagMeetingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagMeetingInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagMeetingOutputError>
}

public struct UntagMeetingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagMeetingInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagMeetingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagMeetingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let meetingId = input.meetingId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("meetingId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/meetings/\(meetingId.urlPercentEncoding())/tags"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagMeetingInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagMeetingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagMeetingOutputError>
}

public struct UntagMeetingInput: Swift.Equatable {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        meetingId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.meetingId = meetingId
        self.tagKeys = tagKeys
    }
}

struct UntagMeetingInputBody: Swift.Equatable {
    public let tagKeys: [Swift.String]?
}

extension UntagMeetingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagMeetingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagMeetingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagMeetingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagMeetingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagMeetingOutputResponse()"}
}

extension UntagMeetingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagMeetingOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagMeetingOutputResponseBody: Swift.Equatable {
}

extension UntagMeetingOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "operation", value: "untag-resource"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/tags"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateAccountInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccountOutputError>
}

extension UpdateAccountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAccountInput(accountId: \(Swift.String(describing: accountId)), defaultLicense: \(Swift.String(describing: defaultLicense)), name: \(Swift.String(describing: name)))"}
}

extension UpdateAccountInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLicense = "DefaultLicense"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultLicense = defaultLicense {
            try encodeContainer.encode(defaultLicense.rawValue, forKey: .defaultLicense)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAccountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccountOutputError>
}

public struct UpdateAccountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccountOutputError>
}

public struct UpdateAccountInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccountInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccountOutputError>
}

public struct UpdateAccountInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccountInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccountOutputError>
}

public struct UpdateAccountInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The default license applied when you add users to an Amazon Chime account.
    public var defaultLicense: ChimeClientTypes.License?
    /// The new name for the specified Amazon Chime account.
    public var name: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        defaultLicense: ChimeClientTypes.License? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.defaultLicense = defaultLicense
        self.name = name
    }
}

struct UpdateAccountInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let defaultLicense: ChimeClientTypes.License?
}

extension UpdateAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLicense = "DefaultLicense"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultLicenseDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.License.self, forKey: .defaultLicense)
        defaultLicense = defaultLicenseDecoded
    }
}

extension UpdateAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAccountOutputResponse(account: \(Swift.String(describing: account)))"}
}

extension UpdateAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.account = output.account
        } else {
            self.account = nil
        }
    }
}

public struct UpdateAccountOutputResponse: Swift.Equatable {
    /// The updated Amazon Chime account details.
    public var account: ChimeClientTypes.Account?

    public init (
        account: ChimeClientTypes.Account? = nil
    )
    {
        self.account = account
    }
}

struct UpdateAccountOutputResponseBody: Swift.Equatable {
    public let account: ChimeClientTypes.Account?
}

extension UpdateAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Account.self, forKey: .account)
        account = accountDecoded
    }
}

public struct UpdateAccountSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccountSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAccountSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAccountSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccountSettingsOutputError>
}

extension UpdateAccountSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAccountSettingsInput(accountId: \(Swift.String(describing: accountId)), accountSettings: \(Swift.String(describing: accountSettings)))"}
}

extension UpdateAccountSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings = "AccountSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountSettings = accountSettings {
            try encodeContainer.encode(accountSettings, forKey: .accountSettings)
        }
    }
}

public struct UpdateAccountSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccountSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAccountSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAccountSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccountSettingsOutputError>
}

public struct UpdateAccountSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccountSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAccountSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAccountSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccountSettingsOutputError>
}

public struct UpdateAccountSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccountSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateAccountSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAccountSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccountSettingsOutputError>
}

public struct UpdateAccountSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccountSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateAccountSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAccountSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccountSettingsOutputError>
}

public struct UpdateAccountSettingsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Chime account settings to update.
    /// This member is required.
    public var accountSettings: ChimeClientTypes.AccountSettings?

    public init (
        accountId: Swift.String? = nil,
        accountSettings: ChimeClientTypes.AccountSettings? = nil
    )
    {
        self.accountId = accountId
        self.accountSettings = accountSettings
    }
}

struct UpdateAccountSettingsInputBody: Swift.Equatable {
    public let accountSettings: ChimeClientTypes.AccountSettings?
}

extension UpdateAccountSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings = "AccountSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
    }
}

extension UpdateAccountSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccountSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccountSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAccountSettingsOutputResponse()"}
}

extension UpdateAccountSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAccountSettingsOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateAccountSettingsOutputResponseBody: Swift.Equatable {
}

extension UpdateAccountSettingsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateAppInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceOutputError>
}

extension UpdateAppInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)))"}
}

extension UpdateAppInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAppInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceOutputError>
}

public struct UpdateAppInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceOutputError>
}

public struct UpdateAppInstanceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceOutputError>
}

public struct UpdateAppInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateAppInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceArn = input.appInstanceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instances/\(appInstanceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAppInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceOutputError>
}

public struct UpdateAppInstanceInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The metadata that you want to change.
    public var metadata: Swift.String?
    /// The name that you want to change.
    /// This member is required.
    public var name: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.metadata = metadata
        self.name = name
    }
}

struct UpdateAppInstanceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let metadata: Swift.String?
}

extension UpdateAppInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateAppInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAppInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAppInstanceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAppInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceOutputResponse(appInstanceArn: \(Swift.String(describing: appInstanceArn)))"}
}

extension UpdateAppInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAppInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
        } else {
            self.appInstanceArn = nil
        }
    }
}

public struct UpdateAppInstanceOutputResponse: Swift.Equatable {
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct UpdateAppInstanceOutputResponseBody: Swift.Equatable {
    public let appInstanceArn: Swift.String?
}

extension UpdateAppInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
    }
}

public struct UpdateAppInstanceUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceUserOutputError>
}

extension UpdateAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)))"}
}

extension UpdateAppInstanceUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAppInstanceUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceUserOutputError>
}

public struct UpdateAppInstanceUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAppInstanceUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAppInstanceUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceUserOutputError>
}

public struct UpdateAppInstanceUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "identity-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceUserOutputError>
}

public struct UpdateAppInstanceUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAppInstanceUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateAppInstanceUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let appInstanceUserArn = input.appInstanceUserArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("appInstanceUserArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAppInstanceUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAppInstanceUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAppInstanceUserOutputError>
}

public struct UpdateAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The metadata of the AppInstanceUser.
    public var metadata: Swift.String?
    /// The name of the AppInstanceUser.
    /// This member is required.
    public var name: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.metadata = metadata
        self.name = name
    }
}

struct UpdateAppInstanceUserInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let metadata: Swift.String?
}

extension UpdateAppInstanceUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceUserOutputResponse(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)))"}
}

extension UpdateAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
        } else {
            self.appInstanceUserArn = nil
        }
    }
}

public struct UpdateAppInstanceUserOutputResponse: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    public var appInstanceUserArn: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct UpdateAppInstanceUserOutputResponseBody: Swift.Equatable {
    public let appInstanceUserArn: Swift.String?
}

extension UpdateAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
    }
}

public struct UpdateBotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBotOutputError>
}

extension UpdateBotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBotInput(accountId: \(Swift.String(describing: accountId)), botId: \(Swift.String(describing: botId)), disabled: \(Swift.String(describing: disabled)))"}
}

extension UpdateBotInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
    }
}

public struct UpdateBotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBotOutputError>
}

public struct UpdateBotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBotOutputError>
}

public struct UpdateBotInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBotInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateBotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBotInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBotOutputError>
}

public struct UpdateBotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBotInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateBotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let botId = input.botId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("botId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBotInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBotOutputError>
}

public struct UpdateBotInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?
    /// When true, stops the specified bot from running in your account.
    public var disabled: Swift.Bool?

    public init (
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil,
        disabled: Swift.Bool? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
        self.disabled = disabled
    }
}

struct UpdateBotInputBody: Swift.Equatable {
    public let disabled: Swift.Bool?
}

extension UpdateBotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension UpdateBotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBotOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBotOutputResponse(bot: \(Swift.String(describing: bot)))"}
}

extension UpdateBotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bot = output.bot
        } else {
            self.bot = nil
        }
    }
}

public struct UpdateBotOutputResponse: Swift.Equatable {
    /// The updated bot details.
    public var bot: ChimeClientTypes.Bot?

    public init (
        bot: ChimeClientTypes.Bot? = nil
    )
    {
        self.bot = bot
    }
}

struct UpdateBotOutputResponseBody: Swift.Equatable {
    public let bot: ChimeClientTypes.Bot?
}

extension UpdateBotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bot = "Bot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Bot.self, forKey: .bot)
        bot = botDecoded
    }
}

public struct UpdateChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

extension UpdateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), metadata: \(Swift.String(describing: metadata)), mode: \(Swift.String(describing: mode)), name: \(Swift.String(describing: name)))"}
}

extension UpdateChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The metadata for the update request.
    public var metadata: Swift.String?
    /// The mode of the update request.
    /// This member is required.
    public var mode: ChimeClientTypes.ChannelMode?
    /// The name of the channel.
    /// This member is required.
    public var name: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        metadata: Swift.String? = nil,
        mode: ChimeClientTypes.ChannelMode? = nil,
        name: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.metadata = metadata
        self.mode = mode
        self.name = name
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let mode: ChimeClientTypes.ChannelMode?
    public let metadata: Swift.String?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

public struct UpdateChannelMessageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelMessageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelMessageOutputError>
}

extension UpdateChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), content: \(Swift.String(describing: content)), messageId: \(Swift.String(describing: messageId)), metadata: \(Swift.String(describing: metadata)))"}
}

extension UpdateChannelMessageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case metadata = "Metadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
    }
}

public struct UpdateChannelMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelMessageOutputError>
}

public struct UpdateChannelMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelMessageOutputError>
}

public struct UpdateChannelMessageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelMessageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelMessageOutputError>
}

public struct UpdateChannelMessageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelMessageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateChannelMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        guard let messageId = input.messageId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("messageId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelMessageOutputError>
}

public struct UpdateChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The content of the message being updated.
    public var content: Swift.String?
    /// The ID string of the message being updated.
    /// This member is required.
    public var messageId: Swift.String?
    /// The metadata of the message being updated.
    public var metadata: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        content: Swift.String? = nil,
        messageId: Swift.String? = nil,
        metadata: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.content = content
        self.messageId = messageId
        self.metadata = metadata
    }
}

struct UpdateChannelMessageInputBody: Swift.Equatable {
    public let content: Swift.String?
    public let metadata: Swift.String?
}

extension UpdateChannelMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case metadata = "Metadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelMessageOutputResponse(channelArn: \(Swift.String(describing: channelArn)), messageId: \(Swift.String(describing: messageId)))"}
}

extension UpdateChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.messageId = output.messageId
        } else {
            self.channelArn = nil
            self.messageId = nil
        }
    }
}

public struct UpdateChannelMessageOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ID string of the message being updated.
    public var messageId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
    }
}

struct UpdateChannelMessageOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let messageId: Swift.String?
}

extension UpdateChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case messageId = "MessageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension UpdateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelOutputResponse(channelArn: \(Swift.String(describing: channelArn)))"}
}

extension UpdateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
        } else {
            self.channelArn = nil
        }
    }
}

public struct UpdateChannelOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct UpdateChannelOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
}

extension UpdateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension UpdateChannelReadMarkerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelReadMarkerInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)))"}
}

extension UpdateChannelReadMarkerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UpdateChannelReadMarkerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelReadMarkerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelReadMarkerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let chimeBearer = input.operationInput.chimeBearer {
            input.builder.withHeader(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelReadMarkerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelReadMarkerOutputError>
}

public struct UpdateChannelReadMarkerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelReadMarkerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelReadMarkerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelReadMarkerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelReadMarkerOutputError>
}

public struct UpdateChannelReadMarkerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelReadMarkerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateChannelReadMarkerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        copiedContext.attributes.set(key: AttributeKey<String>(name: "HostPrefix"), value: "messaging-")
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelReadMarkerInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelReadMarkerOutputError>
}

public struct UpdateChannelReadMarkerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelReadMarkerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateChannelReadMarkerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let channelArn = input.channelArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("channelArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/channels/\(channelArn.urlPercentEncoding())/readMarker"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelReadMarkerInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelReadMarkerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelReadMarkerOutputError>
}

public struct UpdateChannelReadMarkerInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct UpdateChannelReadMarkerInputBody: Swift.Equatable {
}

extension UpdateChannelReadMarkerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UpdateChannelReadMarkerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelReadMarkerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelReadMarkerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelReadMarkerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelReadMarkerOutputResponse(channelArn: \(Swift.String(describing: channelArn)))"}
}

extension UpdateChannelReadMarkerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateChannelReadMarkerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
        } else {
            self.channelArn = nil
        }
    }
}

public struct UpdateChannelReadMarkerOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct UpdateChannelReadMarkerOutputResponseBody: Swift.Equatable {
    public let channelArn: Swift.String?
}

extension UpdateChannelReadMarkerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

public struct UpdateGlobalSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGlobalSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGlobalSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalSettingsOutputError>
}

extension UpdateGlobalSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlobalSettingsInput(businessCalling: \(Swift.String(describing: businessCalling)), voiceConnector: \(Swift.String(describing: voiceConnector)))"}
}

extension UpdateGlobalSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessCalling = "BusinessCalling"
        case voiceConnector = "VoiceConnector"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let businessCalling = businessCalling {
            try encodeContainer.encode(businessCalling, forKey: .businessCalling)
        }
        if let voiceConnector = voiceConnector {
            try encodeContainer.encode(voiceConnector, forKey: .voiceConnector)
        }
    }
}

public struct UpdateGlobalSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGlobalSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGlobalSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalSettingsOutputError>
}

public struct UpdateGlobalSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGlobalSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGlobalSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalSettingsOutputError>
}

public struct UpdateGlobalSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateGlobalSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateGlobalSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalSettingsOutputError>
}

public struct UpdateGlobalSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateGlobalSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateGlobalSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalSettingsOutputError>
}

public struct UpdateGlobalSettingsInput: Swift.Equatable {
    /// The Amazon Chime Business Calling settings.
    /// This member is required.
    public var businessCalling: ChimeClientTypes.BusinessCallingSettings?
    /// The Amazon Chime Voice Connector settings.
    /// This member is required.
    public var voiceConnector: ChimeClientTypes.VoiceConnectorSettings?

    public init (
        businessCalling: ChimeClientTypes.BusinessCallingSettings? = nil,
        voiceConnector: ChimeClientTypes.VoiceConnectorSettings? = nil
    )
    {
        self.businessCalling = businessCalling
        self.voiceConnector = voiceConnector
    }
}

struct UpdateGlobalSettingsInputBody: Swift.Equatable {
    public let businessCalling: ChimeClientTypes.BusinessCallingSettings?
    public let voiceConnector: ChimeClientTypes.VoiceConnectorSettings?
}

extension UpdateGlobalSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessCalling = "BusinessCalling"
        case voiceConnector = "VoiceConnector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let businessCallingDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.BusinessCallingSettings.self, forKey: .businessCalling)
        businessCalling = businessCallingDecoded
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnectorSettings.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension UpdateGlobalSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGlobalSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGlobalSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGlobalSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlobalSettingsOutputResponse()"}
}

extension UpdateGlobalSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGlobalSettingsOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateGlobalSettingsOutputResponseBody: Swift.Equatable {
}

extension UpdateGlobalSettingsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdatePhoneNumberInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePhoneNumberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePhoneNumberOutputError>
}

extension UpdatePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberInput(callingName: \(Swift.String(describing: callingName)), phoneNumberId: \(Swift.String(describing: phoneNumberId)), productType: \(Swift.String(describing: productType)))"}
}

extension UpdatePhoneNumberInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case productType = "ProductType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingName = callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
        if let productType = productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
    }
}

public struct UpdatePhoneNumberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePhoneNumberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePhoneNumberOutputError>
}

public struct UpdatePhoneNumberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePhoneNumberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePhoneNumberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePhoneNumberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePhoneNumberOutputError>
}

public struct UpdatePhoneNumberInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePhoneNumberInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdatePhoneNumberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePhoneNumberInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePhoneNumberOutputError>
}

public struct UpdatePhoneNumberInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePhoneNumberInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdatePhoneNumberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePhoneNumberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let phoneNumberId = input.phoneNumberId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("phoneNumberId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePhoneNumberInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePhoneNumberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePhoneNumberOutputError>
}

public struct UpdatePhoneNumberInput: Swift.Equatable {
    /// The outbound calling name associated with the phone number.
    public var callingName: Swift.String?
    /// The phone number ID.
    /// This member is required.
    public var phoneNumberId: Swift.String?
    /// The product type.
    public var productType: ChimeClientTypes.PhoneNumberProductType?

    public init (
        callingName: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        productType: ChimeClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.callingName = callingName
        self.phoneNumberId = phoneNumberId
        self.productType = productType
    }
}

struct UpdatePhoneNumberInputBody: Swift.Equatable {
    public let productType: ChimeClientTypes.PhoneNumberProductType?
    public let callingName: Swift.String?
}

extension UpdatePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case productType = "ProductType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
    }
}

extension UpdatePhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePhoneNumberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberOutputResponse(phoneNumber: \(Swift.String(describing: phoneNumber)))"}
}

extension UpdatePhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePhoneNumberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumber = output.phoneNumber
        } else {
            self.phoneNumber = nil
        }
    }
}

public struct UpdatePhoneNumberOutputResponse: Swift.Equatable {
    /// The updated phone number details.
    public var phoneNumber: ChimeClientTypes.PhoneNumber?

    public init (
        phoneNumber: ChimeClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct UpdatePhoneNumberOutputResponseBody: Swift.Equatable {
    public let phoneNumber: ChimeClientTypes.PhoneNumber?
}

extension UpdatePhoneNumberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumber.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension ChimeClientTypes.UpdatePhoneNumberRequestItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case phoneNumberId = "PhoneNumberId"
        case productType = "ProductType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingName = callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
        if let phoneNumberId = phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let productType = productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
    }
}

extension ChimeClientTypes.UpdatePhoneNumberRequestItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberRequestItem(callingName: \(Swift.String(describing: callingName)), phoneNumberId: \(Swift.String(describing: phoneNumberId)), productType: \(Swift.String(describing: productType)))"}
}

extension ChimeClientTypes {
    /// The phone number ID, product type, or calling name fields to update, used with the
    /// BatchUpdatePhoneNumber and UpdatePhoneNumber actions.
    public struct UpdatePhoneNumberRequestItem: Swift.Equatable {
        /// The outbound calling name to update.
        public var callingName: Swift.String?
        /// The phone number ID to update.
        /// This member is required.
        public var phoneNumberId: Swift.String?
        /// The product type to update.
        public var productType: ChimeClientTypes.PhoneNumberProductType?

        public init (
            callingName: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            productType: ChimeClientTypes.PhoneNumberProductType? = nil
        )
        {
            self.callingName = callingName
            self.phoneNumberId = phoneNumberId
            self.productType = productType
        }
    }

}

public struct UpdatePhoneNumberSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePhoneNumberSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePhoneNumberSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePhoneNumberSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePhoneNumberSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePhoneNumberSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePhoneNumberSettingsOutputError>
}

extension UpdatePhoneNumberSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberSettingsInput(callingName: \(Swift.String(describing: callingName)))"}
}

extension UpdatePhoneNumberSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingName = callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
    }
}

public struct UpdatePhoneNumberSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePhoneNumberSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePhoneNumberSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePhoneNumberSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePhoneNumberSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePhoneNumberSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePhoneNumberSettingsOutputError>
}

public struct UpdatePhoneNumberSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePhoneNumberSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePhoneNumberSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePhoneNumberSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePhoneNumberSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePhoneNumberSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePhoneNumberSettingsOutputError>
}

public struct UpdatePhoneNumberSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePhoneNumberSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdatePhoneNumberSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePhoneNumberSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePhoneNumberSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePhoneNumberSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePhoneNumberSettingsOutputError>
}

public struct UpdatePhoneNumberSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePhoneNumberSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdatePhoneNumberSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePhoneNumberSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/settings/phone-number"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePhoneNumberSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePhoneNumberSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePhoneNumberSettingsOutputError>
}

public struct UpdatePhoneNumberSettingsInput: Swift.Equatable {
    /// The default outbound calling name for the account.
    /// This member is required.
    public var callingName: Swift.String?

    public init (
        callingName: Swift.String? = nil
    )
    {
        self.callingName = callingName
    }
}

struct UpdatePhoneNumberSettingsInputBody: Swift.Equatable {
    public let callingName: Swift.String?
}

extension UpdatePhoneNumberSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
    }
}

extension UpdatePhoneNumberSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePhoneNumberSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePhoneNumberSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePhoneNumberSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberSettingsOutputResponse()"}
}

extension UpdatePhoneNumberSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePhoneNumberSettingsOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdatePhoneNumberSettingsOutputResponseBody: Swift.Equatable {
}

extension UpdatePhoneNumberSettingsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateProxySessionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProxySessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProxySessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProxySessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProxySessionOutputError>
}

extension UpdateProxySessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProxySessionInput(capabilities: \(Swift.String(describing: capabilities)), expiryMinutes: \(Swift.String(describing: expiryMinutes)), proxySessionId: \(Swift.String(describing: proxySessionId)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension UpdateProxySessionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capabilitylist0 in capabilities {
                try capabilitiesContainer.encode(capabilitylist0.rawValue)
            }
        }
        if let expiryMinutes = expiryMinutes {
            try encodeContainer.encode(expiryMinutes, forKey: .expiryMinutes)
        }
    }
}

public struct UpdateProxySessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProxySessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProxySessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProxySessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProxySessionOutputError>
}

public struct UpdateProxySessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProxySessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProxySessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProxySessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProxySessionOutputError>
}

public struct UpdateProxySessionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProxySessionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateProxySessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateProxySessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProxySessionOutputError>
}

public struct UpdateProxySessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProxySessionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateProxySessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProxySessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        guard let proxySessionId = input.proxySessionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("proxySessionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateProxySessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProxySessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProxySessionOutputError>
}

public struct UpdateProxySessionInput: Swift.Equatable {
    /// The proxy session capabilities.
    /// This member is required.
    public var capabilities: [ChimeClientTypes.Capability]?
    /// The number of minutes allowed for the proxy session.
    public var expiryMinutes: Swift.Int?
    /// The proxy session ID.
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        capabilities: [ChimeClientTypes.Capability]? = nil,
        expiryMinutes: Swift.Int? = nil,
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.expiryMinutes = expiryMinutes
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct UpdateProxySessionInputBody: Swift.Equatable {
    public let capabilities: [ChimeClientTypes.Capability]?
    public let expiryMinutes: Swift.Int?
}

extension UpdateProxySessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilitiesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Capability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[ChimeClientTypes.Capability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [ChimeClientTypes.Capability]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let expiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiryMinutes)
        expiryMinutes = expiryMinutesDecoded
    }
}

extension UpdateProxySessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProxySessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProxySessionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProxySessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProxySessionOutputResponse(proxySession: \(Swift.String(describing: proxySession)))"}
}

extension UpdateProxySessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateProxySessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proxySession = output.proxySession
        } else {
            self.proxySession = nil
        }
    }
}

public struct UpdateProxySessionOutputResponse: Swift.Equatable {
    /// The proxy session details.
    public var proxySession: ChimeClientTypes.ProxySession?

    public init (
        proxySession: ChimeClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

struct UpdateProxySessionOutputResponseBody: Swift.Equatable {
    public let proxySession: ChimeClientTypes.ProxySession?
}

extension UpdateProxySessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxySession = "ProxySession"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ProxySession.self, forKey: .proxySession)
        proxySession = proxySessionDecoded
    }
}

public struct UpdateRoomInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRoomInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRoomInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRoomInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRoomOutputError>
}

extension UpdateRoomInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRoomInput(accountId: \(Swift.String(describing: accountId)), name: \(Swift.String(describing: name)), roomId: \(Swift.String(describing: roomId)))"}
}

extension UpdateRoomInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateRoomInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRoomInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRoomInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRoomInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRoomOutputError>
}

public struct UpdateRoomInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRoomInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRoomInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRoomInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRoomOutputError>
}

public struct UpdateRoomInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRoomInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateRoomInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRoomInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRoomOutputError>
}

public struct UpdateRoomInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRoomInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateRoomInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRoomOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let roomId = input.roomId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("roomId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRoomInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRoomOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRoomOutputError>
}

public struct UpdateRoomInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The room name.
    public var name: Swift.String?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        name: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
        self.roomId = roomId
    }
}

struct UpdateRoomInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension UpdateRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct UpdateRoomMembershipInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRoomMembershipInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRoomMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRoomMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRoomMembershipOutputError>
}

extension UpdateRoomMembershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRoomMembershipInput(accountId: \(Swift.String(describing: accountId)), memberId: \(Swift.String(describing: memberId)), role: \(Swift.String(describing: role)), roomId: \(Swift.String(describing: roomId)))"}
}

extension UpdateRoomMembershipInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
    }
}

public struct UpdateRoomMembershipInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRoomMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRoomMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRoomMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRoomMembershipOutputError>
}

public struct UpdateRoomMembershipInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRoomMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRoomMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRoomMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRoomMembershipOutputError>
}

public struct UpdateRoomMembershipInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRoomMembershipInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateRoomMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRoomMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRoomMembershipOutputError>
}

public struct UpdateRoomMembershipInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRoomMembershipInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateRoomMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRoomMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let roomId = input.roomId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("roomId is nil and needs a value for the path of this operation"))))
        }
        guard let memberId = input.memberId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("memberId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/memberships/\(memberId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRoomMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRoomMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRoomMembershipOutputError>
}

public struct UpdateRoomMembershipInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The member ID.
    /// This member is required.
    public var memberId: Swift.String?
    /// The role of the member.
    public var role: ChimeClientTypes.RoomMembershipRole?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        role: ChimeClientTypes.RoomMembershipRole? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.memberId = memberId
        self.role = role
        self.roomId = roomId
    }
}

struct UpdateRoomMembershipInputBody: Swift.Equatable {
    public let role: ChimeClientTypes.RoomMembershipRole?
}

extension UpdateRoomMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RoomMembershipRole.self, forKey: .role)
        role = roleDecoded
    }
}

extension UpdateRoomMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoomMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoomMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoomMembershipOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRoomMembershipOutputResponse(roomMembership: \(Swift.String(describing: roomMembership)))"}
}

extension UpdateRoomMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRoomMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.roomMembership = output.roomMembership
        } else {
            self.roomMembership = nil
        }
    }
}

public struct UpdateRoomMembershipOutputResponse: Swift.Equatable {
    /// The room membership details.
    public var roomMembership: ChimeClientTypes.RoomMembership?

    public init (
        roomMembership: ChimeClientTypes.RoomMembership? = nil
    )
    {
        self.roomMembership = roomMembership
    }
}

struct UpdateRoomMembershipOutputResponseBody: Swift.Equatable {
    public let roomMembership: ChimeClientTypes.RoomMembership?
}

extension UpdateRoomMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomMembership = "RoomMembership"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomMembershipDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RoomMembership.self, forKey: .roomMembership)
        roomMembership = roomMembershipDecoded
    }
}

extension UpdateRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoomOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoomOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRoomOutputResponse(room: \(Swift.String(describing: room)))"}
}

extension UpdateRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRoomOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.room = output.room
        } else {
            self.room = nil
        }
    }
}

public struct UpdateRoomOutputResponse: Swift.Equatable {
    /// The room details.
    public var room: ChimeClientTypes.Room?

    public init (
        room: ChimeClientTypes.Room? = nil
    )
    {
        self.room = room
    }
}

struct UpdateRoomOutputResponseBody: Swift.Equatable {
    public let room: ChimeClientTypes.Room?
}

extension UpdateRoomOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case room = "Room"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Room.self, forKey: .room)
        room = roomDecoded
    }
}

public struct UpdateSipMediaApplicationCallInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSipMediaApplicationCallInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSipMediaApplicationCallInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSipMediaApplicationCallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSipMediaApplicationCallInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSipMediaApplicationCallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSipMediaApplicationCallOutputError>
}

extension UpdateSipMediaApplicationCallInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSipMediaApplicationCallInput(arguments: \(Swift.String(describing: arguments)), sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)), transactionId: \(Swift.String(describing: transactionId)))"}
}

extension UpdateSipMediaApplicationCallInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arguments = "Arguments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arguments = arguments {
            var argumentsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .arguments)
            for (dictKey0, smaupdatecallargumentsmap0) in arguments {
                try argumentsContainer.encode(smaupdatecallargumentsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateSipMediaApplicationCallInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSipMediaApplicationCallInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSipMediaApplicationCallInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSipMediaApplicationCallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSipMediaApplicationCallInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSipMediaApplicationCallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSipMediaApplicationCallOutputError>
}

public struct UpdateSipMediaApplicationCallInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSipMediaApplicationCallInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSipMediaApplicationCallInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSipMediaApplicationCallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSipMediaApplicationCallInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSipMediaApplicationCallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSipMediaApplicationCallOutputError>
}

public struct UpdateSipMediaApplicationCallInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSipMediaApplicationCallInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateSipMediaApplicationCallInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSipMediaApplicationCallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSipMediaApplicationCallInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSipMediaApplicationCallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSipMediaApplicationCallOutputError>
}

public struct UpdateSipMediaApplicationCallInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSipMediaApplicationCallInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateSipMediaApplicationCallInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSipMediaApplicationCallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sipMediaApplicationId = input.sipMediaApplicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sipMediaApplicationId is nil and needs a value for the path of this operation"))))
        }
        guard let transactionId = input.transactionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("transactionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/calls/\(transactionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSipMediaApplicationCallInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSipMediaApplicationCallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSipMediaApplicationCallOutputError>
}

public struct UpdateSipMediaApplicationCallInput: Swift.Equatable {
    /// Arguments made available to the Lambda function as part of the CALL_UPDATE_REQUESTED event. Can contain 0-20 key-value pairs.
    /// This member is required.
    public var arguments: [Swift.String:Swift.String]?
    /// The ID of the SIP media application handling the call.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// The ID of the call transaction.
    /// This member is required.
    public var transactionId: Swift.String?

    public init (
        arguments: [Swift.String:Swift.String]? = nil,
        sipMediaApplicationId: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.arguments = arguments
        self.sipMediaApplicationId = sipMediaApplicationId
        self.transactionId = transactionId
    }
}

struct UpdateSipMediaApplicationCallInputBody: Swift.Equatable {
    public let arguments: [Swift.String:Swift.String]?
}

extension UpdateSipMediaApplicationCallInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arguments = "Arguments"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let argumentsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .arguments)
        var argumentsDecoded0: [Swift.String:Swift.String]? = nil
        if let argumentsContainer = argumentsContainer {
            argumentsDecoded0 = [Swift.String:Swift.String]()
            for (key0, sensitivestring0) in argumentsContainer {
                if let sensitivestring0 = sensitivestring0 {
                    argumentsDecoded0?[key0] = sensitivestring0
                }
            }
        }
        arguments = argumentsDecoded0
    }
}

extension UpdateSipMediaApplicationCallOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSipMediaApplicationCallOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSipMediaApplicationCallOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSipMediaApplicationCallOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSipMediaApplicationCallOutputResponse(sipMediaApplicationCall: \(Swift.String(describing: sipMediaApplicationCall)))"}
}

extension UpdateSipMediaApplicationCallOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSipMediaApplicationCallOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationCall = output.sipMediaApplicationCall
        } else {
            self.sipMediaApplicationCall = nil
        }
    }
}

public struct UpdateSipMediaApplicationCallOutputResponse: Swift.Equatable {
    /// A Call instance for a SIP media application.
    public var sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall?

    public init (
        sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall? = nil
    )
    {
        self.sipMediaApplicationCall = sipMediaApplicationCall
    }
}

struct UpdateSipMediaApplicationCallOutputResponseBody: Swift.Equatable {
    public let sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall?
}

extension UpdateSipMediaApplicationCallOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationCall = "SipMediaApplicationCall"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationCallDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplicationCall.self, forKey: .sipMediaApplicationCall)
        sipMediaApplicationCall = sipMediaApplicationCallDecoded
    }
}

public struct UpdateSipMediaApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSipMediaApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSipMediaApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSipMediaApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSipMediaApplicationOutputError>
}

extension UpdateSipMediaApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSipMediaApplicationInput(endpoints: \(Swift.String(describing: endpoints)), name: \(Swift.String(describing: name)), sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)))"}
}

extension UpdateSipMediaApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for sipmediaapplicationendpointlist0 in endpoints {
                try endpointsContainer.encode(sipmediaapplicationendpointlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateSipMediaApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSipMediaApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSipMediaApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSipMediaApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSipMediaApplicationOutputError>
}

public struct UpdateSipMediaApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSipMediaApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSipMediaApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSipMediaApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSipMediaApplicationOutputError>
}

public struct UpdateSipMediaApplicationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSipMediaApplicationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateSipMediaApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSipMediaApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSipMediaApplicationOutputError>
}

public struct UpdateSipMediaApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSipMediaApplicationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateSipMediaApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSipMediaApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sipMediaApplicationId = input.sipMediaApplicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sipMediaApplicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSipMediaApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSipMediaApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSipMediaApplicationOutputError>
}

public struct UpdateSipMediaApplicationInput: Swift.Equatable {
    /// The new set of endpoints for the specified SIP media application.
    public var endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]?
    /// The new name for the specified SIP media application.
    public var name: Swift.String?
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init (
        endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]? = nil,
        name: Swift.String? = nil,
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.name = name
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct UpdateSipMediaApplicationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]?
}

extension UpdateSipMediaApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipMediaApplicationEndpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[ChimeClientTypes.SipMediaApplicationEndpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [ChimeClientTypes.SipMediaApplicationEndpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension UpdateSipMediaApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSipMediaApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSipMediaApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSipMediaApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSipMediaApplicationOutputResponse(sipMediaApplication: \(Swift.String(describing: sipMediaApplication)))"}
}

extension UpdateSipMediaApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSipMediaApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplication = output.sipMediaApplication
        } else {
            self.sipMediaApplication = nil
        }
    }
}

public struct UpdateSipMediaApplicationOutputResponse: Swift.Equatable {
    /// The updated SIP media application details.
    public var sipMediaApplication: ChimeClientTypes.SipMediaApplication?

    public init (
        sipMediaApplication: ChimeClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

struct UpdateSipMediaApplicationOutputResponseBody: Swift.Equatable {
    public let sipMediaApplication: ChimeClientTypes.SipMediaApplication?
}

extension UpdateSipMediaApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplication = "SipMediaApplication"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplication.self, forKey: .sipMediaApplication)
        sipMediaApplication = sipMediaApplicationDecoded
    }
}

public struct UpdateSipRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSipRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSipRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSipRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSipRuleOutputError>
}

extension UpdateSipRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSipRuleInput(disabled: \(Swift.String(describing: disabled)), name: \(Swift.String(describing: name)), sipRuleId: \(Swift.String(describing: sipRuleId)), targetApplications: \(Swift.String(describing: targetApplications)))"}
}

extension UpdateSipRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetApplications = targetApplications {
            var targetApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetApplications)
            for sipruletargetapplicationlist0 in targetApplications {
                try targetApplicationsContainer.encode(sipruletargetapplicationlist0)
            }
        }
    }
}

public struct UpdateSipRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSipRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSipRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSipRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSipRuleOutputError>
}

public struct UpdateSipRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSipRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSipRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSipRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSipRuleOutputError>
}

public struct UpdateSipRuleInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSipRuleInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateSipRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSipRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSipRuleOutputError>
}

public struct UpdateSipRuleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSipRuleInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateSipRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSipRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let sipRuleId = input.sipRuleId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sipRuleId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sip-rules/\(sipRuleId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSipRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSipRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSipRuleOutputError>
}

public struct UpdateSipRuleInput: Swift.Equatable {
    /// The new value specified to indicate whether the rule is disabled.
    public var disabled: Swift.Bool?
    /// The new name for the specified SIP rule.
    /// This member is required.
    public var name: Swift.String?
    /// The SIP rule ID.
    /// This member is required.
    public var sipRuleId: Swift.String?
    /// The new value of the list of target applications.
    public var targetApplications: [ChimeClientTypes.SipRuleTargetApplication]?

    public init (
        disabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        sipRuleId: Swift.String? = nil,
        targetApplications: [ChimeClientTypes.SipRuleTargetApplication]? = nil
    )
    {
        self.disabled = disabled
        self.name = name
        self.sipRuleId = sipRuleId
        self.targetApplications = targetApplications
    }
}

struct UpdateSipRuleInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let disabled: Swift.Bool?
    public let targetApplications: [ChimeClientTypes.SipRuleTargetApplication]?
}

extension UpdateSipRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let targetApplicationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipRuleTargetApplication?].self, forKey: .targetApplications)
        var targetApplicationsDecoded0:[ChimeClientTypes.SipRuleTargetApplication]? = nil
        if let targetApplicationsContainer = targetApplicationsContainer {
            targetApplicationsDecoded0 = [ChimeClientTypes.SipRuleTargetApplication]()
            for structure0 in targetApplicationsContainer {
                if let structure0 = structure0 {
                    targetApplicationsDecoded0?.append(structure0)
                }
            }
        }
        targetApplications = targetApplicationsDecoded0
    }
}

extension UpdateSipRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSipRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSipRuleOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSipRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSipRuleOutputResponse(sipRule: \(Swift.String(describing: sipRule)))"}
}

extension UpdateSipRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSipRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipRule = output.sipRule
        } else {
            self.sipRule = nil
        }
    }
}

public struct UpdateSipRuleOutputResponse: Swift.Equatable {
    /// Updated SIP rule details.
    public var sipRule: ChimeClientTypes.SipRule?

    public init (
        sipRule: ChimeClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

struct UpdateSipRuleOutputResponseBody: Swift.Equatable {
    public let sipRule: ChimeClientTypes.SipRule?
}

extension UpdateSipRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipRule = "SipRule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipRule.self, forKey: .sipRule)
        sipRule = sipRuleDecoded
    }
}

public struct UpdateUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserOutputError>
}

extension UpdateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserInput(accountId: \(Swift.String(describing: accountId)), alexaForBusinessMetadata: \(Swift.String(describing: alexaForBusinessMetadata)), licenseType: \(Swift.String(describing: licenseType)), userId: \(Swift.String(describing: userId)), userType: \(Swift.String(describing: userType)))"}
}

extension UpdateUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alexaForBusinessMetadata = "AlexaForBusinessMetadata"
        case licenseType = "LicenseType"
        case userType = "UserType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alexaForBusinessMetadata = alexaForBusinessMetadata {
            try encodeContainer.encode(alexaForBusinessMetadata, forKey: .alexaForBusinessMetadata)
        }
        if let licenseType = licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let userType = userType {
            try encodeContainer.encode(userType.rawValue, forKey: .userType)
        }
    }
}

public struct UpdateUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserOutputError>
}

public struct UpdateUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserOutputError>
}

public struct UpdateUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserOutputError>
}

public struct UpdateUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let userId = input.userId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("userId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserOutputError>
}

public struct UpdateUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Alexa for Business metadata.
    public var alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata?
    /// The user license type to update. This must be a supported license type for the Amazon Chime
    ///             account that the user belongs to.
    public var licenseType: ChimeClientTypes.License?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?
    /// The user type.
    public var userType: ChimeClientTypes.UserType?

    public init (
        accountId: Swift.String? = nil,
        alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata? = nil,
        licenseType: ChimeClientTypes.License? = nil,
        userId: Swift.String? = nil,
        userType: ChimeClientTypes.UserType? = nil
    )
    {
        self.accountId = accountId
        self.alexaForBusinessMetadata = alexaForBusinessMetadata
        self.licenseType = licenseType
        self.userId = userId
        self.userType = userType
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    public let licenseType: ChimeClientTypes.License?
    public let userType: ChimeClientTypes.UserType?
    public let alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alexaForBusinessMetadata = "AlexaForBusinessMetadata"
        case licenseType = "LicenseType"
        case userType = "UserType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.License.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let userTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.UserType.self, forKey: .userType)
        userType = userTypeDecoded
        let alexaForBusinessMetadataDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AlexaForBusinessMetadata.self, forKey: .alexaForBusinessMetadata)
        alexaForBusinessMetadata = alexaForBusinessMetadataDecoded
    }
}

extension UpdateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserOutputResponse(user: \(Swift.String(describing: user)))"}
}

extension UpdateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct UpdateUserOutputResponse: Swift.Equatable {
    /// The updated user details.
    public var user: ChimeClientTypes.User?

    public init (
        user: ChimeClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct UpdateUserOutputResponseBody: Swift.Equatable {
    public let user: ChimeClientTypes.User?
}

extension UpdateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

extension ChimeClientTypes.UpdateUserRequestItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alexaForBusinessMetadata = "AlexaForBusinessMetadata"
        case licenseType = "LicenseType"
        case userId = "UserId"
        case userType = "UserType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alexaForBusinessMetadata = alexaForBusinessMetadata {
            try encodeContainer.encode(alexaForBusinessMetadata, forKey: .alexaForBusinessMetadata)
        }
        if let licenseType = licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let userType = userType {
            try encodeContainer.encode(userType.rawValue, forKey: .userType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let licenseTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.License.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let userTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.UserType.self, forKey: .userType)
        userType = userTypeDecoded
        let alexaForBusinessMetadataDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AlexaForBusinessMetadata.self, forKey: .alexaForBusinessMetadata)
        alexaForBusinessMetadata = alexaForBusinessMetadataDecoded
    }
}

extension ChimeClientTypes.UpdateUserRequestItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserRequestItem(alexaForBusinessMetadata: \(Swift.String(describing: alexaForBusinessMetadata)), licenseType: \(Swift.String(describing: licenseType)), userId: \(Swift.String(describing: userId)), userType: \(Swift.String(describing: userType)))"}
}

extension ChimeClientTypes {
    /// The user ID and user fields to update, used with the
    /// BatchUpdateUser action.
    public struct UpdateUserRequestItem: Swift.Equatable {
        /// The Alexa for Business metadata.
        public var alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata?
        /// The user license type.
        public var licenseType: ChimeClientTypes.License?
        /// The user ID.
        /// This member is required.
        public var userId: Swift.String?
        /// The user type.
        public var userType: ChimeClientTypes.UserType?

        public init (
            alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata? = nil,
            licenseType: ChimeClientTypes.License? = nil,
            userId: Swift.String? = nil,
            userType: ChimeClientTypes.UserType? = nil
        )
        {
            self.alexaForBusinessMetadata = alexaForBusinessMetadata
            self.licenseType = licenseType
            self.userId = userId
            self.userType = userType
        }
    }

}

public struct UpdateUserSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserSettingsOutputError>
}

extension UpdateUserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserSettingsInput(accountId: \(Swift.String(describing: accountId)), userId: \(Swift.String(describing: userId)), userSettings: \(Swift.String(describing: userSettings)))"}
}

extension UpdateUserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettings = "UserSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userSettings = userSettings {
            try encodeContainer.encode(userSettings, forKey: .userSettings)
        }
    }
}

public struct UpdateUserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserSettingsOutputError>
}

public struct UpdateUserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserSettingsOutputError>
}

public struct UpdateUserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserSettingsOutputError>
}

public struct UpdateUserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accountId = input.accountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accountId is nil and needs a value for the path of this operation"))))
        }
        guard let userId = input.userId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("userId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())/settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserSettingsOutputError>
}

public struct UpdateUserSettingsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?
    /// The user settings to update.
    /// This member is required.
    public var userSettings: ChimeClientTypes.UserSettings?

    public init (
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil,
        userSettings: ChimeClientTypes.UserSettings? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
        self.userSettings = userSettings
    }
}

struct UpdateUserSettingsInputBody: Swift.Equatable {
    public let userSettings: ChimeClientTypes.UserSettings?
}

extension UpdateUserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettings = "UserSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.UserSettings.self, forKey: .userSettings)
        userSettings = userSettingsDecoded
    }
}

extension UpdateUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserSettingsOutputResponse()"}
}

extension UpdateUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserSettingsOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateUserSettingsOutputResponseBody: Swift.Equatable {
}

extension UpdateUserSettingsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateVoiceConnectorGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVoiceConnectorGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVoiceConnectorGroupOutputError>
}

extension UpdateVoiceConnectorGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVoiceConnectorGroupInput(name: \(Swift.String(describing: name)), voiceConnectorGroupId: \(Swift.String(describing: voiceConnectorGroupId)), voiceConnectorItems: \(Swift.String(describing: voiceConnectorItems)))"}
}

extension UpdateVoiceConnectorGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let voiceConnectorItems = voiceConnectorItems {
            var voiceConnectorItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .voiceConnectorItems)
            for voiceconnectoritemlist0 in voiceConnectorItems {
                try voiceConnectorItemsContainer.encode(voiceconnectoritemlist0)
            }
        }
    }
}

public struct UpdateVoiceConnectorGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVoiceConnectorGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVoiceConnectorGroupOutputError>
}

public struct UpdateVoiceConnectorGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVoiceConnectorGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVoiceConnectorGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVoiceConnectorGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVoiceConnectorGroupOutputError>
}

public struct UpdateVoiceConnectorGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVoiceConnectorGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateVoiceConnectorGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateVoiceConnectorGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVoiceConnectorGroupOutputError>
}

public struct UpdateVoiceConnectorGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVoiceConnectorGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateVoiceConnectorGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVoiceConnectorGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorGroupId = input.voiceConnectorGroupId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorGroupId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateVoiceConnectorGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVoiceConnectorGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVoiceConnectorGroupOutputError>
}

public struct UpdateVoiceConnectorGroupInput: Swift.Equatable {
    /// The name of the Amazon Chime Voice Connector group.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Chime Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?
    /// The VoiceConnectorItems to associate with the group.
    /// This member is required.
    public var voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]?

    public init (
        name: Swift.String? = nil,
        voiceConnectorGroupId: Swift.String? = nil,
        voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]? = nil
    )
    {
        self.name = name
        self.voiceConnectorGroupId = voiceConnectorGroupId
        self.voiceConnectorItems = voiceConnectorItems
    }
}

struct UpdateVoiceConnectorGroupInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]?
}

extension UpdateVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let voiceConnectorItemsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.VoiceConnectorItem?].self, forKey: .voiceConnectorItems)
        var voiceConnectorItemsDecoded0:[ChimeClientTypes.VoiceConnectorItem]? = nil
        if let voiceConnectorItemsContainer = voiceConnectorItemsContainer {
            voiceConnectorItemsDecoded0 = [ChimeClientTypes.VoiceConnectorItem]()
            for structure0 in voiceConnectorItemsContainer {
                if let structure0 = structure0 {
                    voiceConnectorItemsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorItems = voiceConnectorItemsDecoded0
    }
}

extension UpdateVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVoiceConnectorGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVoiceConnectorGroupOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVoiceConnectorGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVoiceConnectorGroupOutputResponse(voiceConnectorGroup: \(Swift.String(describing: voiceConnectorGroup)))"}
}

extension UpdateVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateVoiceConnectorGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorGroup = output.voiceConnectorGroup
        } else {
            self.voiceConnectorGroup = nil
        }
    }
}

public struct UpdateVoiceConnectorGroupOutputResponse: Swift.Equatable {
    /// The updated Amazon Chime Voice Connector group details.
    public var voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup?

    public init (
        voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

struct UpdateVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
    public let voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup?
}

extension UpdateVoiceConnectorGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorGroup = "VoiceConnectorGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnectorGroup.self, forKey: .voiceConnectorGroup)
        voiceConnectorGroup = voiceConnectorGroupDecoded
    }
}

public struct UpdateVoiceConnectorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVoiceConnectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVoiceConnectorOutputError>
}

extension UpdateVoiceConnectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVoiceConnectorInput(name: \(Swift.String(describing: name)), requireEncryption: \(Swift.String(describing: requireEncryption)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension UpdateVoiceConnectorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requireEncryption = requireEncryption {
            try encodeContainer.encode(requireEncryption, forKey: .requireEncryption)
        }
    }
}

public struct UpdateVoiceConnectorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVoiceConnectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVoiceConnectorOutputError>
}

public struct UpdateVoiceConnectorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVoiceConnectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVoiceConnectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVoiceConnectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVoiceConnectorOutputError>
}

public struct UpdateVoiceConnectorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVoiceConnectorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateVoiceConnectorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateVoiceConnectorInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVoiceConnectorOutputError>
}

public struct UpdateVoiceConnectorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVoiceConnectorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateVoiceConnectorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVoiceConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let voiceConnectorId = input.voiceConnectorId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("voiceConnectorId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateVoiceConnectorInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVoiceConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVoiceConnectorOutputError>
}

public struct UpdateVoiceConnectorInput: Swift.Equatable {
    /// The name of the Amazon Chime Voice Connector.
    /// This member is required.
    public var name: Swift.String?
    /// When enabled, requires encryption for the Amazon Chime Voice Connector.
    /// This member is required.
    public var requireEncryption: Swift.Bool?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        name: Swift.String? = nil,
        requireEncryption: Swift.Bool? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.name = name
        self.requireEncryption = requireEncryption
        self.voiceConnectorId = voiceConnectorId
    }
}

struct UpdateVoiceConnectorInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let requireEncryption: Swift.Bool?
}

extension UpdateVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requireEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireEncryption)
        requireEncryption = requireEncryptionDecoded
    }
}

extension UpdateVoiceConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVoiceConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVoiceConnectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVoiceConnectorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVoiceConnectorOutputResponse(voiceConnector: \(Swift.String(describing: voiceConnector)))"}
}

extension UpdateVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateVoiceConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct UpdateVoiceConnectorOutputResponse: Swift.Equatable {
    /// The updated Amazon Chime Voice Connector details.
    public var voiceConnector: ChimeClientTypes.VoiceConnector?

    public init (
        voiceConnector: ChimeClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct UpdateVoiceConnectorOutputResponseBody: Swift.Equatable {
    public let voiceConnector: ChimeClientTypes.VoiceConnector?
}

extension UpdateVoiceConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnector.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension ChimeClientTypes.User: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alexaForBusinessMetadata = "AlexaForBusinessMetadata"
        case displayName = "DisplayName"
        case invitedOn = "InvitedOn"
        case licenseType = "LicenseType"
        case personalPIN = "PersonalPIN"
        case primaryEmail = "PrimaryEmail"
        case primaryProvisionedNumber = "PrimaryProvisionedNumber"
        case registeredOn = "RegisteredOn"
        case userId = "UserId"
        case userInvitationStatus = "UserInvitationStatus"
        case userRegistrationStatus = "UserRegistrationStatus"
        case userType = "UserType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let alexaForBusinessMetadata = alexaForBusinessMetadata {
            try encodeContainer.encode(alexaForBusinessMetadata, forKey: .alexaForBusinessMetadata)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let invitedOn = invitedOn {
            try encodeContainer.encode(invitedOn.timeIntervalSince1970, forKey: .invitedOn)
        }
        if let licenseType = licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let personalPIN = personalPIN {
            try encodeContainer.encode(personalPIN, forKey: .personalPIN)
        }
        if let primaryEmail = primaryEmail {
            try encodeContainer.encode(primaryEmail, forKey: .primaryEmail)
        }
        if let primaryProvisionedNumber = primaryProvisionedNumber {
            try encodeContainer.encode(primaryProvisionedNumber, forKey: .primaryProvisionedNumber)
        }
        if let registeredOn = registeredOn {
            try encodeContainer.encode(registeredOn.timeIntervalSince1970, forKey: .registeredOn)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let userInvitationStatus = userInvitationStatus {
            try encodeContainer.encode(userInvitationStatus.rawValue, forKey: .userInvitationStatus)
        }
        if let userRegistrationStatus = userRegistrationStatus {
            try encodeContainer.encode(userRegistrationStatus.rawValue, forKey: .userRegistrationStatus)
        }
        if let userType = userType {
            try encodeContainer.encode(userType.rawValue, forKey: .userType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let primaryEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryEmail)
        primaryEmail = primaryEmailDecoded
        let primaryProvisionedNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryProvisionedNumber)
        primaryProvisionedNumber = primaryProvisionedNumberDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let licenseTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.License.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let userTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.UserType.self, forKey: .userType)
        userType = userTypeDecoded
        let userRegistrationStatusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RegistrationStatus.self, forKey: .userRegistrationStatus)
        userRegistrationStatus = userRegistrationStatusDecoded
        let userInvitationStatusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.InviteStatus.self, forKey: .userInvitationStatus)
        userInvitationStatus = userInvitationStatusDecoded
        let registeredOnDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .registeredOn)
        registeredOn = registeredOnDecoded
        let invitedOnDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .invitedOn)
        invitedOn = invitedOnDecoded
        let alexaForBusinessMetadataDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AlexaForBusinessMetadata.self, forKey: .alexaForBusinessMetadata)
        alexaForBusinessMetadata = alexaForBusinessMetadataDecoded
        let personalPINDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .personalPIN)
        personalPIN = personalPINDecoded
    }
}

extension ChimeClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(accountId: \(Swift.String(describing: accountId)), alexaForBusinessMetadata: \(Swift.String(describing: alexaForBusinessMetadata)), displayName: \(Swift.String(describing: displayName)), invitedOn: \(Swift.String(describing: invitedOn)), licenseType: \(Swift.String(describing: licenseType)), personalPIN: \(Swift.String(describing: personalPIN)), primaryEmail: \(Swift.String(describing: primaryEmail)), primaryProvisionedNumber: \(Swift.String(describing: primaryProvisionedNumber)), registeredOn: \(Swift.String(describing: registeredOn)), userId: \(Swift.String(describing: userId)), userInvitationStatus: \(Swift.String(describing: userInvitationStatus)), userRegistrationStatus: \(Swift.String(describing: userRegistrationStatus)), userType: \(Swift.String(describing: userType)))"}
}

extension ChimeClientTypes {
    /// The user on the Amazon Chime account.
    public struct User: Swift.Equatable {
        /// The Amazon Chime account ID.
        public var accountId: Swift.String?
        /// The Alexa for Business metadata.
        public var alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata?
        /// The display name of the user.
        public var displayName: Swift.String?
        /// Date and time when the user is invited to the Amazon Chime account, in ISO 8601 format.
        public var invitedOn: ClientRuntime.Date?
        /// The license type for the user.
        public var licenseType: ChimeClientTypes.License?
        /// The user's personal meeting PIN.
        public var personalPIN: Swift.String?
        /// The primary email address of the user.
        public var primaryEmail: Swift.String?
        /// The primary phone number associated with the user.
        public var primaryProvisionedNumber: Swift.String?
        /// Date and time when the user is registered, in ISO 8601 format.
        public var registeredOn: ClientRuntime.Date?
        /// The user ID.
        /// This member is required.
        public var userId: Swift.String?
        /// The user invite status.
        public var userInvitationStatus: ChimeClientTypes.InviteStatus?
        /// The user registration status.
        public var userRegistrationStatus: ChimeClientTypes.RegistrationStatus?
        /// The user type.
        public var userType: ChimeClientTypes.UserType?

        public init (
            accountId: Swift.String? = nil,
            alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata? = nil,
            displayName: Swift.String? = nil,
            invitedOn: ClientRuntime.Date? = nil,
            licenseType: ChimeClientTypes.License? = nil,
            personalPIN: Swift.String? = nil,
            primaryEmail: Swift.String? = nil,
            primaryProvisionedNumber: Swift.String? = nil,
            registeredOn: ClientRuntime.Date? = nil,
            userId: Swift.String? = nil,
            userInvitationStatus: ChimeClientTypes.InviteStatus? = nil,
            userRegistrationStatus: ChimeClientTypes.RegistrationStatus? = nil,
            userType: ChimeClientTypes.UserType? = nil
        )
        {
            self.accountId = accountId
            self.alexaForBusinessMetadata = alexaForBusinessMetadata
            self.displayName = displayName
            self.invitedOn = invitedOn
            self.licenseType = licenseType
            self.personalPIN = personalPIN
            self.primaryEmail = primaryEmail
            self.primaryProvisionedNumber = primaryProvisionedNumber
            self.registeredOn = registeredOn
            self.userId = userId
            self.userInvitationStatus = userInvitationStatus
            self.userRegistrationStatus = userRegistrationStatus
            self.userType = userType
        }
    }

}

extension ChimeClientTypes.UserError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeClientTypes.UserError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), userId: \(Swift.String(describing: userId)))"}
}

extension ChimeClientTypes {
    /// The list of errors returned when errors are encountered during the BatchSuspendUser, BatchUnsuspendUser, or
    ///     BatchUpdateUser actions. This includes user IDs, error codes, and error messages.
    public struct UserError: Swift.Equatable {
        /// The error code.
        public var errorCode: ChimeClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The user ID for which the action failed.
        public var userId: Swift.String?

        public init (
            errorCode: ChimeClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.userId = userId
        }
    }

}

extension ChimeClientTypes.UserSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case telephony = "Telephony"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let telephony = telephony {
            try encodeContainer.encode(telephony, forKey: .telephony)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telephonyDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TelephonySettings.self, forKey: .telephony)
        telephony = telephonyDecoded
    }
}

extension ChimeClientTypes.UserSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserSettings(telephony: \(Swift.String(describing: telephony)))"}
}

extension ChimeClientTypes {
    /// Settings associated with an Amazon Chime user, including inbound and outbound calling and text
    ///             messaging.
    public struct UserSettings: Swift.Equatable {
        /// The telephony settings associated with the user.
        /// This member is required.
        public var telephony: ChimeClientTypes.TelephonySettings?

        public init (
            telephony: ChimeClientTypes.TelephonySettings? = nil
        )
        {
            self.telephony = telephony
        }
    }

}

extension ChimeClientTypes {
    public enum UserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case privateuser
        case shareddevice
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .privateuser,
                .shareddevice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .privateuser: return "PrivateUser"
            case .shareddevice: return "SharedDevice"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserType(rawValue: rawValue) ?? UserType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.VoiceConnector: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case createdTimestamp = "CreatedTimestamp"
        case name = "Name"
        case outboundHostName = "OutboundHostName"
        case requireEncryption = "RequireEncryption"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion.rawValue, forKey: .awsRegion)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outboundHostName = outboundHostName {
            try encodeContainer.encode(outboundHostName, forKey: .outboundHostName)
        }
        if let requireEncryption = requireEncryption {
            try encodeContainer.encode(requireEncryption, forKey: .requireEncryption)
        }
        if let updatedTimestamp = updatedTimestamp {
            try encodeContainer.encode(updatedTimestamp.timeIntervalSince1970, forKey: .updatedTimestamp)
        }
        if let voiceConnectorId = voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnectorAwsRegion.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let outboundHostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundHostName)
        outboundHostName = outboundHostNameDecoded
        let requireEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireEncryption)
        requireEncryption = requireEncryptionDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeClientTypes.VoiceConnector: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VoiceConnector(awsRegion: \(Swift.String(describing: awsRegion)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), name: \(Swift.String(describing: name)), outboundHostName: \(Swift.String(describing: outboundHostName)), requireEncryption: \(Swift.String(describing: requireEncryption)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension ChimeClientTypes {
    /// The Amazon Chime Voice Connector configuration, including outbound host name and encryption
    ///             settings.
    public struct VoiceConnector: Swift.Equatable {
        ///
        /// The AWS Region in which the Amazon Chime Voice Connector is created. Default:
        /// us-east-1.
        ///
        public var awsRegion: ChimeClientTypes.VoiceConnectorAwsRegion?
        /// The Amazon Chime Voice Connector creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The name of the Amazon Chime Voice Connector.
        public var name: Swift.String?
        /// The outbound host name for the Amazon Chime Voice Connector.
        public var outboundHostName: Swift.String?
        /// Designates whether encryption is required for the Amazon Chime Voice Connector.
        public var requireEncryption: Swift.Bool?
        /// The updated Amazon Chime Voice Connector timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The Amazon Chime Voice Connector ID.
        public var voiceConnectorId: Swift.String?

        public init (
            awsRegion: ChimeClientTypes.VoiceConnectorAwsRegion? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            outboundHostName: Swift.String? = nil,
            requireEncryption: Swift.Bool? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.createdTimestamp = createdTimestamp
            self.name = name
            self.outboundHostName = outboundHostName
            self.requireEncryption = requireEncryption
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeClientTypes {
    public enum VoiceConnectorAwsRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case usEast1
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceConnectorAwsRegion] {
            return [
                .usEast1,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .usEast1: return "us-east-1"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceConnectorAwsRegion(rawValue: rawValue) ?? VoiceConnectorAwsRegion.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.VoiceConnectorGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case name = "Name"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceConnectorGroupId = "VoiceConnectorGroupId"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedTimestamp = updatedTimestamp {
            try encodeContainer.encode(updatedTimestamp.timeIntervalSince1970, forKey: .updatedTimestamp)
        }
        if let voiceConnectorGroupId = voiceConnectorGroupId {
            try encodeContainer.encode(voiceConnectorGroupId, forKey: .voiceConnectorGroupId)
        }
        if let voiceConnectorItems = voiceConnectorItems {
            var voiceConnectorItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .voiceConnectorItems)
            for voiceconnectoritemlist0 in voiceConnectorItems {
                try voiceConnectorItemsContainer.encode(voiceconnectoritemlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorGroupId)
        voiceConnectorGroupId = voiceConnectorGroupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let voiceConnectorItemsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.VoiceConnectorItem?].self, forKey: .voiceConnectorItems)
        var voiceConnectorItemsDecoded0:[ChimeClientTypes.VoiceConnectorItem]? = nil
        if let voiceConnectorItemsContainer = voiceConnectorItemsContainer {
            voiceConnectorItemsDecoded0 = [ChimeClientTypes.VoiceConnectorItem]()
            for structure0 in voiceConnectorItemsContainer {
                if let structure0 = structure0 {
                    voiceConnectorItemsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorItems = voiceConnectorItemsDecoded0
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeClientTypes.VoiceConnectorGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VoiceConnectorGroup(createdTimestamp: \(Swift.String(describing: createdTimestamp)), name: \(Swift.String(describing: name)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), voiceConnectorGroupId: \(Swift.String(describing: voiceConnectorGroupId)), voiceConnectorItems: \(Swift.String(describing: voiceConnectorItems)))"}
}

extension ChimeClientTypes {
    /// The Amazon Chime Voice Connector group configuration, including associated Amazon Chime Voice
    ///             Connectors. You can include Amazon Chime Voice Connectors from different AWS Regions in
    ///             your group. This creates a fault tolerant mechanism for fallback in case of availability
    ///             events.
    public struct VoiceConnectorGroup: Swift.Equatable {
        /// The Amazon Chime Voice Connector group creation time stamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The name of the Amazon Chime Voice Connector group.
        public var name: Swift.String?
        /// The updated Amazon Chime Voice Connector group time stamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The Amazon Chime Voice Connector group ID.
        public var voiceConnectorGroupId: Swift.String?
        /// The Amazon Chime Voice Connectors to which to route inbound calls.
        public var voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]?

        public init (
            createdTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceConnectorGroupId: Swift.String? = nil,
            voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.name = name
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorGroupId = voiceConnectorGroupId
            self.voiceConnectorItems = voiceConnectorItems
        }
    }

}

extension ChimeClientTypes.VoiceConnectorItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case priority = "Priority"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let voiceConnectorId = voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension ChimeClientTypes.VoiceConnectorItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VoiceConnectorItem(priority: \(Swift.String(describing: priority)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)))"}
}

extension ChimeClientTypes {
    /// For Amazon Chime Voice Connector groups, the Amazon Chime Voice Connectors to which to route inbound calls. Includes priority configuration settings. Limit: 3
    /// VoiceConnectorItems
    /// per Amazon Chime Voice Connector group.
    public struct VoiceConnectorItem: Swift.Equatable {
        /// The priority associated with the Amazon Chime Voice Connector, with 1 being the highest priority. Higher priority Amazon Chime Voice Connectors are attempted first.
        /// This member is required.
        public var priority: Swift.Int?
        /// The Amazon Chime Voice Connector ID.
        /// This member is required.
        public var voiceConnectorId: Swift.String?

        public init (
            priority: Swift.Int? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.priority = priority
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeClientTypes.VoiceConnectorSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdrBucket = "CdrBucket"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdrBucket = cdrBucket {
            try encodeContainer.encode(cdrBucket, forKey: .cdrBucket)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cdrBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdrBucket)
        cdrBucket = cdrBucketDecoded
    }
}

extension ChimeClientTypes.VoiceConnectorSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VoiceConnectorSettings(cdrBucket: \(Swift.String(describing: cdrBucket)))"}
}

extension ChimeClientTypes {
    /// The Amazon Chime Voice Connector settings. Includes any Amazon S3 buckets designated for
    ///             storing call detail records.
    public struct VoiceConnectorSettings: Swift.Equatable {
        /// The Amazon S3 bucket designated for call detail record storage.
        public var cdrBucket: Swift.String?

        public init (
            cdrBucket: Swift.String? = nil
        )
        {
            self.cdrBucket = cdrBucket
        }
    }

}
