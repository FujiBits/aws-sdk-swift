// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension DaxClientTypes {
    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case immediate
        case requiresReboot
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .immediate,
                .requiresReboot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .immediate: return "IMMEDIATE"
            case .requiresReboot: return "REQUIRES_REBOOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
        }
    }
}

extension DaxClientTypes.Cluster: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeNodes = "ActiveNodes"
        case clusterArn = "ClusterArn"
        case clusterDiscoveryEndpoint = "ClusterDiscoveryEndpoint"
        case clusterName = "ClusterName"
        case description = "Description"
        case iamRoleArn = "IamRoleArn"
        case nodeIdsToRemove = "NodeIdsToRemove"
        case nodeType = "NodeType"
        case nodes = "Nodes"
        case notificationConfiguration = "NotificationConfiguration"
        case parameterGroup = "ParameterGroup"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case sSEDescription = "SSEDescription"
        case securityGroups = "SecurityGroups"
        case status = "Status"
        case subnetGroup = "SubnetGroup"
        case totalNodes = "TotalNodes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeNodes = activeNodes {
            try encodeContainer.encode(activeNodes, forKey: .activeNodes)
        }
        if let clusterArn = clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let clusterDiscoveryEndpoint = clusterDiscoveryEndpoint {
            try encodeContainer.encode(clusterDiscoveryEndpoint, forKey: .clusterDiscoveryEndpoint)
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let nodeIdsToRemove = nodeIdsToRemove {
            var nodeIdsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeIdsToRemove)
            for nodeidentifierlist0 in nodeIdsToRemove {
                try nodeIdsToRemoveContainer.encode(nodeidentifierlist0)
            }
        }
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let nodes = nodes {
            var nodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodes)
            for nodelist0 in nodes {
                try nodesContainer.encode(nodelist0)
            }
        }
        if let notificationConfiguration = notificationConfiguration {
            try encodeContainer.encode(notificationConfiguration, forKey: .notificationConfiguration)
        }
        if let parameterGroup = parameterGroup {
            try encodeContainer.encode(parameterGroup, forKey: .parameterGroup)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let sSEDescription = sSEDescription {
            try encodeContainer.encode(sSEDescription, forKey: .sSEDescription)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroupmembershiplist0 in securityGroups {
                try securityGroupsContainer.encode(securitygroupmembershiplist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subnetGroup = subnetGroup {
            try encodeContainer.encode(subnetGroup, forKey: .subnetGroup)
        }
        if let totalNodes = totalNodes {
            try encodeContainer.encode(totalNodes, forKey: .totalNodes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let totalNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNodes)
        totalNodes = totalNodesDecoded
        let activeNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeNodes)
        activeNodes = activeNodesDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let clusterDiscoveryEndpointDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Endpoint.self, forKey: .clusterDiscoveryEndpoint)
        clusterDiscoveryEndpoint = clusterDiscoveryEndpointDecoded
        let nodeIdsToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodeIdsToRemove)
        var nodeIdsToRemoveDecoded0:[Swift.String]? = nil
        if let nodeIdsToRemoveContainer = nodeIdsToRemoveContainer {
            nodeIdsToRemoveDecoded0 = [Swift.String]()
            for string0 in nodeIdsToRemoveContainer {
                if let string0 = string0 {
                    nodeIdsToRemoveDecoded0?.append(string0)
                }
            }
        }
        nodeIdsToRemove = nodeIdsToRemoveDecoded0
        let nodesContainer = try containerValues.decodeIfPresent([DaxClientTypes.Node?].self, forKey: .nodes)
        var nodesDecoded0:[DaxClientTypes.Node]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [DaxClientTypes.Node]()
            for structure0 in nodesContainer {
                if let structure0 = structure0 {
                    nodesDecoded0?.append(structure0)
                }
            }
        }
        nodes = nodesDecoded0
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(DaxClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
        let subnetGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroup)
        subnetGroup = subnetGroupDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([DaxClientTypes.SecurityGroupMembership?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[DaxClientTypes.SecurityGroupMembership]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [DaxClientTypes.SecurityGroupMembership]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let parameterGroupDecoded = try containerValues.decodeIfPresent(DaxClientTypes.ParameterGroupStatus.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
        let sSEDescriptionDecoded = try containerValues.decodeIfPresent(DaxClientTypes.SSEDescription.self, forKey: .sSEDescription)
        sSEDescription = sSEDescriptionDecoded
    }
}

extension DaxClientTypes.Cluster: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Cluster(activeNodes: \(Swift.String(describing: activeNodes)), clusterArn: \(Swift.String(describing: clusterArn)), clusterDiscoveryEndpoint: \(Swift.String(describing: clusterDiscoveryEndpoint)), clusterName: \(Swift.String(describing: clusterName)), description: \(Swift.String(describing: description)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), nodeIdsToRemove: \(Swift.String(describing: nodeIdsToRemove)), nodeType: \(Swift.String(describing: nodeType)), nodes: \(Swift.String(describing: nodes)), notificationConfiguration: \(Swift.String(describing: notificationConfiguration)), parameterGroup: \(Swift.String(describing: parameterGroup)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), sSEDescription: \(Swift.String(describing: sSEDescription)), securityGroups: \(Swift.String(describing: securityGroups)), status: \(Swift.String(describing: status)), subnetGroup: \(Swift.String(describing: subnetGroup)), totalNodes: \(Swift.String(describing: totalNodes)))"}
}

extension DaxClientTypes {
    /// <p>Contains all of the attributes of a specific DAX cluster.</p>
    public struct Cluster: Swift.Equatable {
        /// <p>The number of nodes in the cluster that are active (i.e., capable of serving
        ///             requests).</p>
        public let activeNodes: Swift.Int?
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        ///         </p>
        public let clusterArn: Swift.String?
        /// <p>The configuration endpoint for this DAX cluster, consisting of a DNS name and a
        ///             port number. Client applications can specify this endpoint, rather than an individual
        ///             node endpoint, and allow the DAX client software to intelligently route requests and
        ///             responses to nodes in the DAX cluster.</p>
        public let clusterDiscoveryEndpoint: DaxClientTypes.Endpoint?
        /// <p>The name of the DAX cluster.</p>
        public let clusterName: Swift.String?
        /// <p>The description of the cluster.</p>
        public let description: Swift.String?
        /// <p>A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX
        ///             will assume this role and use the role's permissions to access DynamoDB on your
        ///             behalf.</p>
        public let iamRoleArn: Swift.String?
        /// <p>A list of nodes to be removed from the cluster.</p>
        public let nodeIdsToRemove: [Swift.String]?
        /// <p>The node type for the nodes in the cluster. (All nodes in a DAX cluster are of
        ///             the same type.)</p>
        public let nodeType: Swift.String?
        /// <p>A list of nodes that are currently in the cluster.</p>
        public let nodes: [DaxClientTypes.Node]?
        /// <p>Describes a notification topic and its status. Notification topics are used for
        ///             publishing DAX events to subscribers using Amazon Simple Notification Service
        ///             (SNS).</p>
        public let notificationConfiguration: DaxClientTypes.NotificationConfiguration?
        /// <p>The parameter group being used by nodes in the cluster.</p>
        public let parameterGroup: DaxClientTypes.ParameterGroupStatus?
        /// <p>A range of time when maintenance of DAX cluster software will be performed. For
        ///             example: <code>sun:01:00-sun:09:00</code>. Cluster maintenance normally takes less than
        ///             30 minutes, and is performed automatically within the maintenance window.</p>
        public let preferredMaintenanceWindow: Swift.String?
        /// <p>The description of the server-side encryption status on the specified DAX cluster.</p>
        public let sSEDescription: DaxClientTypes.SSEDescription?
        /// <p>A list of security groups, and the status of each, for the nodes in the cluster.</p>
        public let securityGroups: [DaxClientTypes.SecurityGroupMembership]?
        /// <p>The current status of the cluster.</p>
        public let status: Swift.String?
        /// <p>The subnet group where the DAX cluster is running.</p>
        public let subnetGroup: Swift.String?
        /// <p>The total number of nodes in the cluster.</p>
        public let totalNodes: Swift.Int?

        public init (
            activeNodes: Swift.Int? = nil,
            clusterArn: Swift.String? = nil,
            clusterDiscoveryEndpoint: DaxClientTypes.Endpoint? = nil,
            clusterName: Swift.String? = nil,
            description: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            nodeIdsToRemove: [Swift.String]? = nil,
            nodeType: Swift.String? = nil,
            nodes: [DaxClientTypes.Node]? = nil,
            notificationConfiguration: DaxClientTypes.NotificationConfiguration? = nil,
            parameterGroup: DaxClientTypes.ParameterGroupStatus? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            sSEDescription: DaxClientTypes.SSEDescription? = nil,
            securityGroups: [DaxClientTypes.SecurityGroupMembership]? = nil,
            status: Swift.String? = nil,
            subnetGroup: Swift.String? = nil,
            totalNodes: Swift.Int? = nil
        )
        {
            self.activeNodes = activeNodes
            self.clusterArn = clusterArn
            self.clusterDiscoveryEndpoint = clusterDiscoveryEndpoint
            self.clusterName = clusterName
            self.description = description
            self.iamRoleArn = iamRoleArn
            self.nodeIdsToRemove = nodeIdsToRemove
            self.nodeType = nodeType
            self.nodes = nodes
            self.notificationConfiguration = notificationConfiguration
            self.parameterGroup = parameterGroup
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.sSEDescription = sSEDescription
            self.securityGroups = securityGroups
            self.status = status
            self.subnetGroup = subnetGroup
            self.totalNodes = totalNodes
        }
    }

}

extension ClusterAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ClusterAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You already have a DAX cluster with the given identifier.</p>
public struct ClusterAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ClusterNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested cluster ID does not refer to an existing DAX cluster.</p>
public struct ClusterNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterQuotaForCustomerExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterQuotaForCustomerExceededFault(message: \(Swift.String(describing: message)))"}
}

extension ClusterQuotaForCustomerExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ClusterQuotaForCustomerExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have attempted to exceed the maximum number of DAX clusters for your AWS
///             account.</p>
public struct ClusterQuotaForCustomerExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterQuotaForCustomerExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterQuotaForCustomerExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

extension CreateClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterInput(availabilityZones: \(Swift.String(describing: availabilityZones)), clusterName: \(Swift.String(describing: clusterName)), description: \(Swift.String(describing: description)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), nodeType: \(Swift.String(describing: nodeType)), notificationTopicArn: \(Swift.String(describing: notificationTopicArn)), parameterGroupName: \(Swift.String(describing: parameterGroupName)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), replicationFactor: \(Swift.String(describing: replicationFactor)), sSESpecification: \(Swift.String(describing: sSESpecification)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetGroupName: \(Swift.String(describing: subnetGroupName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case description = "Description"
        case iamRoleArn = "IamRoleArn"
        case nodeType = "NodeType"
        case notificationTopicArn = "NotificationTopicArn"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationFactor = "ReplicationFactor"
        case sSESpecification = "SSESpecification"
        case securityGroupIds = "SecurityGroupIds"
        case subnetGroupName = "SubnetGroupName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzonelist0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzonelist0)
            }
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let notificationTopicArn = notificationTopicArn {
            try encodeContainer.encode(notificationTopicArn, forKey: .notificationTopicArn)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if replicationFactor != 0 {
            try encodeContainer.encode(replicationFactor, forKey: .replicationFactor)
        }
        if let sSESpecification = sSESpecification {
            try encodeContainer.encode(sSESpecification, forKey: .sSESpecification)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidentifierlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidentifierlist0)
            }
        }
        if let subnetGroupName = subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

public struct CreateClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

public struct CreateClusterInput: Swift.Equatable {
    /// <p>The Availability Zones (AZs) in which the cluster nodes will reside after the cluster
    ///          has been created or updated. If provided, the length of this list must equal the <code>ReplicationFactor</code> parameter.
    ///          If you omit this parameter, DAX will spread the nodes across Availability Zones for the highest availability.</p>
    public let availabilityZones: [Swift.String]?
    /// <p>The cluster identifier. This parameter is stored as a lowercase
    ///             string.</p>
    ///         <p>
    ///             <b>Constraints:</b>
    ///         </p>
    ///         <ul>
    ///             <li>
    ///                 <p>A name must contain from 1 to 20 alphanumeric characters or
    ///                     hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The first character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>A name cannot end with a hyphen or contain two consecutive
    ///                     hyphens.</p>
    ///             </li>
    ///          </ul>
    public let clusterName: Swift.String?
    /// <p>A description of the cluster.</p>
    public let description: Swift.String?
    /// <p>A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX
    ///             will assume this role and use the role's permissions to access DynamoDB on your
    ///             behalf.</p>
    public let iamRoleArn: Swift.String?
    /// <p>The compute and memory capacity of the nodes in the cluster.</p>
    public let nodeType: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to which notifications will
    ///             be sent.</p>
    ///         <note>
    ///             <p>The Amazon SNS topic owner must be same as the DAX cluster owner.</p>
    ///         </note>
    public let notificationTopicArn: Swift.String?
    /// <p>The parameter group to be associated with the DAX cluster.</p>
    public let parameterGroupName: Swift.String?
    /// <p>Specifies the weekly time range during which maintenance on the DAX cluster is
    ///             performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock
    ///             UTC). The minimum maintenance window is a 60 minute period. Valid values for
    ///                 <code>ddd</code> are:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>sun</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>mon</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>tue</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>wed</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>thu</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>fri</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>sat</code>
    ///                 </p>
    ///             </li>
    ///          </ul>
    ///         <p>Example: <code>sun:05:00-sun:09:00</code>
    ///         </p>
    ///         <note>
    ///             <p>If you don't specify a preferred maintenance window when you create or modify a
    ///                 cache cluster, DAX assigns a 60-minute maintenance window on a randomly selected day
    ///                 of the week.</p>
    ///          </note>
    public let preferredMaintenanceWindow: Swift.String?
    /// <p>The number of nodes in the DAX cluster. A replication factor of 1 will
    ///             create a single-node cluster, without any read replicas. For additional fault tolerance,
    ///             you can create a multiple node cluster with one or more read replicas. To do this, set
    ///                 <code>ReplicationFactor</code> to a number between 3 (one primary and two read replicas) and 10 (one primary and nine read replicas).
    ///                  <code>If the AvailabilityZones</code> parameter is provided, its length must equal the <code>ReplicationFactor</code>.</p>
    ///         <note>
    ///             <p>AWS recommends that you have at least two read replicas per cluster.</p>
    ///          </note>
    public let replicationFactor: Swift.Int
    /// <p>Represents the settings used to enable server-side encryption on the cluster.</p>
    public let sSESpecification: DaxClientTypes.SSESpecification?
    /// <p>A list of security group IDs to be assigned to each node in the DAX cluster. (Each of the
    ///              security group ID is system-generated.)</p>
    ///         <p>If this parameter is not specified, DAX assigns the default VPC security group to
    ///             each node.</p>
    public let securityGroupIds: [Swift.String]?
    /// <p>The name of the subnet group to be used for the replication group.</p>
    ///         <important>
    ///             <p>DAX clusters can only run in an Amazon VPC environment. All of the subnets
    ///                 that you specify in a subnet group must exist in the same VPC.</p>
    ///         </important>
    public let subnetGroupName: Swift.String?
    /// <p>A set of tags to associate with the DAX cluster.  </p>
    public let tags: [DaxClientTypes.Tag]?

    public init (
        availabilityZones: [Swift.String]? = nil,
        clusterName: Swift.String? = nil,
        description: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        nodeType: Swift.String? = nil,
        notificationTopicArn: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        replicationFactor: Swift.Int = 0,
        sSESpecification: DaxClientTypes.SSESpecification? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetGroupName: Swift.String? = nil,
        tags: [DaxClientTypes.Tag]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.clusterName = clusterName
        self.description = description
        self.iamRoleArn = iamRoleArn
        self.nodeType = nodeType
        self.notificationTopicArn = notificationTopicArn
        self.parameterGroupName = parameterGroupName
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.replicationFactor = replicationFactor
        self.sSESpecification = sSESpecification
        self.securityGroupIds = securityGroupIds
        self.subnetGroupName = subnetGroupName
        self.tags = tags
    }
}

struct CreateClusterInputBody: Swift.Equatable {
    public let clusterName: Swift.String?
    public let nodeType: Swift.String?
    public let description: Swift.String?
    public let replicationFactor: Swift.Int
    public let availabilityZones: [Swift.String]?
    public let subnetGroupName: Swift.String?
    public let securityGroupIds: [Swift.String]?
    public let preferredMaintenanceWindow: Swift.String?
    public let notificationTopicArn: Swift.String?
    public let iamRoleArn: Swift.String?
    public let parameterGroupName: Swift.String?
    public let tags: [DaxClientTypes.Tag]?
    public let sSESpecification: DaxClientTypes.SSESpecification?
}

extension CreateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case description = "Description"
        case iamRoleArn = "IamRoleArn"
        case nodeType = "NodeType"
        case notificationTopicArn = "NotificationTopicArn"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationFactor = "ReplicationFactor"
        case sSESpecification = "SSESpecification"
        case securityGroupIds = "SecurityGroupIds"
        case subnetGroupName = "SubnetGroupName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let replicationFactorDecoded = try containerValues.decode(Swift.Int.self, forKey: .replicationFactor)
        replicationFactor = replicationFactorDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let notificationTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationTopicArn)
        notificationTopicArn = notificationTopicArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DaxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DaxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DaxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let sSESpecificationDecoded = try containerValues.decodeIfPresent(DaxClientTypes.SSESpecification.self, forKey: .sSESpecification)
        sSESpecification = sSESpecificationDecoded
    }
}

extension CreateClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterAlreadyExistsFault" : self = .clusterAlreadyExistsFault(try ClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterQuotaForCustomerExceededFault" : self = .clusterQuotaForCustomerExceededFault(try ClusterQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForClusterExceededFault" : self = .nodeQuotaForClusterExceededFault(try NodeQuotaForClusterExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForCustomerExceededFault" : self = .nodeQuotaForCustomerExceededFault(try NodeQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagQuotaPerResourceExceeded" : self = .tagQuotaPerResourceExceeded(try TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterAlreadyExistsFault(ClusterAlreadyExistsFault)
    case clusterQuotaForCustomerExceededFault(ClusterQuotaForCustomerExceededFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case nodeQuotaForClusterExceededFault(NodeQuotaForClusterExceededFault)
    case nodeQuotaForCustomerExceededFault(NodeQuotaForCustomerExceededFault)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case tagQuotaPerResourceExceeded(TagQuotaPerResourceExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension CreateClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct CreateClusterOutputResponse: Swift.Equatable {
    /// <p>A description of the DAX cluster that you have created.</p>
    public let cluster: DaxClientTypes.Cluster?

    public init (
        cluster: DaxClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct CreateClusterOutputResponseBody: Swift.Equatable {
    public let cluster: DaxClientTypes.Cluster?
}

extension CreateClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct CreateParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParameterGroupOutputError>
}

extension CreateParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateParameterGroupInput(description: \(Swift.String(describing: description)), parameterGroupName: \(Swift.String(describing: parameterGroupName)))"}
}

extension CreateParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }
}

public struct CreateParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParameterGroupOutputError>
}

public struct CreateParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParameterGroupOutputError>
}

public struct CreateParameterGroupInput: Swift.Equatable {
    /// <p>A description of the parameter group.</p>
    public let description: Swift.String?
    /// <p>The name of the parameter group to apply to all of the clusters in this replication
    ///             group.</p>
    public let parameterGroupName: Swift.String?

    public init (
        description: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil
    )
    {
        self.description = description
        self.parameterGroupName = parameterGroupName
    }
}

struct CreateParameterGroupInputBody: Swift.Equatable {
    public let parameterGroupName: Swift.String?
    public let description: Swift.String?
}

extension CreateParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case parameterGroupName = "ParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupAlreadyExistsFault" : self = .parameterGroupAlreadyExistsFault(try ParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupQuotaExceededFault" : self = .parameterGroupQuotaExceededFault(try ParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupAlreadyExistsFault(ParameterGroupAlreadyExistsFault)
    case parameterGroupQuotaExceededFault(ParameterGroupQuotaExceededFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateParameterGroupOutputResponse(parameterGroup: \(Swift.String(describing: parameterGroup)))"}
}

extension CreateParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.parameterGroup = output.parameterGroup
        } else {
            self.parameterGroup = nil
        }
    }
}

public struct CreateParameterGroupOutputResponse: Swift.Equatable {
    /// <p>Represents the output of a <i>CreateParameterGroup</i>
    ///             action.</p>
    public let parameterGroup: DaxClientTypes.ParameterGroup?

    public init (
        parameterGroup: DaxClientTypes.ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

struct CreateParameterGroupOutputResponseBody: Swift.Equatable {
    public let parameterGroup: DaxClientTypes.ParameterGroup?
}

extension CreateParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroup = "ParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupDecoded = try containerValues.decodeIfPresent(DaxClientTypes.ParameterGroup.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
    }
}

public struct CreateSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSubnetGroupOutputError>
}

extension CreateSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubnetGroupInput(description: \(Swift.String(describing: description)), subnetGroupName: \(Swift.String(describing: subnetGroupName)), subnetIds: \(Swift.String(describing: subnetIds)))"}
}

extension CreateSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let subnetGroupName = subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidentifierlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidentifierlist0)
            }
        }
    }
}

public struct CreateSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSubnetGroupOutputError>
}

public struct CreateSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSubnetGroupOutputError>
}

public struct CreateSubnetGroupInput: Swift.Equatable {
    /// <p>A description for the subnet group</p>
    public let description: Swift.String?
    /// <p>A name for the subnet group. This value is stored as a lowercase string. </p>
    public let subnetGroupName: Swift.String?
    /// <p>A list of VPC subnet IDs for the subnet group.</p>
    public let subnetIds: [Swift.String]?

    public init (
        description: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.description = description
        self.subnetGroupName = subnetGroupName
        self.subnetIds = subnetIds
    }
}

struct CreateSubnetGroupInputBody: Swift.Equatable {
    public let subnetGroupName: Swift.String?
    public let description: Swift.String?
    public let subnetIds: [Swift.String]?
}

extension CreateSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension CreateSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupAlreadyExistsFault" : self = .subnetGroupAlreadyExistsFault(try SubnetGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupQuotaExceededFault" : self = .subnetGroupQuotaExceededFault(try SubnetGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetQuotaExceededFault" : self = .subnetQuotaExceededFault(try SubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidSubnet(InvalidSubnet)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupAlreadyExistsFault(SubnetGroupAlreadyExistsFault)
    case subnetGroupQuotaExceededFault(SubnetGroupQuotaExceededFault)
    case subnetQuotaExceededFault(SubnetQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSubnetGroupOutputResponse(subnetGroup: \(Swift.String(describing: subnetGroup)))"}
}

extension CreateSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subnetGroup = output.subnetGroup
        } else {
            self.subnetGroup = nil
        }
    }
}

public struct CreateSubnetGroupOutputResponse: Swift.Equatable {
    /// <p>Represents the output of a <i>CreateSubnetGroup</i>
    ///             operation.</p>
    public let subnetGroup: DaxClientTypes.SubnetGroup?

    public init (
        subnetGroup: DaxClientTypes.SubnetGroup? = nil
    )
    {
        self.subnetGroup = subnetGroup
    }
}

struct CreateSubnetGroupOutputResponseBody: Swift.Equatable {
    public let subnetGroup: DaxClientTypes.SubnetGroup?
}

extension CreateSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroup = "SubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupDecoded = try containerValues.decodeIfPresent(DaxClientTypes.SubnetGroup.self, forKey: .subnetGroup)
        subnetGroup = subnetGroupDecoded
    }
}

public struct DecreaseReplicationFactorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecreaseReplicationFactorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DecreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DecreaseReplicationFactorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecreaseReplicationFactorOutputError>
}

extension DecreaseReplicationFactorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecreaseReplicationFactorInput(availabilityZones: \(Swift.String(describing: availabilityZones)), clusterName: \(Swift.String(describing: clusterName)), newReplicationFactor: \(Swift.String(describing: newReplicationFactor)), nodeIdsToRemove: \(Swift.String(describing: nodeIdsToRemove)))"}
}

extension DecreaseReplicationFactorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
        case nodeIdsToRemove = "NodeIdsToRemove"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzonelist0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzonelist0)
            }
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if newReplicationFactor != 0 {
            try encodeContainer.encode(newReplicationFactor, forKey: .newReplicationFactor)
        }
        if let nodeIdsToRemove = nodeIdsToRemove {
            var nodeIdsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeIdsToRemove)
            for nodeidentifierlist0 in nodeIdsToRemove {
                try nodeIdsToRemoveContainer.encode(nodeidentifierlist0)
            }
        }
    }
}

public struct DecreaseReplicationFactorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecreaseReplicationFactorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DecreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DecreaseReplicationFactorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecreaseReplicationFactorOutputError>
}

public struct DecreaseReplicationFactorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecreaseReplicationFactorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DecreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DecreaseReplicationFactorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DecreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecreaseReplicationFactorOutputError>
}

public struct DecreaseReplicationFactorInput: Swift.Equatable {
    /// <p>The Availability Zone(s) from which to remove nodes.</p>
    public let availabilityZones: [Swift.String]?
    /// <p>The name of the DAX cluster from which you want to remove nodes.</p>
    public let clusterName: Swift.String?
    /// <p>The new number of nodes for the DAX cluster.</p>
    public let newReplicationFactor: Swift.Int
    /// <p>The unique identifiers of the nodes to be removed from the cluster.</p>
    public let nodeIdsToRemove: [Swift.String]?

    public init (
        availabilityZones: [Swift.String]? = nil,
        clusterName: Swift.String? = nil,
        newReplicationFactor: Swift.Int = 0,
        nodeIdsToRemove: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.clusterName = clusterName
        self.newReplicationFactor = newReplicationFactor
        self.nodeIdsToRemove = nodeIdsToRemove
    }
}

struct DecreaseReplicationFactorInputBody: Swift.Equatable {
    public let clusterName: Swift.String?
    public let newReplicationFactor: Swift.Int
    public let availabilityZones: [Swift.String]?
    public let nodeIdsToRemove: [Swift.String]?
}

extension DecreaseReplicationFactorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
        case nodeIdsToRemove = "NodeIdsToRemove"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let newReplicationFactorDecoded = try containerValues.decode(Swift.Int.self, forKey: .newReplicationFactor)
        newReplicationFactor = newReplicationFactorDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let nodeIdsToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodeIdsToRemove)
        var nodeIdsToRemoveDecoded0:[Swift.String]? = nil
        if let nodeIdsToRemoveContainer = nodeIdsToRemoveContainer {
            nodeIdsToRemoveDecoded0 = [Swift.String]()
            for string0 in nodeIdsToRemoveContainer {
                if let string0 = string0 {
                    nodeIdsToRemoveDecoded0?.append(string0)
                }
            }
        }
        nodeIdsToRemove = nodeIdsToRemoveDecoded0
    }
}

extension DecreaseReplicationFactorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DecreaseReplicationFactorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeNotFoundFault" : self = .nodeNotFoundFault(try NodeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DecreaseReplicationFactorOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case nodeNotFoundFault(NodeNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DecreaseReplicationFactorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecreaseReplicationFactorOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension DecreaseReplicationFactorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DecreaseReplicationFactorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DecreaseReplicationFactorOutputResponse: Swift.Equatable {
    /// <p>A description of the DAX cluster, after you have decreased its replication
    ///             factor.</p>
    public let cluster: DaxClientTypes.Cluster?

    public init (
        cluster: DaxClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DecreaseReplicationFactorOutputResponseBody: Swift.Equatable {
    public let cluster: DaxClientTypes.Cluster?
}

extension DecreaseReplicationFactorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct DeleteClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterOutputError>
}

extension DeleteClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterInput(clusterName: \(Swift.String(describing: clusterName)))"}
}

extension DeleteClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
    }
}

public struct DeleteClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInput: Swift.Equatable {
    /// <p>The name of the cluster to be deleted.</p>
    public let clusterName: Swift.String?

    public init (
        clusterName: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
    }
}

struct DeleteClusterInputBody: Swift.Equatable {
    public let clusterName: Swift.String?
}

extension DeleteClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
    }
}

extension DeleteClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension DeleteClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DeleteClusterOutputResponse: Swift.Equatable {
    /// <p>A description of the DAX cluster that is being deleted.</p>
    public let cluster: DaxClientTypes.Cluster?

    public init (
        cluster: DaxClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DeleteClusterOutputResponseBody: Swift.Equatable {
    public let cluster: DaxClientTypes.Cluster?
}

extension DeleteClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct DeleteParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParameterGroupOutputError>
}

extension DeleteParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteParameterGroupInput(parameterGroupName: \(Swift.String(describing: parameterGroupName)))"}
}

extension DeleteParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }
}

public struct DeleteParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParameterGroupOutputError>
}

public struct DeleteParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParameterGroupOutputError>
}

public struct DeleteParameterGroupInput: Swift.Equatable {
    /// <p>The name of the parameter group to delete.</p>
    public let parameterGroupName: Swift.String?

    public init (
        parameterGroupName: Swift.String? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
    }
}

struct DeleteParameterGroupInputBody: Swift.Equatable {
    public let parameterGroupName: Swift.String?
}

extension DeleteParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
    }
}

extension DeleteParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteParameterGroupOutputResponse(deletionMessage: \(Swift.String(describing: deletionMessage)))"}
}

extension DeleteParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deletionMessage = output.deletionMessage
        } else {
            self.deletionMessage = nil
        }
    }
}

public struct DeleteParameterGroupOutputResponse: Swift.Equatable {
    /// <p>A user-specified message for this action (i.e., a reason for deleting the parameter
    ///             group).</p>
    public let deletionMessage: Swift.String?

    public init (
        deletionMessage: Swift.String? = nil
    )
    {
        self.deletionMessage = deletionMessage
    }
}

struct DeleteParameterGroupOutputResponseBody: Swift.Equatable {
    public let deletionMessage: Swift.String?
}

extension DeleteParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionMessage = "DeletionMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionMessage)
        deletionMessage = deletionMessageDecoded
    }
}

public struct DeleteSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSubnetGroupOutputError>
}

extension DeleteSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSubnetGroupInput(subnetGroupName: \(Swift.String(describing: subnetGroupName)))"}
}

extension DeleteSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroupName = "SubnetGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetGroupName = subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
    }
}

public struct DeleteSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSubnetGroupOutputError>
}

public struct DeleteSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSubnetGroupOutputError>
}

public struct DeleteSubnetGroupInput: Swift.Equatable {
    /// <p>The name of the subnet group to delete.</p>
    public let subnetGroupName: Swift.String?

    public init (
        subnetGroupName: Swift.String? = nil
    )
    {
        self.subnetGroupName = subnetGroupName
    }
}

struct DeleteSubnetGroupInputBody: Swift.Equatable {
    public let subnetGroupName: Swift.String?
}

extension DeleteSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroupName = "SubnetGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
    }
}

extension DeleteSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupInUseFault" : self = .subnetGroupInUseFault(try SubnetGroupInUseFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupInUseFault(SubnetGroupInUseFault)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSubnetGroupOutputResponse(deletionMessage: \(Swift.String(describing: deletionMessage)))"}
}

extension DeleteSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deletionMessage = output.deletionMessage
        } else {
            self.deletionMessage = nil
        }
    }
}

public struct DeleteSubnetGroupOutputResponse: Swift.Equatable {
    /// <p>A user-specified message for this action (i.e., a reason for deleting the subnet
    ///             group).</p>
    public let deletionMessage: Swift.String?

    public init (
        deletionMessage: Swift.String? = nil
    )
    {
        self.deletionMessage = deletionMessage
    }
}

struct DeleteSubnetGroupOutputResponseBody: Swift.Equatable {
    public let deletionMessage: Swift.String?
}

extension DeleteSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionMessage = "DeletionMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionMessage)
        deletionMessage = deletionMessageDecoded
    }
}

public struct DescribeClustersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClustersOutputError>
}

extension DescribeClustersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClustersInput(clusterNames: \(Swift.String(describing: clusterNames)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeClustersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterNames = "ClusterNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterNames = clusterNames {
            var clusterNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterNames)
            for clusternamelist0 in clusterNames {
                try clusterNamesContainer.encode(clusternamelist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeClustersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClustersOutputError>
}

public struct DescribeClustersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClustersOutputError>
}

public struct DescribeClustersInput: Swift.Equatable {
    /// <p>The names of the DAX clusters being described.</p>
    public let clusterNames: [Swift.String]?
    /// <p>The maximum number of results to include in the response. If more results exist
    ///             than the specified <code>MaxResults</code> value, a token is included in the response so
    ///             that the remaining results can be retrieved.</p>
    ///         <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
    public let maxResults: Swift.Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///             results from this action. If this parameter is specified, the response includes only
    ///             results beyond the token, up to the value specified by
    ///             <code>MaxResults</code>.</p>
    public let nextToken: Swift.String?

    public init (
        clusterNames: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterNames = clusterNames
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeClustersInputBody: Swift.Equatable {
    public let clusterNames: [Swift.String]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeClustersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterNames = "ClusterNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clusterNames)
        var clusterNamesDecoded0:[Swift.String]? = nil
        if let clusterNamesContainer = clusterNamesContainer {
            clusterNamesDecoded0 = [Swift.String]()
            for string0 in clusterNamesContainer {
                if let string0 = string0 {
                    clusterNamesDecoded0?.append(string0)
                }
            }
        }
        clusterNames = clusterNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeClustersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClustersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClustersOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClustersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClustersOutputResponse(clusters: \(Swift.String(describing: clusters)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusters = output.clusters
            self.nextToken = output.nextToken
        } else {
            self.clusters = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeClustersOutputResponse: Swift.Equatable {
    /// <p>The descriptions of your DAX clusters, in response to a
    ///             <i>DescribeClusters</i> request.</p>
    public let clusters: [DaxClientTypes.Cluster]?
    /// <p>Provides an identifier to allow retrieval of paginated results.</p>
    public let nextToken: Swift.String?

    public init (
        clusters: [DaxClientTypes.Cluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusters = clusters
        self.nextToken = nextToken
    }
}

struct DescribeClustersOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let clusters: [DaxClientTypes.Cluster]?
}

extension DescribeClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusters = "Clusters"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let clustersContainer = try containerValues.decodeIfPresent([DaxClientTypes.Cluster?].self, forKey: .clusters)
        var clustersDecoded0:[DaxClientTypes.Cluster]? = nil
        if let clustersContainer = clustersContainer {
            clustersDecoded0 = [DaxClientTypes.Cluster]()
            for structure0 in clustersContainer {
                if let structure0 = structure0 {
                    clustersDecoded0?.append(structure0)
                }
            }
        }
        clusters = clustersDecoded0
    }
}

public struct DescribeDefaultParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDefaultParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDefaultParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDefaultParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDefaultParametersOutputError>
}

extension DescribeDefaultParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDefaultParametersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeDefaultParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeDefaultParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDefaultParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDefaultParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDefaultParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDefaultParametersOutputError>
}

public struct DescribeDefaultParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDefaultParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDefaultParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDefaultParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDefaultParametersOutputError>
}

public struct DescribeDefaultParametersInput: Swift.Equatable {
    /// <p>The maximum number of results to include in the response. If more results exist
    ///             than the specified <code>MaxResults</code> value, a token is included in the response so
    ///             that the remaining results can be retrieved.</p>
    ///         <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
    public let maxResults: Swift.Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///             results from this action. If this parameter is specified, the response includes only
    ///             results beyond the token, up to the value specified by
    ///             <code>MaxResults</code>.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeDefaultParametersInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeDefaultParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDefaultParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDefaultParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDefaultParametersOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDefaultParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDefaultParametersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), parameters: \(Swift.String(describing: parameters)))"}
}

extension DescribeDefaultParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDefaultParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct DescribeDefaultParametersOutputResponse: Swift.Equatable {
    /// <p>Provides an identifier to allow retrieval of paginated results.</p>
    public let nextToken: Swift.String?
    /// <p>A list of parameters.  Each element in the list represents one parameter.</p>
    public let parameters: [DaxClientTypes.Parameter]?

    public init (
        nextToken: Swift.String? = nil,
        parameters: [DaxClientTypes.Parameter]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct DescribeDefaultParametersOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let parameters: [DaxClientTypes.Parameter]?
}

extension DescribeDefaultParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parametersContainer = try containerValues.decodeIfPresent([DaxClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[DaxClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [DaxClientTypes.Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

public struct DescribeEventsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

extension DescribeEventsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventsInput(duration: \(Swift.String(describing: duration)), endTime: \(Swift.String(describing: endTime)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), sourceName: \(Swift.String(describing: sourceName)), sourceType: \(Swift.String(describing: sourceType)), startTime: \(Swift.String(describing: startTime)))"}
}

extension DescribeEventsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sourceName = "SourceName"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sourceName = sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct DescribeEventsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInput: Swift.Equatable {
    /// <p>The number of minutes' worth of events to retrieve.</p>
    public let duration: Swift.Int?
    /// <p>The end of the time interval for which to retrieve events, specified in ISO 8601
    ///             format.</p>
    public let endTime: ClientRuntime.Date?
    /// <p>The maximum number of results to include in the response. If more results exist
    ///             than the specified <code>MaxResults</code> value, a token is included in the response so
    ///             that the remaining results can be retrieved.</p>
    ///         <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
    public let maxResults: Swift.Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///             results from this action. If this parameter is specified, the response includes only
    ///             results beyond the token, up to the value specified by
    ///             <code>MaxResults</code>.</p>
    public let nextToken: Swift.String?
    /// <p>The identifier of the event source for which events will be returned. If not
    ///             specified, then all sources are included in the response.</p>
    public let sourceName: Swift.String?
    /// <p>The event source to retrieve events for. If no value is specified, all events are
    ///             returned.</p>
    public let sourceType: DaxClientTypes.SourceType?
    /// <p>The beginning of the time interval to retrieve events for, specified in ISO 8601
    ///             format.</p>
    public let startTime: ClientRuntime.Date?

    public init (
        duration: Swift.Int? = nil,
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceName: Swift.String? = nil,
        sourceType: DaxClientTypes.SourceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceName = sourceName
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

struct DescribeEventsInputBody: Swift.Equatable {
    public let sourceName: Swift.String?
    public let sourceType: DaxClientTypes.SourceType?
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
    public let duration: Swift.Int?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sourceName = "SourceName"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(DaxClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventsOutputResponse(events: \(Swift.String(describing: events)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventsOutputResponse: Swift.Equatable {
    /// <p>An array of events.  Each element in the array represents one event.</p>
    public let events: [DaxClientTypes.Event]?
    /// <p>Provides an identifier to allow retrieval of paginated results.</p>
    public let nextToken: Swift.String?

    public init (
        events: [DaxClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct DescribeEventsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let events: [DaxClientTypes.Event]?
}

extension DescribeEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let eventsContainer = try containerValues.decodeIfPresent([DaxClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[DaxClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [DaxClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

public struct DescribeParameterGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParameterGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParameterGroupsOutputError>
}

extension DescribeParameterGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeParameterGroupsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), parameterGroupNames: \(Swift.String(describing: parameterGroupNames)))"}
}

extension DescribeParameterGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupNames = "ParameterGroupNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterGroupNames = parameterGroupNames {
            var parameterGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterGroupNames)
            for parametergroupnamelist0 in parameterGroupNames {
                try parameterGroupNamesContainer.encode(parametergroupnamelist0)
            }
        }
    }
}

public struct DescribeParameterGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParameterGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParameterGroupsOutputError>
}

public struct DescribeParameterGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParameterGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParameterGroupsOutputError>
}

public struct DescribeParameterGroupsInput: Swift.Equatable {
    /// <p>The maximum number of results to include in the response. If more results exist
    ///             than the specified <code>MaxResults</code> value, a token is included in the response so
    ///             that the remaining results can be retrieved.</p>
    ///         <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
    public let maxResults: Swift.Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///             results from this action. If this parameter is specified, the response includes only
    ///             results beyond the token, up to the value specified by
    ///             <code>MaxResults</code>.</p>
    public let nextToken: Swift.String?
    /// <p>The names of the parameter groups.</p>
    public let parameterGroupNames: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parameterGroupNames: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterGroupNames = parameterGroupNames
    }
}

struct DescribeParameterGroupsInputBody: Swift.Equatable {
    public let parameterGroupNames: [Swift.String]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeParameterGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupNames = "ParameterGroupNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parameterGroupNames)
        var parameterGroupNamesDecoded0:[Swift.String]? = nil
        if let parameterGroupNamesContainer = parameterGroupNamesContainer {
            parameterGroupNamesDecoded0 = [Swift.String]()
            for string0 in parameterGroupNamesContainer {
                if let string0 = string0 {
                    parameterGroupNamesDecoded0?.append(string0)
                }
            }
        }
        parameterGroupNames = parameterGroupNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeParameterGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeParameterGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeParameterGroupsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeParameterGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeParameterGroupsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), parameterGroups: \(Swift.String(describing: parameterGroups)))"}
}

extension DescribeParameterGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameterGroups = output.parameterGroups
        } else {
            self.nextToken = nil
            self.parameterGroups = nil
        }
    }
}

public struct DescribeParameterGroupsOutputResponse: Swift.Equatable {
    /// <p>Provides an identifier to allow retrieval of paginated results.</p>
    public let nextToken: Swift.String?
    /// <p>An array of parameter groups.  Each element in the array represents one parameter group.</p>
    public let parameterGroups: [DaxClientTypes.ParameterGroup]?

    public init (
        nextToken: Swift.String? = nil,
        parameterGroups: [DaxClientTypes.ParameterGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameterGroups = parameterGroups
    }
}

struct DescribeParameterGroupsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let parameterGroups: [DaxClientTypes.ParameterGroup]?
}

extension DescribeParameterGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameterGroups = "ParameterGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parameterGroupsContainer = try containerValues.decodeIfPresent([DaxClientTypes.ParameterGroup?].self, forKey: .parameterGroups)
        var parameterGroupsDecoded0:[DaxClientTypes.ParameterGroup]? = nil
        if let parameterGroupsContainer = parameterGroupsContainer {
            parameterGroupsDecoded0 = [DaxClientTypes.ParameterGroup]()
            for structure0 in parameterGroupsContainer {
                if let structure0 = structure0 {
                    parameterGroupsDecoded0?.append(structure0)
                }
            }
        }
        parameterGroups = parameterGroupsDecoded0
    }
}

public struct DescribeParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParametersOutputError>
}

extension DescribeParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeParametersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), parameterGroupName: \(Swift.String(describing: parameterGroupName)), source: \(Swift.String(describing: source)))"}
}

extension DescribeParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupName = "ParameterGroupName"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }
}

public struct DescribeParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParametersOutputError>
}

public struct DescribeParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeParametersOutputError>
}

public struct DescribeParametersInput: Swift.Equatable {
    /// <p>The maximum number of results to include in the response. If more results exist
    ///             than the specified <code>MaxResults</code> value, a token is included in the response so
    ///             that the remaining results can be retrieved.</p>
    ///         <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
    public let maxResults: Swift.Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///             results from this action. If this parameter is specified, the response includes only
    ///             results beyond the token, up to the value specified by
    ///             <code>MaxResults</code>.</p>
    public let nextToken: Swift.String?
    /// <p>The name of the parameter group.</p>
    public let parameterGroupName: Swift.String?
    /// <p>How the parameter is defined. For example, <code>system</code> denotes a
    ///             system-defined parameter.</p>
    public let source: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil,
        source: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterGroupName = parameterGroupName
        self.source = source
    }
}

struct DescribeParametersInputBody: Swift.Equatable {
    public let parameterGroupName: Swift.String?
    public let source: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupName = "ParameterGroupName"
        case source = "Source"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeParametersOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeParametersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), parameters: \(Swift.String(describing: parameters)))"}
}

extension DescribeParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct DescribeParametersOutputResponse: Swift.Equatable {
    /// <p>Provides an identifier to allow retrieval of paginated results.</p>
    public let nextToken: Swift.String?
    /// <p>A list of parameters within a parameter group.  Each element in the list represents one parameter.</p>
    public let parameters: [DaxClientTypes.Parameter]?

    public init (
        nextToken: Swift.String? = nil,
        parameters: [DaxClientTypes.Parameter]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct DescribeParametersOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let parameters: [DaxClientTypes.Parameter]?
}

extension DescribeParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parametersContainer = try containerValues.decodeIfPresent([DaxClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[DaxClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [DaxClientTypes.Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

public struct DescribeSubnetGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSubnetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSubnetGroupsOutputError>
}

extension DescribeSubnetGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSubnetGroupsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), subnetGroupNames: \(Swift.String(describing: subnetGroupNames)))"}
}

extension DescribeSubnetGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subnetGroupNames = "SubnetGroupNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let subnetGroupNames = subnetGroupNames {
            var subnetGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetGroupNames)
            for subnetgroupnamelist0 in subnetGroupNames {
                try subnetGroupNamesContainer.encode(subnetgroupnamelist0)
            }
        }
    }
}

public struct DescribeSubnetGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSubnetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSubnetGroupsOutputError>
}

public struct DescribeSubnetGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSubnetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSubnetGroupsOutputError>
}

public struct DescribeSubnetGroupsInput: Swift.Equatable {
    /// <p>The maximum number of results to include in the response. If more results exist
    ///             than the specified <code>MaxResults</code> value, a token is included in the response so
    ///             that the remaining results can be retrieved.</p>
    ///             <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
    public let maxResults: Swift.Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///             results from this action. If this parameter is specified, the response includes only
    ///             results beyond the token, up to the value specified by
    ///             <code>MaxResults</code>.</p>
    public let nextToken: Swift.String?
    /// <p>The name of the subnet group.</p>
    public let subnetGroupNames: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        subnetGroupNames: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subnetGroupNames = subnetGroupNames
    }
}

struct DescribeSubnetGroupsInputBody: Swift.Equatable {
    public let subnetGroupNames: [Swift.String]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeSubnetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subnetGroupNames = "SubnetGroupNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetGroupNames)
        var subnetGroupNamesDecoded0:[Swift.String]? = nil
        if let subnetGroupNamesContainer = subnetGroupNamesContainer {
            subnetGroupNamesDecoded0 = [Swift.String]()
            for string0 in subnetGroupNamesContainer {
                if let string0 = string0 {
                    subnetGroupNamesDecoded0?.append(string0)
                }
            }
        }
        subnetGroupNames = subnetGroupNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSubnetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSubnetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSubnetGroupsOutputError: Swift.Error, Swift.Equatable {
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSubnetGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSubnetGroupsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), subnetGroups: \(Swift.String(describing: subnetGroups)))"}
}

extension DescribeSubnetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSubnetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subnetGroups = output.subnetGroups
        } else {
            self.nextToken = nil
            self.subnetGroups = nil
        }
    }
}

public struct DescribeSubnetGroupsOutputResponse: Swift.Equatable {
    /// <p>Provides an identifier to allow retrieval of paginated results.</p>
    public let nextToken: Swift.String?
    /// <p>An array of subnet groups.  Each element in the array represents a single subnet group.</p>
    public let subnetGroups: [DaxClientTypes.SubnetGroup]?

    public init (
        nextToken: Swift.String? = nil,
        subnetGroups: [DaxClientTypes.SubnetGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.subnetGroups = subnetGroups
    }
}

struct DescribeSubnetGroupsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let subnetGroups: [DaxClientTypes.SubnetGroup]?
}

extension DescribeSubnetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case subnetGroups = "SubnetGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let subnetGroupsContainer = try containerValues.decodeIfPresent([DaxClientTypes.SubnetGroup?].self, forKey: .subnetGroups)
        var subnetGroupsDecoded0:[DaxClientTypes.SubnetGroup]? = nil
        if let subnetGroupsContainer = subnetGroupsContainer {
            subnetGroupsDecoded0 = [DaxClientTypes.SubnetGroup]()
            for structure0 in subnetGroupsContainer {
                if let structure0 = structure0 {
                    subnetGroupsDecoded0?.append(structure0)
                }
            }
        }
        subnetGroups = subnetGroupsDecoded0
    }
}

extension DaxClientTypes.Endpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension DaxClientTypes.Endpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Endpoint(address: \(Swift.String(describing: address)), port: \(Swift.String(describing: port)))"}
}

extension DaxClientTypes {
    /// <p>Represents the information required for client programs to connect to the
    ///             configuration endpoint for a DAX cluster, or to an individual node within the
    ///             cluster.</p>
    public struct Endpoint: Swift.Equatable {
        /// <p>The DNS hostname of the endpoint.</p>
        public let address: Swift.String?
        /// <p>The port number that applications should use to connect to the endpoint.</p>
        public let port: Swift.Int

        public init (
            address: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.address = address
            self.port = port
        }
    }

}

extension DaxClientTypes.Event: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case message = "Message"
        case sourceName = "SourceName"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = date {
            try encodeContainer.encode(date.timeIntervalSince1970, forKey: .date)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let sourceName = sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(DaxClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let dateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .date)
        date = dateDecoded
    }
}

extension DaxClientTypes.Event: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Event(date: \(Swift.String(describing: date)), message: \(Swift.String(describing: message)), sourceName: \(Swift.String(describing: sourceName)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension DaxClientTypes {
    /// <p>Represents a single occurrence of something interesting within the system. Some
    ///             examples of events are creating a DAX cluster, adding or removing a node, or rebooting
    ///             a node.</p>
    public struct Event: Swift.Equatable {
        /// <p>The date and time when the event occurred.</p>
        public let date: ClientRuntime.Date?
        /// <p>A user-defined message associated with the event.</p>
        public let message: Swift.String?
        /// <p>The source of the event. For example, if the event occurred at the node level, the
        ///             source would be the node ID.</p>
        public let sourceName: Swift.String?
        /// <p>Specifies the origin of this event - a cluster, a parameter group, a node ID,
        ///             etc.</p>
        public let sourceType: DaxClientTypes.SourceType?

        public init (
            date: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            sourceName: Swift.String? = nil,
            sourceType: DaxClientTypes.SourceType? = nil
        )
        {
            self.date = date
            self.message = message
            self.sourceName = sourceName
            self.sourceType = sourceType
        }
    }

}

public struct IncreaseReplicationFactorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IncreaseReplicationFactorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<IncreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<IncreaseReplicationFactorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IncreaseReplicationFactorOutputError>
}

extension IncreaseReplicationFactorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncreaseReplicationFactorInput(availabilityZones: \(Swift.String(describing: availabilityZones)), clusterName: \(Swift.String(describing: clusterName)), newReplicationFactor: \(Swift.String(describing: newReplicationFactor)))"}
}

extension IncreaseReplicationFactorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzonelist0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzonelist0)
            }
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if newReplicationFactor != 0 {
            try encodeContainer.encode(newReplicationFactor, forKey: .newReplicationFactor)
        }
    }
}

public struct IncreaseReplicationFactorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IncreaseReplicationFactorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<IncreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<IncreaseReplicationFactorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IncreaseReplicationFactorOutputError>
}

public struct IncreaseReplicationFactorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IncreaseReplicationFactorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<IncreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<IncreaseReplicationFactorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<IncreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IncreaseReplicationFactorOutputError>
}

public struct IncreaseReplicationFactorInput: Swift.Equatable {
    /// <p>The Availability Zones (AZs) in which the cluster nodes will be created. All nodes
    ///             belonging to the cluster are placed in these Availability Zones. Use this parameter if you want
    ///             to distribute the nodes across multiple AZs.</p>
    public let availabilityZones: [Swift.String]?
    /// <p>The name of the DAX cluster that will receive additional nodes.</p>
    public let clusterName: Swift.String?
    /// <p>The new number of nodes for the DAX cluster.</p>
    public let newReplicationFactor: Swift.Int

    public init (
        availabilityZones: [Swift.String]? = nil,
        clusterName: Swift.String? = nil,
        newReplicationFactor: Swift.Int = 0
    )
    {
        self.availabilityZones = availabilityZones
        self.clusterName = clusterName
        self.newReplicationFactor = newReplicationFactor
    }
}

struct IncreaseReplicationFactorInputBody: Swift.Equatable {
    public let clusterName: Swift.String?
    public let newReplicationFactor: Swift.Int
    public let availabilityZones: [Swift.String]?
}

extension IncreaseReplicationFactorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let newReplicationFactorDecoded = try containerValues.decode(Swift.Int.self, forKey: .newReplicationFactor)
        newReplicationFactor = newReplicationFactorDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
    }
}

extension IncreaseReplicationFactorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension IncreaseReplicationFactorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForClusterExceededFault" : self = .nodeQuotaForClusterExceededFault(try NodeQuotaForClusterExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForCustomerExceededFault" : self = .nodeQuotaForCustomerExceededFault(try NodeQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum IncreaseReplicationFactorOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case nodeQuotaForClusterExceededFault(NodeQuotaForClusterExceededFault)
    case nodeQuotaForCustomerExceededFault(NodeQuotaForCustomerExceededFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension IncreaseReplicationFactorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncreaseReplicationFactorOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension IncreaseReplicationFactorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IncreaseReplicationFactorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct IncreaseReplicationFactorOutputResponse: Swift.Equatable {
    /// <p>A description of the DAX cluster. with its new replication factor.</p>
    public let cluster: DaxClientTypes.Cluster?

    public init (
        cluster: DaxClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct IncreaseReplicationFactorOutputResponseBody: Swift.Equatable {
    public let cluster: DaxClientTypes.Cluster?
}

extension IncreaseReplicationFactorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension InsufficientClusterCapacityFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InsufficientClusterCapacityFault(message: \(Swift.String(describing: message)))"}
}

extension InsufficientClusterCapacityFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InsufficientClusterCapacityFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There are not enough system resources to create the cluster you requested (or to
///             resize an already-existing cluster). </p>
public struct InsufficientClusterCapacityFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientClusterCapacityFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InsufficientClusterCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidARNFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidARNFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidARNFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidARNFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon Resource Name (ARN) supplied in the request is not valid.</p>
public struct InvalidARNFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidARNFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidARNFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidClusterStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidClusterStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidClusterStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested DAX cluster is not in the <i>available</i>
///             state.</p>
public struct InvalidClusterStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidClusterStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterCombinationException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterCombinationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Two or more incompatible parameters were specified.</p>
public struct InvalidParameterCombinationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterGroupStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterGroupStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterGroupStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterGroupStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameters in a parameter group are in an invalid state.</p>
public struct InvalidParameterGroupStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterGroupStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterValueException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value for a parameter is invalid.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSubnet(message: \(Swift.String(describing: message)))"}
}

extension InvalidSubnet: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidSubnetBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An invalid subnet identifier was specified.</p>
public struct InvalidSubnet: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidSubnetBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVPCNetworkStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidVPCNetworkStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidVPCNetworkStateFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidVPCNetworkStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The VPC network is in an invalid state.</p>
public struct InvalidVPCNetworkStateFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidVPCNetworkStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidVPCNetworkStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DaxClientTypes {
    public enum IsModifiable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conditional
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [IsModifiable] {
            return [
                .conditional,
                .false,
                .true,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conditional: return "CONDITIONAL"
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IsModifiable(rawValue: rawValue) ?? IsModifiable.sdkUnknown(rawValue)
        }
    }
}

public struct ListTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

extension ListTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsInput(nextToken: \(Swift.String(describing: nextToken)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension ListTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct ListTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInput: Swift.Equatable {
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///             results from this action. If this parameter is specified, the response includes only
    ///             results beyond the token.</p>
    public let nextToken: Swift.String?
    /// <p>The name of the DAX resource to which the tags belong.</p>
    public let resourceName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceName = resourceName
    }
}

struct ListTagsInputBody: Swift.Equatable {
    public let resourceName: Swift.String?
    public let nextToken: Swift.String?
}

extension ListTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidARNFault" : self = .invalidARNFault(try InvalidARNFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidARNFault(InvalidARNFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Swift.Equatable {
    /// <p>If this value is present, there are additional results to be displayed.  To retrieve them, call
    ///             <code>ListTags</code> again, with <code>NextToken</code> set to this value.</p>
    public let nextToken: Swift.String?
    /// <p>A list of tags currently associated with the DAX cluster.</p>
    public let tags: [DaxClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [DaxClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Swift.Equatable {
    public let tags: [DaxClientTypes.Tag]?
    public let nextToken: Swift.String?
}

extension ListTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([DaxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DaxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DaxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DaxClientTypes.Node: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case endpoint = "Endpoint"
        case nodeCreateTime = "NodeCreateTime"
        case nodeId = "NodeId"
        case nodeStatus = "NodeStatus"
        case parameterGroupStatus = "ParameterGroupStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let nodeCreateTime = nodeCreateTime {
            try encodeContainer.encode(nodeCreateTime.timeIntervalSince1970, forKey: .nodeCreateTime)
        }
        if let nodeId = nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
        if let nodeStatus = nodeStatus {
            try encodeContainer.encode(nodeStatus, forKey: .nodeStatus)
        }
        if let parameterGroupStatus = parameterGroupStatus {
            try encodeContainer.encode(parameterGroupStatus, forKey: .parameterGroupStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let nodeCreateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .nodeCreateTime)
        nodeCreateTime = nodeCreateTimeDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let nodeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeStatus)
        nodeStatus = nodeStatusDecoded
        let parameterGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupStatus)
        parameterGroupStatus = parameterGroupStatusDecoded
    }
}

extension DaxClientTypes.Node: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Node(availabilityZone: \(Swift.String(describing: availabilityZone)), endpoint: \(Swift.String(describing: endpoint)), nodeCreateTime: \(Swift.String(describing: nodeCreateTime)), nodeId: \(Swift.String(describing: nodeId)), nodeStatus: \(Swift.String(describing: nodeStatus)), parameterGroupStatus: \(Swift.String(describing: parameterGroupStatus)))"}
}

extension DaxClientTypes {
    /// <p>Represents an individual node within a DAX cluster.</p>
    public struct Node: Swift.Equatable {
        /// <p>The Availability Zone (AZ) in which the node has been deployed.</p>
        public let availabilityZone: Swift.String?
        /// <p>The endpoint for the node, consisting of a DNS name and a port number. Client
        ///             applications can connect directly to a node endpoint, if desired (as an alternative to
        ///             allowing DAX client software to intelligently route requests and responses to nodes in
        ///             the DAX cluster.</p>
        public let endpoint: DaxClientTypes.Endpoint?
        /// <p>The date and time (in UNIX epoch format) when the node was launched.</p>
        public let nodeCreateTime: ClientRuntime.Date?
        /// <p>A system-generated identifier for the node.</p>
        public let nodeId: Swift.String?
        /// <p>The current status of the node. For example: <code>available</code>.</p>
        public let nodeStatus: Swift.String?
        /// <p>The status of the parameter group associated with this node. For example,
        ///                 <code>in-sync</code>.</p>
        public let parameterGroupStatus: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            endpoint: DaxClientTypes.Endpoint? = nil,
            nodeCreateTime: ClientRuntime.Date? = nil,
            nodeId: Swift.String? = nil,
            nodeStatus: Swift.String? = nil,
            parameterGroupStatus: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.endpoint = endpoint
            self.nodeCreateTime = nodeCreateTime
            self.nodeId = nodeId
            self.nodeStatus = nodeStatus
            self.parameterGroupStatus = parameterGroupStatus
        }
    }

}

extension NodeNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NodeNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension NodeNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NodeNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>None of the nodes in the cluster have the given node ID.</p>
public struct NodeNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NodeNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NodeNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NodeQuotaForClusterExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NodeQuotaForClusterExceededFault(message: \(Swift.String(describing: message)))"}
}

extension NodeQuotaForClusterExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NodeQuotaForClusterExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have attempted to exceed the maximum number of nodes for a DAX
///             cluster.</p>
public struct NodeQuotaForClusterExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NodeQuotaForClusterExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NodeQuotaForClusterExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NodeQuotaForCustomerExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NodeQuotaForCustomerExceededFault(message: \(Swift.String(describing: message)))"}
}

extension NodeQuotaForCustomerExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NodeQuotaForCustomerExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have attempted to exceed the maximum number of nodes for your AWS
///             account.</p>
public struct NodeQuotaForCustomerExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NodeQuotaForCustomerExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NodeQuotaForCustomerExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DaxClientTypes.NodeTypeSpecificValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeType = "NodeType"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DaxClientTypes.NodeTypeSpecificValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NodeTypeSpecificValue(nodeType: \(Swift.String(describing: nodeType)), value: \(Swift.String(describing: value)))"}
}

extension DaxClientTypes {
    /// <p>Represents a parameter value that is applicable to a particular node
    ///             type.</p>
    public struct NodeTypeSpecificValue: Swift.Equatable {
        /// <p>A node type to which the parameter value applies.</p>
        public let nodeType: Swift.String?
        /// <p>The parameter value for this node type.</p>
        public let value: Swift.String?

        public init (
            nodeType: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.nodeType = nodeType
            self.value = value
        }
    }

}

extension DaxClientTypes.NotificationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
        case topicStatus = "TopicStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
        if let topicStatus = topicStatus {
            try encodeContainer.encode(topicStatus, forKey: .topicStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let topicStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicStatus)
        topicStatus = topicStatusDecoded
    }
}

extension DaxClientTypes.NotificationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationConfiguration(topicArn: \(Swift.String(describing: topicArn)), topicStatus: \(Swift.String(describing: topicStatus)))"}
}

extension DaxClientTypes {
    /// <p>Describes a notification topic and its status. Notification topics are used for
    ///             publishing DAX events to subscribers using Amazon Simple Notification Service
    ///             (SNS).</p>
    public struct NotificationConfiguration: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) that identifies the topic. </p>
        public let topicArn: Swift.String?
        /// <p>The current state of the topic.</p>
        public let topicStatus: Swift.String?

        public init (
            topicArn: Swift.String? = nil,
            topicStatus: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
            self.topicStatus = topicStatus
        }
    }

}

extension DaxClientTypes.Parameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues = "AllowedValues"
        case changeType = "ChangeType"
        case dataType = "DataType"
        case description = "Description"
        case isModifiable = "IsModifiable"
        case nodeTypeSpecificValues = "NodeTypeSpecificValues"
        case parameterName = "ParameterName"
        case parameterType = "ParameterType"
        case parameterValue = "ParameterValue"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            try encodeContainer.encode(allowedValues, forKey: .allowedValues)
        }
        if let changeType = changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let isModifiable = isModifiable {
            try encodeContainer.encode(isModifiable.rawValue, forKey: .isModifiable)
        }
        if let nodeTypeSpecificValues = nodeTypeSpecificValues {
            var nodeTypeSpecificValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeTypeSpecificValues)
            for nodetypespecificvaluelist0 in nodeTypeSpecificValues {
                try nodeTypeSpecificValuesContainer.encode(nodetypespecificvaluelist0)
            }
        }
        if let parameterName = parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterType = parameterType {
            try encodeContainer.encode(parameterType.rawValue, forKey: .parameterType)
        }
        if let parameterValue = parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterTypeDecoded = try containerValues.decodeIfPresent(DaxClientTypes.ParameterType.self, forKey: .parameterType)
        parameterType = parameterTypeDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
        let nodeTypeSpecificValuesContainer = try containerValues.decodeIfPresent([DaxClientTypes.NodeTypeSpecificValue?].self, forKey: .nodeTypeSpecificValues)
        var nodeTypeSpecificValuesDecoded0:[DaxClientTypes.NodeTypeSpecificValue]? = nil
        if let nodeTypeSpecificValuesContainer = nodeTypeSpecificValuesContainer {
            nodeTypeSpecificValuesDecoded0 = [DaxClientTypes.NodeTypeSpecificValue]()
            for structure0 in nodeTypeSpecificValuesContainer {
                if let structure0 = structure0 {
                    nodeTypeSpecificValuesDecoded0?.append(structure0)
                }
            }
        }
        nodeTypeSpecificValues = nodeTypeSpecificValuesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let isModifiableDecoded = try containerValues.decodeIfPresent(DaxClientTypes.IsModifiable.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(DaxClientTypes.ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
    }
}

extension DaxClientTypes.Parameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Parameter(allowedValues: \(Swift.String(describing: allowedValues)), changeType: \(Swift.String(describing: changeType)), dataType: \(Swift.String(describing: dataType)), description: \(Swift.String(describing: description)), isModifiable: \(Swift.String(describing: isModifiable)), nodeTypeSpecificValues: \(Swift.String(describing: nodeTypeSpecificValues)), parameterName: \(Swift.String(describing: parameterName)), parameterType: \(Swift.String(describing: parameterType)), parameterValue: \(Swift.String(describing: parameterValue)), source: \(Swift.String(describing: source)))"}
}

extension DaxClientTypes {
    /// <p>Describes an individual setting that controls some aspect of DAX
    ///             behavior.</p>
    public struct Parameter: Swift.Equatable {
        /// <p>A range of values within which the parameter can be set.</p>
        public let allowedValues: Swift.String?
        /// <p>The conditions under which changes to this parameter can be applied. For example,
        ///                 <code>requires-reboot</code> indicates that a new value for this parameter will only
        ///             take effect if a node is rebooted.</p>
        public let changeType: DaxClientTypes.ChangeType?
        /// <p>The data type of the parameter. For example, <code>integer</code>:</p>
        public let dataType: Swift.String?
        /// <p>A description of the parameter</p>
        public let description: Swift.String?
        /// <p>Whether the customer is allowed to modify the parameter.</p>
        public let isModifiable: DaxClientTypes.IsModifiable?
        /// <p>A list of node types, and specific parameter values for each node.</p>
        public let nodeTypeSpecificValues: [DaxClientTypes.NodeTypeSpecificValue]?
        /// <p>The name of the parameter.</p>
        public let parameterName: Swift.String?
        /// <p>Determines whether the parameter can be applied to any nodes, or only nodes of a
        ///             particular type.</p>
        public let parameterType: DaxClientTypes.ParameterType?
        /// <p>The value for the parameter.</p>
        public let parameterValue: Swift.String?
        /// <p>How the parameter is defined. For example, <code>system</code> denotes a
        ///             system-defined parameter.</p>
        public let source: Swift.String?

        public init (
            allowedValues: Swift.String? = nil,
            changeType: DaxClientTypes.ChangeType? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            isModifiable: DaxClientTypes.IsModifiable? = nil,
            nodeTypeSpecificValues: [DaxClientTypes.NodeTypeSpecificValue]? = nil,
            parameterName: Swift.String? = nil,
            parameterType: DaxClientTypes.ParameterType? = nil,
            parameterValue: Swift.String? = nil,
            source: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.changeType = changeType
            self.dataType = dataType
            self.description = description
            self.isModifiable = isModifiable
            self.nodeTypeSpecificValues = nodeTypeSpecificValues
            self.parameterName = parameterName
            self.parameterType = parameterType
            self.parameterValue = parameterValue
            self.source = source
        }
    }

}

extension DaxClientTypes.ParameterGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DaxClientTypes.ParameterGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterGroup(description: \(Swift.String(describing: description)), parameterGroupName: \(Swift.String(describing: parameterGroupName)))"}
}

extension DaxClientTypes {
    /// <p>A named set of parameters that are applied to all of the nodes in a DAX
    ///             cluster.</p>
    public struct ParameterGroup: Swift.Equatable {
        /// <p>A description of the parameter group.</p>
        public let description: Swift.String?
        /// <p>The name of the parameter group.</p>
        public let parameterGroupName: Swift.String?

        public init (
            description: Swift.String? = nil,
            parameterGroupName: Swift.String? = nil
        )
        {
            self.description = description
            self.parameterGroupName = parameterGroupName
        }
    }

}

extension ParameterGroupAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterGroupAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension ParameterGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterGroupAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified parameter group already exists.</p>
public struct ParameterGroupAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterGroupAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ParameterGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ParameterGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterGroupNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified parameter group does not exist.</p>
public struct ParameterGroupNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ParameterGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterGroupQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterGroupQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension ParameterGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ParameterGroupQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have attempted to exceed the maximum number of parameter groups.</p>
public struct ParameterGroupQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterGroupQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ParameterGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DaxClientTypes.ParameterGroupStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeIdsToReboot = "NodeIdsToReboot"
        case parameterApplyStatus = "ParameterApplyStatus"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeIdsToReboot = nodeIdsToReboot {
            var nodeIdsToRebootContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeIdsToReboot)
            for nodeidentifierlist0 in nodeIdsToReboot {
                try nodeIdsToRebootContainer.encode(nodeidentifierlist0)
            }
        }
        if let parameterApplyStatus = parameterApplyStatus {
            try encodeContainer.encode(parameterApplyStatus, forKey: .parameterApplyStatus)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
        let nodeIdsToRebootContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodeIdsToReboot)
        var nodeIdsToRebootDecoded0:[Swift.String]? = nil
        if let nodeIdsToRebootContainer = nodeIdsToRebootContainer {
            nodeIdsToRebootDecoded0 = [Swift.String]()
            for string0 in nodeIdsToRebootContainer {
                if let string0 = string0 {
                    nodeIdsToRebootDecoded0?.append(string0)
                }
            }
        }
        nodeIdsToReboot = nodeIdsToRebootDecoded0
    }
}

extension DaxClientTypes.ParameterGroupStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterGroupStatus(nodeIdsToReboot: \(Swift.String(describing: nodeIdsToReboot)), parameterApplyStatus: \(Swift.String(describing: parameterApplyStatus)), parameterGroupName: \(Swift.String(describing: parameterGroupName)))"}
}

extension DaxClientTypes {
    /// <p>The status of a parameter group.</p>
    public struct ParameterGroupStatus: Swift.Equatable {
        /// <p>The node IDs of one or more nodes to be rebooted.</p>
        public let nodeIdsToReboot: [Swift.String]?
        /// <p>The status of parameter updates. </p>
        public let parameterApplyStatus: Swift.String?
        /// <p>The name of the parameter group.</p>
        public let parameterGroupName: Swift.String?

        public init (
            nodeIdsToReboot: [Swift.String]? = nil,
            parameterApplyStatus: Swift.String? = nil,
            parameterGroupName: Swift.String? = nil
        )
        {
            self.nodeIdsToReboot = nodeIdsToReboot
            self.parameterApplyStatus = parameterApplyStatus
            self.parameterGroupName = parameterGroupName
        }
    }

}

extension DaxClientTypes.ParameterNameValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterName = parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterValue = parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
    }
}

extension DaxClientTypes.ParameterNameValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterNameValue(parameterName: \(Swift.String(describing: parameterName)), parameterValue: \(Swift.String(describing: parameterValue)))"}
}

extension DaxClientTypes {
    /// <p>An individual DAX parameter.</p>
    public struct ParameterNameValue: Swift.Equatable {
        /// <p>The name of the parameter.</p>
        public let parameterName: Swift.String?
        /// <p>The value of the parameter.</p>
        public let parameterValue: Swift.String?

        public init (
            parameterName: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }
    }

}

extension DaxClientTypes {
    public enum ParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case nodeTypeSpecific
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterType] {
            return [
                .default,
                .nodeTypeSpecific,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .nodeTypeSpecific: return "NODE_TYPE_SPECIFIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParameterType(rawValue: rawValue) ?? ParameterType.sdkUnknown(rawValue)
        }
    }
}

public struct RebootNodeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootNodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootNodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootNodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootNodeOutputError>
}

extension RebootNodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootNodeInput(clusterName: \(Swift.String(describing: clusterName)), nodeId: \(Swift.String(describing: nodeId)))"}
}

extension RebootNodeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case nodeId = "NodeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let nodeId = nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
    }
}

public struct RebootNodeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootNodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootNodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootNodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootNodeOutputError>
}

public struct RebootNodeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootNodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootNodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootNodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootNodeOutputError>
}

public struct RebootNodeInput: Swift.Equatable {
    /// <p>The name of the DAX cluster containing the node to be rebooted.</p>
    public let clusterName: Swift.String?
    /// <p>The system-assigned ID of the node to be rebooted.</p>
    public let nodeId: Swift.String?

    public init (
        clusterName: Swift.String? = nil,
        nodeId: Swift.String? = nil
    )
    {
        self.clusterName = clusterName
        self.nodeId = nodeId
    }
}

struct RebootNodeInputBody: Swift.Equatable {
    public let clusterName: Swift.String?
    public let nodeId: Swift.String?
}

extension RebootNodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case nodeId = "NodeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
    }
}

extension RebootNodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootNodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeNotFoundFault" : self = .nodeNotFoundFault(try NodeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootNodeOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case nodeNotFoundFault(NodeNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootNodeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootNodeOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension RebootNodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RebootNodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct RebootNodeOutputResponse: Swift.Equatable {
    /// <p>A description of the DAX cluster after a node has been rebooted.</p>
    public let cluster: DaxClientTypes.Cluster?

    public init (
        cluster: DaxClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct RebootNodeOutputResponseBody: Swift.Equatable {
    public let cluster: DaxClientTypes.Cluster?
}

extension RebootNodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension DaxClientTypes.SSEDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DaxClientTypes.SSEStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DaxClientTypes.SSEDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SSEDescription(status: \(Swift.String(describing: status)))"}
}

extension DaxClientTypes {
    /// <p>The description of the server-side encryption status on the specified DAX cluster.</p>
    public struct SSEDescription: Swift.Equatable {
        /// <p>The current state of server-side encryption:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>ENABLING</code> - Server-side encryption is being enabled.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>ENABLED</code> - Server-side encryption is enabled.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>DISABLING</code> - Server-side encryption is being disabled.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>DISABLED</code> - Server-side encryption is disabled.</p>
        ///             </li>
        ///          </ul>
        public let status: DaxClientTypes.SSEStatus?

        public init (
            status: DaxClientTypes.SSEStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension DaxClientTypes.SSESpecification: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension DaxClientTypes.SSESpecification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SSESpecification(enabled: \(Swift.String(describing: enabled)))"}
}

extension DaxClientTypes {
    /// <p>Represents the settings used to enable server-side encryption.</p>
    public struct SSESpecification: Swift.Equatable {
        /// <p>Indicates whether server-side encryption is enabled (true) or disabled (false) on the cluster.</p>
        public let enabled: Swift.Bool?

        public init (
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension DaxClientTypes {
    public enum SSEStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case sdkUnknown(Swift.String)

        public static var allCases: [SSEStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SSEStatus(rawValue: rawValue) ?? SSEStatus.sdkUnknown(rawValue)
        }
    }
}

extension DaxClientTypes.SecurityGroupMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIdentifier = "SecurityGroupIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIdentifier = securityGroupIdentifier {
            try encodeContainer.encode(securityGroupIdentifier, forKey: .securityGroupIdentifier)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroupIdentifier)
        securityGroupIdentifier = securityGroupIdentifierDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DaxClientTypes.SecurityGroupMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SecurityGroupMembership(securityGroupIdentifier: \(Swift.String(describing: securityGroupIdentifier)), status: \(Swift.String(describing: status)))"}
}

extension DaxClientTypes {
    /// <p>An individual VPC security group and its status.</p>
    public struct SecurityGroupMembership: Swift.Equatable {
        /// <p>The unique ID for this security group.</p>
        public let securityGroupIdentifier: Swift.String?
        /// <p>The status of this security group.</p>
        public let status: Swift.String?

        public init (
            securityGroupIdentifier: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.securityGroupIdentifier = securityGroupIdentifier
            self.status = status
        }
    }

}

extension ServiceLinkedRoleNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceLinkedRoleNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ServiceLinkedRoleNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceLinkedRoleNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified service linked role (SLR) was not found.</p>
public struct ServiceLinkedRoleNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceLinkedRoleNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceLinkedRoleNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DaxClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cluster
        case parameterGroup
        case subnetGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .cluster,
                .parameterGroup,
                .subnetGroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cluster: return "CLUSTER"
            case .parameterGroup: return "PARAMETER_GROUP"
            case .subnetGroup: return "SUBNET_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension DaxClientTypes.Subnet: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetAvailabilityZone = subnetAvailabilityZone {
            try encodeContainer.encode(subnetAvailabilityZone, forKey: .subnetAvailabilityZone)
        }
        if let subnetIdentifier = subnetIdentifier {
            try encodeContainer.encode(subnetIdentifier, forKey: .subnetIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
    }
}

extension DaxClientTypes.Subnet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Subnet(subnetAvailabilityZone: \(Swift.String(describing: subnetAvailabilityZone)), subnetIdentifier: \(Swift.String(describing: subnetIdentifier)))"}
}

extension DaxClientTypes {
    /// <p>Represents the subnet associated with a DAX cluster. This parameter refers to
    ///             subnets defined in Amazon Virtual Private Cloud (Amazon VPC) and used with
    ///             DAX.</p>
    public struct Subnet: Swift.Equatable {
        /// <p>The Availability Zone (AZ) for the subnet.</p>
        public let subnetAvailabilityZone: Swift.String?
        /// <p>The system-assigned identifier for the subnet.</p>
        public let subnetIdentifier: Swift.String?

        public init (
            subnetAvailabilityZone: Swift.String? = nil,
            subnetIdentifier: Swift.String? = nil
        )
        {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
        }
    }

}

extension DaxClientTypes.SubnetGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let subnetGroupName = subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnetlist0 in subnets {
                try subnetsContainer.encode(subnetlist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([DaxClientTypes.Subnet?].self, forKey: .subnets)
        var subnetsDecoded0:[DaxClientTypes.Subnet]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [DaxClientTypes.Subnet]()
            for structure0 in subnetsContainer {
                if let structure0 = structure0 {
                    subnetsDecoded0?.append(structure0)
                }
            }
        }
        subnets = subnetsDecoded0
    }
}

extension DaxClientTypes.SubnetGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetGroup(description: \(Swift.String(describing: description)), subnetGroupName: \(Swift.String(describing: subnetGroupName)), subnets: \(Swift.String(describing: subnets)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension DaxClientTypes {
    /// <p>Represents the output of one of the following actions:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <i>CreateSubnetGroup</i>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <i>ModifySubnetGroup</i>
    ///                 </p>
    ///             </li>
    ///          </ul>
    public struct SubnetGroup: Swift.Equatable {
        /// <p>The description of the subnet group.</p>
        public let description: Swift.String?
        /// <p>The name of the subnet group.</p>
        public let subnetGroupName: Swift.String?
        /// <p>A list of subnets associated with the subnet group. </p>
        public let subnets: [DaxClientTypes.Subnet]?
        /// <p>The Amazon Virtual Private Cloud identifier (VPC ID) of the subnet group.</p>
        public let vpcId: Swift.String?

        public init (
            description: Swift.String? = nil,
            subnetGroupName: Swift.String? = nil,
            subnets: [DaxClientTypes.Subnet]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.description = description
            self.subnetGroupName = subnetGroupName
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension SubnetGroupAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetGroupAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension SubnetGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetGroupAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified subnet group already exists.</p>
public struct SubnetGroupAlreadyExistsFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetGroupInUseFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetGroupInUseFault(message: \(Swift.String(describing: message)))"}
}

extension SubnetGroupInUseFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetGroupInUseFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified subnet group is currently in use.</p>
public struct SubnetGroupInUseFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupInUseFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetGroupInUseFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SubnetGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetGroupNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested subnet group name does not refer to an existing subnet
///             group.</p>
public struct SubnetGroupNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetGroupQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetGroupQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension SubnetGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetGroupQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request cannot be processed because it would exceed the allowed number of
///             subnets in a subnet group.</p>
public struct SubnetGroupQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetInUse(message: \(Swift.String(describing: message)))"}
}

extension SubnetInUse: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetInUseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested subnet is being used by another subnet group.</p>
public struct SubnetInUse: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension SubnetQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubnetQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request cannot be processed because it would exceed the allowed number of
///             subnets in a subnet group.</p>
public struct SubnetQuotaExceededFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DaxClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DaxClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension DaxClientTypes {
    /// <p>A description of a tag.  Every tag is a key-value pair. You can add up to 50 tags to a single
    ///             DAX cluster.</p>
    ///         <p>AWS-assigned tag names and values are automatically assigned the <code>aws:</code>
    ///             prefix, which the user cannot assign. AWS-assigned tag names do not count towards the
    ///             tag limit of 50. User-assigned tag names have the prefix <code>user:</code>.</p>
    ///         <p>You cannot backdate the application of a tag.</p>
    public struct Tag: Swift.Equatable {
        /// <p>The key for the tag.  Tag keys are case sensitive. Every DAX cluster can only have
        ///             one tag with the same key. If you try to add an existing tag (same key), the
        ///             existing tag value will be updated to the new value.</p>
        public let key: Swift.String?
        /// <p>The value of the tag. Tag values are case-sensitive and can be null. </p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension TagNotFoundFault: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The tag does not exist.</p>
public struct TagNotFoundFault: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TagNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagQuotaPerResourceExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagQuotaPerResourceExceeded(message: \(Swift.String(describing: message)))"}
}

extension TagQuotaPerResourceExceeded: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagQuotaPerResourceExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the maximum number of tags for this DAX cluster.</p>
public struct TagQuotaPerResourceExceeded: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagQuotaPerResourceExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TagQuotaPerResourceExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceName: \(Swift.String(describing: resourceName)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The name of the DAX resource to which tags should be added.</p>
    public let resourceName: Swift.String?
    /// <p>The tags to be assigned to the DAX resource. </p>
    public let tags: [DaxClientTypes.Tag]?

    public init (
        resourceName: Swift.String? = nil,
        tags: [DaxClientTypes.Tag]? = nil
    )
    {
        self.resourceName = resourceName
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceName: Swift.String?
    public let tags: [DaxClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DaxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DaxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DaxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidARNFault" : self = .invalidARNFault(try InvalidARNFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagQuotaPerResourceExceeded" : self = .tagQuotaPerResourceExceeded(try TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidARNFault(InvalidARNFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case tagQuotaPerResourceExceeded(TagQuotaPerResourceExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {
    /// <p>The list of tags that are associated with the DAX resource.</p>
    public let tags: [DaxClientTypes.Tag]?

    public init (
        tags: [DaxClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct TagResourceOutputResponseBody: Swift.Equatable {
    public let tags: [DaxClientTypes.Tag]?
}

extension TagResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([DaxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DaxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DaxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceName: \(Swift.String(describing: resourceName)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for keylist0 in tagKeys {
                try tagKeysContainer.encode(keylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The name of the DAX resource from which the tags should be removed.</p>
    public let resourceName: Swift.String?
    /// <p>A list of tag keys. If the DAX cluster has any tags with these keys, then the tags are removed from the cluster.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceName = resourceName
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceName: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidARNFault" : self = .invalidARNFault(try InvalidARNFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagNotFoundFault" : self = .tagNotFoundFault(try TagNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidARNFault(InvalidARNFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case tagNotFoundFault(TagNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UntagResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {
    /// <p>The tag keys that have been removed from the cluster.</p>
    public let tags: [DaxClientTypes.Tag]?

    public init (
        tags: [DaxClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
    public let tags: [DaxClientTypes.Tag]?
}

extension UntagResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([DaxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DaxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DaxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterOutputError>
}

extension UpdateClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateClusterInput(clusterName: \(Swift.String(describing: clusterName)), description: \(Swift.String(describing: description)), notificationTopicArn: \(Swift.String(describing: notificationTopicArn)), notificationTopicStatus: \(Swift.String(describing: notificationTopicStatus)), parameterGroupName: \(Swift.String(describing: parameterGroupName)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), securityGroupIds: \(Swift.String(describing: securityGroupIds)))"}
}

extension UpdateClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case description = "Description"
        case notificationTopicArn = "NotificationTopicArn"
        case notificationTopicStatus = "NotificationTopicStatus"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let notificationTopicArn = notificationTopicArn {
            try encodeContainer.encode(notificationTopicArn, forKey: .notificationTopicArn)
        }
        if let notificationTopicStatus = notificationTopicStatus {
            try encodeContainer.encode(notificationTopicStatus, forKey: .notificationTopicStatus)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidentifierlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidentifierlist0)
            }
        }
    }
}

public struct UpdateClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterOutputError>
}

public struct UpdateClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterOutputError>
}

public struct UpdateClusterInput: Swift.Equatable {
    /// <p>The name of the DAX cluster to be modified.</p>
    public let clusterName: Swift.String?
    /// <p>A description of the changes being made to the cluster.</p>
    public let description: Swift.String?
    /// <p>The Amazon Resource Name (ARN) that identifies the topic.</p>
    public let notificationTopicArn: Swift.String?
    /// <p>The current state of the topic.</p>
    public let notificationTopicStatus: Swift.String?
    /// <p>The name of a parameter group for this cluster.</p>
    public let parameterGroupName: Swift.String?
    /// <p>A range of time when maintenance of DAX cluster software will be performed. For
    ///             example: <code>sun:01:00-sun:09:00</code>. Cluster maintenance normally takes less than
    ///             30 minutes, and is performed automatically within the maintenance window.</p>
    public let preferredMaintenanceWindow: Swift.String?
    /// <p>A list of user-specified security group IDs to be assigned to each node in the DAX cluster.  If this parameter is not
    ///             specified, DAX assigns the default VPC security group to each node.</p>
    public let securityGroupIds: [Swift.String]?

    public init (
        clusterName: Swift.String? = nil,
        description: Swift.String? = nil,
        notificationTopicArn: Swift.String? = nil,
        notificationTopicStatus: Swift.String? = nil,
        parameterGroupName: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil
    )
    {
        self.clusterName = clusterName
        self.description = description
        self.notificationTopicArn = notificationTopicArn
        self.notificationTopicStatus = notificationTopicStatus
        self.parameterGroupName = parameterGroupName
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.securityGroupIds = securityGroupIds
    }
}

struct UpdateClusterInputBody: Swift.Equatable {
    public let clusterName: Swift.String?
    public let description: Swift.String?
    public let preferredMaintenanceWindow: Swift.String?
    public let notificationTopicArn: Swift.String?
    public let notificationTopicStatus: Swift.String?
    public let parameterGroupName: Swift.String?
    public let securityGroupIds: [Swift.String]?
}

extension UpdateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "ClusterName"
        case description = "Description"
        case notificationTopicArn = "NotificationTopicArn"
        case notificationTopicStatus = "NotificationTopicStatus"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let notificationTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationTopicArn)
        notificationTopicArn = notificationTopicArnDecoded
        let notificationTopicStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationTopicStatus)
        notificationTopicStatus = notificationTopicStatusDecoded
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension UpdateClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateClusterOutputError: Swift.Error, Swift.Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateClusterOutputResponse(cluster: \(Swift.String(describing: cluster)))"}
}

extension UpdateClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct UpdateClusterOutputResponse: Swift.Equatable {
    /// <p>A description of the DAX cluster, after it has been modified.</p>
    public let cluster: DaxClientTypes.Cluster?

    public init (
        cluster: DaxClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct UpdateClusterOutputResponseBody: Swift.Equatable {
    public let cluster: DaxClientTypes.Cluster?
}

extension UpdateClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DaxClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct UpdateParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateParameterGroupOutputError>
}

extension UpdateParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateParameterGroupInput(parameterGroupName: \(Swift.String(describing: parameterGroupName)), parameterNameValues: \(Swift.String(describing: parameterNameValues)))"}
}

extension UpdateParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case parameterNameValues = "ParameterNameValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let parameterNameValues = parameterNameValues {
            var parameterNameValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterNameValues)
            for parameternamevaluelist0 in parameterNameValues {
                try parameterNameValuesContainer.encode(parameternamevaluelist0)
            }
        }
    }
}

public struct UpdateParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateParameterGroupOutputError>
}

public struct UpdateParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateParameterGroupOutputError>
}

public struct UpdateParameterGroupInput: Swift.Equatable {
    /// <p>The name of the parameter group.</p>
    public let parameterGroupName: Swift.String?
    /// <p>An array of name-value pairs for the parameters in the group. Each element in the
    ///             array represents a single parameter.</p>
    public let parameterNameValues: [DaxClientTypes.ParameterNameValue]?

    public init (
        parameterGroupName: Swift.String? = nil,
        parameterNameValues: [DaxClientTypes.ParameterNameValue]? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
        self.parameterNameValues = parameterNameValues
    }
}

struct UpdateParameterGroupInputBody: Swift.Equatable {
    public let parameterGroupName: Swift.String?
    public let parameterNameValues: [DaxClientTypes.ParameterNameValue]?
}

extension UpdateParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case parameterNameValues = "ParameterNameValues"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterNameValuesContainer = try containerValues.decodeIfPresent([DaxClientTypes.ParameterNameValue?].self, forKey: .parameterNameValues)
        var parameterNameValuesDecoded0:[DaxClientTypes.ParameterNameValue]? = nil
        if let parameterNameValuesContainer = parameterNameValuesContainer {
            parameterNameValuesDecoded0 = [DaxClientTypes.ParameterNameValue]()
            for structure0 in parameterNameValuesContainer {
                if let structure0 = structure0 {
                    parameterNameValuesDecoded0?.append(structure0)
                }
            }
        }
        parameterNameValues = parameterNameValuesDecoded0
    }
}

extension UpdateParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateParameterGroupOutputResponse(parameterGroup: \(Swift.String(describing: parameterGroup)))"}
}

extension UpdateParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.parameterGroup = output.parameterGroup
        } else {
            self.parameterGroup = nil
        }
    }
}

public struct UpdateParameterGroupOutputResponse: Swift.Equatable {
    /// <p>The parameter group that has been modified.</p>
    public let parameterGroup: DaxClientTypes.ParameterGroup?

    public init (
        parameterGroup: DaxClientTypes.ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

struct UpdateParameterGroupOutputResponseBody: Swift.Equatable {
    public let parameterGroup: DaxClientTypes.ParameterGroup?
}

extension UpdateParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterGroup = "ParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupDecoded = try containerValues.decodeIfPresent(DaxClientTypes.ParameterGroup.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
    }
}

public struct UpdateSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSubnetGroupOutputError>
}

extension UpdateSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubnetGroupInput(description: \(Swift.String(describing: description)), subnetGroupName: \(Swift.String(describing: subnetGroupName)), subnetIds: \(Swift.String(describing: subnetIds)))"}
}

extension UpdateSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let subnetGroupName = subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidentifierlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidentifierlist0)
            }
        }
    }
}

public struct UpdateSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSubnetGroupOutputError>
}

public struct UpdateSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSubnetGroupOutputError>
}

public struct UpdateSubnetGroupInput: Swift.Equatable {
    /// <p>A description of the subnet group.</p>
    public let description: Swift.String?
    /// <p>The name of the subnet group.</p>
    public let subnetGroupName: Swift.String?
    /// <p>A list of subnet IDs in the subnet group.</p>
    public let subnetIds: [Swift.String]?

    public init (
        description: Swift.String? = nil,
        subnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.description = description
        self.subnetGroupName = subnetGroupName
        self.subnetIds = subnetIds
    }
}

struct UpdateSubnetGroupInputBody: Swift.Equatable {
    public let subnetGroupName: Swift.String?
    public let description: Swift.String?
    public let subnetIds: [Swift.String]?
}

extension UpdateSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension UpdateSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetInUse" : self = .subnetInUse(try SubnetInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetQuotaExceededFault" : self = .subnetQuotaExceededFault(try SubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidSubnet(InvalidSubnet)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case subnetInUse(SubnetInUse)
    case subnetQuotaExceededFault(SubnetQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSubnetGroupOutputResponse(subnetGroup: \(Swift.String(describing: subnetGroup)))"}
}

extension UpdateSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subnetGroup = output.subnetGroup
        } else {
            self.subnetGroup = nil
        }
    }
}

public struct UpdateSubnetGroupOutputResponse: Swift.Equatable {
    /// <p>The subnet group that has been modified.</p>
    public let subnetGroup: DaxClientTypes.SubnetGroup?

    public init (
        subnetGroup: DaxClientTypes.SubnetGroup? = nil
    )
    {
        self.subnetGroup = subnetGroup
    }
}

struct UpdateSubnetGroupOutputResponseBody: Swift.Equatable {
    public let subnetGroup: DaxClientTypes.SubnetGroup?
}

extension UpdateSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetGroup = "SubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupDecoded = try containerValues.decodeIfPresent(DaxClientTypes.SubnetGroup.self, forKey: .subnetGroup)
        subnetGroup = subnetGroupDecoded
    }
}
