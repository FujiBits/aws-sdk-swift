// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension EcrPublicClient {
    /// <p>Checks the availability of one or more image layers within a repository in a public
    ///          registry. When an image is pushed to a repository, each image layer is checked to verify if
    ///          it has been uploaded before. If it has been uploaded, then the image layer is
    ///          skipped.</p>
    ///          <note>
    ///             <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
    ///          </note>
    func batchCheckLayerAvailability(input: BatchCheckLayerAvailabilityInput) async throws -> BatchCheckLayerAvailabilityOutputResponse
    {
        typealias batchCheckLayerAvailabilityContinuation = CheckedContinuation<BatchCheckLayerAvailabilityOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchCheckLayerAvailabilityContinuation) in
            batchCheckLayerAvailability(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a list of specified images within a repository in a public registry. Images are
    ///          specified with either an <code>imageTag</code> or <code>imageDigest</code>.</p>
    ///          <p>You can remove a tag from an image by specifying the image's tag in your request. When
    ///          you remove the last tag from an image, the image is deleted from your repository.</p>
    ///          <p>You can completely delete an image (and all of its tags) by specifying the image's
    ///          digest in your request.</p>
    func batchDeleteImage(input: BatchDeleteImageInput) async throws -> BatchDeleteImageOutputResponse
    {
        typealias batchDeleteImageContinuation = CheckedContinuation<BatchDeleteImageOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: batchDeleteImageContinuation) in
            batchDeleteImage(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Informs Amazon ECR that the image layer upload has completed for a specified public registry,
    ///          repository name, and upload ID. You can optionally provide a <code>sha256</code> digest of
    ///          the image layer for data validation purposes.</p>
    ///          <p>When an image is pushed, the CompleteLayerUpload API is called once per each new image
    ///          layer to verify that the upload has completed.</p>
    ///          <note>
    ///             <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
    ///          </note>
    func completeLayerUpload(input: CompleteLayerUploadInput) async throws -> CompleteLayerUploadOutputResponse
    {
        typealias completeLayerUploadContinuation = CheckedContinuation<CompleteLayerUploadOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: completeLayerUploadContinuation) in
            completeLayerUpload(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a repository in a public registry. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/Repositories.html">Amazon ECR
    ///             repositories</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
    func createRepository(input: CreateRepositoryInput) async throws -> CreateRepositoryOutputResponse
    {
        typealias createRepositoryContinuation = CheckedContinuation<CreateRepositoryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createRepositoryContinuation) in
            createRepository(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a repository in a public registry. If the repository contains images, you must
    ///          either delete all images in the repository or use the <code>force</code> option which
    ///          deletes all images on your behalf before deleting the repository.</p>
    func deleteRepository(input: DeleteRepositoryInput) async throws -> DeleteRepositoryOutputResponse
    {
        typealias deleteRepositoryContinuation = CheckedContinuation<DeleteRepositoryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRepositoryContinuation) in
            deleteRepository(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the repository policy associated with the specified repository.</p>
    func deleteRepositoryPolicy(input: DeleteRepositoryPolicyInput) async throws -> DeleteRepositoryPolicyOutputResponse
    {
        typealias deleteRepositoryPolicyContinuation = CheckedContinuation<DeleteRepositoryPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRepositoryPolicyContinuation) in
            deleteRepositoryPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the image tag details for a repository in a public registry.</p>
    func describeImageTags(input: DescribeImageTagsInput) async throws -> DescribeImageTagsOutputResponse
    {
        typealias describeImageTagsContinuation = CheckedContinuation<DescribeImageTagsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeImageTagsContinuation) in
            describeImageTags(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns metadata about the images in a repository in a public registry.</p>
    ///          <note>
    ///             <p>Beginning with Docker version 1.9, the Docker client compresses image layers before
    ///             pushing them to a V2 Docker registry. The output of the <code>docker images</code>
    ///             command shows the uncompressed image size, so it may return a larger image size than the
    ///             image sizes returned by <a>DescribeImages</a>.</p>
    ///          </note>
    func describeImages(input: DescribeImagesInput) async throws -> DescribeImagesOutputResponse
    {
        typealias describeImagesContinuation = CheckedContinuation<DescribeImagesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeImagesContinuation) in
            describeImages(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns details for a public registry.</p>
    func describeRegistries(input: DescribeRegistriesInput) async throws -> DescribeRegistriesOutputResponse
    {
        typealias describeRegistriesContinuation = CheckedContinuation<DescribeRegistriesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRegistriesContinuation) in
            describeRegistries(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes repositories in a public registry.</p>
    func describeRepositories(input: DescribeRepositoriesInput) async throws -> DescribeRepositoriesOutputResponse
    {
        typealias describeRepositoriesContinuation = CheckedContinuation<DescribeRepositoriesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRepositoriesContinuation) in
            describeRepositories(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves an authorization token. An authorization token represents your IAM
    ///          authentication credentials and can be used to access any Amazon ECR registry that your IAM
    ///          principal has access to. The authorization token is valid for 12 hours. This API requires
    ///          the <code>ecr-public:GetAuthorizationToken</code> and
    ///             <code>sts:GetServiceBearerToken</code> permissions.</p>
    func getAuthorizationToken(input: GetAuthorizationTokenInput) async throws -> GetAuthorizationTokenOutputResponse
    {
        typealias getAuthorizationTokenContinuation = CheckedContinuation<GetAuthorizationTokenOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getAuthorizationTokenContinuation) in
            getAuthorizationToken(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves catalog metadata for a public registry.</p>
    func getRegistryCatalogData(input: GetRegistryCatalogDataInput) async throws -> GetRegistryCatalogDataOutputResponse
    {
        typealias getRegistryCatalogDataContinuation = CheckedContinuation<GetRegistryCatalogDataOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getRegistryCatalogDataContinuation) in
            getRegistryCatalogData(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieve catalog metadata for a repository in a public registry. This metadata is
    ///          displayed publicly in the Amazon ECR Public Gallery.</p>
    func getRepositoryCatalogData(input: GetRepositoryCatalogDataInput) async throws -> GetRepositoryCatalogDataOutputResponse
    {
        typealias getRepositoryCatalogDataContinuation = CheckedContinuation<GetRepositoryCatalogDataOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getRepositoryCatalogDataContinuation) in
            getRepositoryCatalogData(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves the repository policy for the specified repository.</p>
    func getRepositoryPolicy(input: GetRepositoryPolicyInput) async throws -> GetRepositoryPolicyOutputResponse
    {
        typealias getRepositoryPolicyContinuation = CheckedContinuation<GetRepositoryPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getRepositoryPolicyContinuation) in
            getRepositoryPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Notifies Amazon ECR that you intend to upload an image layer.</p>
    ///          <p>When an image is pushed, the InitiateLayerUpload API is called once per image layer that
    ///          has not already been uploaded. Whether or not an image layer has been uploaded is
    ///          determined by the BatchCheckLayerAvailability API action.</p>
    ///          <note>
    ///             <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
    ///          </note>
    func initiateLayerUpload(input: InitiateLayerUploadInput) async throws -> InitiateLayerUploadOutputResponse
    {
        typealias initiateLayerUploadContinuation = CheckedContinuation<InitiateLayerUploadOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: initiateLayerUploadContinuation) in
            initiateLayerUpload(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>List the tags for an Amazon ECR Public resource.</p>
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates or updates the image manifest and tags associated with an image.</p>
    ///          <p>When an image is pushed and all new image layers have been uploaded, the PutImage API is
    ///          called once to create or update the image manifest and the tags associated with the
    ///          image.</p>
    ///
    ///          <note>
    ///             <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
    ///          </note>
    func putImage(input: PutImageInput) async throws -> PutImageOutputResponse
    {
        typealias putImageContinuation = CheckedContinuation<PutImageOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putImageContinuation) in
            putImage(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Create or updates the catalog data for a public registry.</p>
    func putRegistryCatalogData(input: PutRegistryCatalogDataInput) async throws -> PutRegistryCatalogDataOutputResponse
    {
        typealias putRegistryCatalogDataContinuation = CheckedContinuation<PutRegistryCatalogDataOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putRegistryCatalogDataContinuation) in
            putRegistryCatalogData(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates or updates the catalog data for a repository in a public registry.</p>
    func putRepositoryCatalogData(input: PutRepositoryCatalogDataInput) async throws -> PutRepositoryCatalogDataOutputResponse
    {
        typealias putRepositoryCatalogDataContinuation = CheckedContinuation<PutRepositoryCatalogDataOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putRepositoryCatalogDataContinuation) in
            putRepositoryCatalogData(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Applies a repository policy to the specified public repository to control access
    ///          permissions. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policies.html">Amazon ECR Repository
    ///             Policies</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
    func setRepositoryPolicy(input: SetRepositoryPolicyInput) async throws -> SetRepositoryPolicyOutputResponse
    {
        typealias setRepositoryPolicyContinuation = CheckedContinuation<SetRepositoryPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: setRepositoryPolicyContinuation) in
            setRepositoryPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Associates the specified tags to a resource with the specified <code>resourceArn</code>.
    ///          If existing tags on a resource are not specified in the request parameters, they are not
    ///          changed. When a resource is deleted, the tags associated with that resource are deleted as
    ///          well.</p>
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes specified tags from a resource.</p>
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Uploads an image layer part to Amazon ECR.</p>
    ///          <p>When an image is pushed, each new image layer is uploaded in parts. The maximum size of
    ///          each image layer part can be 20971520 bytes (or about 20MB). The UploadLayerPart API is
    ///          called once per each new image layer part.</p>
    ///          <note>
    ///             <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
    ///          </note>
    func uploadLayerPart(input: UploadLayerPartInput) async throws -> UploadLayerPartOutputResponse
    {
        typealias uploadLayerPartContinuation = CheckedContinuation<UploadLayerPartOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: uploadLayerPartContinuation) in
            uploadLayerPart(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
